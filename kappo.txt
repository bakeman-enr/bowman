
/*
 *
 * (C) COPYRIGHT 2011-2014 ARM Limited. All rights reserved.
 *
 * This program is free software and is provided to you under the terms of the
 * GNU General Public License version 2 as published by the Free Software
 * Foundation, and any use by you of this program is subject to the terms
 * of such GNU licence.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, you can access it online at
 * http://www.gnu.org/licenses/gpl-2.0.html.
 *
 * SPDX-License-Identifier: GPL-2.0
 *
 */





/* ***** IMPORTANT: THIS IS NOT A NORMAL HEADER FILE         *****
 * *****            DO NOT INCLUDE DIRECTLY                  *****
 * *****            THE LACK OF HEADER GUARDS IS INTENTIONAL ***** */

/*
 * The purpose of this header file is just to contain a list of trace code idenitifers
 *
 * Each identifier is wrapped in a macro, so that its string form and enum form can be created
 *
 * Each macro is separated with a comma, to allow insertion into an array initializer or enum definition block.
 *
 * This allows automatic creation of an enum and a corresponding array of strings
 *
 * Before #including, the includer MUST #define KBASE_TRACE_CODE_MAKE_CODE.
 * After #including, the includer MUST #under KBASE_TRACE_CODE_MAKE_CODE.
 *
 * e.g.:
 * #define KBASE_TRACE_CODE( X ) KBASE_TRACE_CODE_ ## X
 * typedef enum
 * {
 * #define KBASE_TRACE_CODE_MAKE_CODE( X ) KBASE_TRACE_CODE( X )
 * #include "mali_kbase_trace_defs.h"
 * #undef  KBASE_TRACE_CODE_MAKE_CODE
 * } kbase_trace_code;
 *
 * IMPORTANT: THIS FILE MUST NOT BE USED FOR ANY OTHER PURPOSE OTHER THAN THE ABOVE
 *
 *
 * The use of the macro here is:
 * - KBASE_TRACE_CODE_MAKE_CODE( X )
 *
 * Which produces:
 * - For an enum, KBASE_TRACE_CODE_X
 * - For a string, "X"
 *
 *
 * For example:
 * - KBASE_TRACE_CODE_MAKE_CODE( JM_JOB_COMPLETE ) expands to:
 *  - KBASE_TRACE_CODE_JM_JOB_COMPLETE for the enum
 *  - "JM_JOB_COMPLETE" for the string
 * - To use it to trace an event, do:
 *  - KBASE_TRACE_ADD( kbdev, JM_JOB_COMPLETE, subcode, kctx, uatom, val );
 */

#if 0 /* Dummy section to avoid breaking formatting */
int dummy_array[] = {
#endif

/*
 * Core events
 */
	/* no info_val, no gpu_addr, no atom */
	KBASE_TRACE_CODE_MAKE_CODE(CORE_CTX_DESTROY),
	/* no info_val, no gpu_addr, no atom */
	KBASE_TRACE_CODE_MAKE_CODE(CORE_CTX_HWINSTR_TERM),
	/* info_val == GPU_IRQ_STATUS register */
	KBASE_TRACE_CODE_MAKE_CODE(CORE_GPU_IRQ),
	/* info_val == bits cleared */
	KBASE_TRACE_CODE_MAKE_CODE(CORE_GPU_IRQ_CLEAR),
	/* info_val == GPU_IRQ_STATUS register */
	KBASE_TRACE_CODE_MAKE_CODE(CORE_GPU_IRQ_DONE),
	KBASE_TRACE_CODE_MAKE_CODE(CORE_GPU_SOFT_RESET),
	KBASE_TRACE_CODE_MAKE_CODE(CORE_GPU_HARD_RESET),
	KBASE_TRACE_CODE_MAKE_CODE(CORE_GPU_PRFCNT_CLEAR),
	/* GPU addr==dump address */
	KBASE_TRACE_CODE_MAKE_CODE(CORE_GPU_PRFCNT_SAMPLE),
	KBASE_TRACE_CODE_MAKE_CODE(CORE_GPU_CLEAN_INV_CACHES),
/*
 * Job Slot management events
 */
	/* info_val==irq rawstat at start */
	KBASE_TRACE_CODE_MAKE_CODE(JM_IRQ),
	/* info_val==jobs processed */
	KBASE_TRACE_CODE_MAKE_CODE(JM_IRQ_END),
/* In the following:
 *
 * - ctx is set if a corresponding job found (NULL otherwise, e.g. some soft-stop cases)
 * - uatom==kernel-side mapped uatom address (for correlation with user-side)
 */
	/* info_val==exit code; gpu_addr==chain gpuaddr */
	KBASE_TRACE_CODE_MAKE_CODE(JM_JOB_DONE),
	/* gpu_addr==JS_HEAD_NEXT written, info_val==lower 32 bits of affinity */
	KBASE_TRACE_CODE_MAKE_CODE(JM_SUBMIT),
	/* gpu_addr is as follows:
	 * - If JS_STATUS active after soft-stop, val==gpu addr written to
	 *   JS_HEAD on submit
	 * - otherwise gpu_addr==0 */
	KBASE_TRACE_CODE_MAKE_CODE(JM_SOFTSTOP),
	KBASE_TRACE_CODE_MAKE_CODE(JM_SOFTSTOP_0),
	KBASE_TRACE_CODE_MAKE_CODE(JM_SOFTSTOP_1),
	/* gpu_addr==JS_HEAD read */
	KBASE_TRACE_CODE_MAKE_CODE(JM_HARDSTOP),
	/* gpu_addr==JS_HEAD read */
	KBASE_TRACE_CODE_MAKE_CODE(JM_HARDSTOP_0),
	/* gpu_addr==JS_HEAD read */
	KBASE_TRACE_CODE_MAKE_CODE(JM_HARDSTOP_1),
	/* gpu_addr==JS_TAIL read */
	KBASE_TRACE_CODE_MAKE_CODE(JM_UPDATE_HEAD),
/* gpu_addr is as follows:
 * - If JS_STATUS active before soft-stop, val==JS_HEAD
 * - otherwise gpu_addr==0
 */
	/* gpu_addr==JS_HEAD read */
	KBASE_TRACE_CODE_MAKE_CODE(JM_CHECK_HEAD),
	KBASE_TRACE_CODE_MAKE_CODE(JM_FLUSH_WORKQS),
	KBASE_TRACE_CODE_MAKE_CODE(JM_FLUSH_WORKQS_DONE),
	/* info_val == is_scheduled */
	KBASE_TRACE_CODE_MAKE_CODE(JM_ZAP_NON_SCHEDULED),
	/* info_val == is_scheduled */
	KBASE_TRACE_CODE_MAKE_CODE(JM_ZAP_SCHEDULED),
	KBASE_TRACE_CODE_MAKE_CODE(JM_ZAP_DONE),
	/* info_val == nr jobs submitted */
	KBASE_TRACE_CODE_MAKE_CODE(JM_SLOT_SOFT_OR_HARD_STOP),
	/* gpu_addr==JS_HEAD_NEXT last written */
	KBASE_TRACE_CODE_MAKE_CODE(JM_SLOT_EVICT),
	KBASE_TRACE_CODE_MAKE_CODE(JM_SUBMIT_AFTER_RESET),
	KBASE_TRACE_CODE_MAKE_CODE(JM_BEGIN_RESET_WORKER),
	KBASE_TRACE_CODE_MAKE_CODE(JM_END_RESET_WORKER),
/*
 * Job dispatch events
 */
	/* gpu_addr==value to write into JS_HEAD */
	KBASE_TRACE_CODE_MAKE_CODE(JD_DONE),
	/* gpu_addr==value to write into JS_HEAD */
	KBASE_TRACE_CODE_MAKE_CODE(JD_DONE_WORKER),
	/* gpu_addr==value to write into JS_HEAD */
	KBASE_TRACE_CODE_MAKE_CODE(JD_DONE_WORKER_END),
	/* gpu_addr==value to write into JS_HEAD */
	KBASE_TRACE_CODE_MAKE_CODE(JD_DONE_TRY_RUN_NEXT_JOB),
	/* gpu_addr==0, info_val==0, uatom==0 */
	KBASE_TRACE_CODE_MAKE_CODE(JD_ZAP_CONTEXT),
	/* gpu_addr==value to write into JS_HEAD */
	KBASE_TRACE_CODE_MAKE_CODE(JD_CANCEL),
	/* gpu_addr==value to write into JS_HEAD */
	KBASE_TRACE_CODE_MAKE_CODE(JD_CANCEL_WORKER),
/*
 * Scheduler Core events
 */
	KBASE_TRACE_CODE_MAKE_CODE(JS_RETAIN_CTX_NOLOCK),
	/* gpu_addr==value to write into JS_HEAD */
	KBASE_TRACE_CODE_MAKE_CODE(JS_ADD_JOB),
	/* gpu_addr==last value written/would be written to JS_HEAD */
	KBASE_TRACE_CODE_MAKE_CODE(JS_REMOVE_JOB),
	KBASE_TRACE_CODE_MAKE_CODE(JS_RETAIN_CTX),
	KBASE_TRACE_CODE_MAKE_CODE(JS_RELEASE_CTX),
	KBASE_TRACE_CODE_MAKE_CODE(JS_TRY_SCHEDULE_HEAD_CTX),
	/* gpu_addr==value to write into JS_HEAD */
	KBASE_TRACE_CODE_MAKE_CODE(JS_JOB_DONE_TRY_RUN_NEXT_JOB),
	/* gpu_addr==value to write into JS_HEAD */
	KBASE_TRACE_CODE_MAKE_CODE(JS_JOB_DONE_RETRY_NEEDED),
	/* kctx is the one being evicted, info_val == kctx to put in  */
	KBASE_TRACE_CODE_MAKE_CODE(JS_FAST_START_EVICTS_CTX),
	KBASE_TRACE_CODE_MAKE_CODE(JS_AFFINITY_SUBMIT_TO_BLOCKED),
	/* info_val == lower 32 bits of affinity */
	KBASE_TRACE_CODE_MAKE_CODE(JS_AFFINITY_CURRENT),
	/* info_val == lower 32 bits of affinity */
	KBASE_TRACE_CODE_MAKE_CODE(JS_CORE_REF_REQUEST_CORES_FAILED),
	/* info_val == lower 32 bits of affinity */
	KBASE_TRACE_CODE_MAKE_CODE(JS_CORE_REF_REGISTER_INUSE_FAILED),
	/* info_val == lower 32 bits of rechecked affinity */
	KBASE_TRACE_CODE_MAKE_CODE(JS_CORE_REF_REQUEST_ON_RECHECK_FAILED),
	/* info_val == lower 32 bits of rechecked affinity */
	KBASE_TRACE_CODE_MAKE_CODE(JS_CORE_REF_REGISTER_ON_RECHECK_FAILED),
	/* info_val == lower 32 bits of affinity */
	KBASE_TRACE_CODE_MAKE_CODE(JS_CORE_REF_AFFINITY_WOULD_VIOLATE),
	/* info_val == the ctx attribute now on ctx */
	KBASE_TRACE_CODE_MAKE_CODE(JS_CTX_ATTR_NOW_ON_CTX),
	/* info_val == the ctx attribute now on runpool */
	KBASE_TRACE_CODE_MAKE_CODE(JS_CTX_ATTR_NOW_ON_RUNPOOL),
	/* info_val == the ctx attribute now off ctx */
	KBASE_TRACE_CODE_MAKE_CODE(JS_CTX_ATTR_NOW_OFF_CTX),
	/* info_val == the ctx attribute now off runpool */
	KBASE_TRACE_CODE_MAKE_CODE(JS_CTX_ATTR_NOW_OFF_RUNPOOL),
/*
 * Scheduler Policy events
 */
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_INIT_CTX),
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_TERM_CTX),
	/* info_val == whether it was evicted */
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_TRY_EVICT_CTX),
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_FOREACH_CTX_JOBS),
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_ENQUEUE_CTX),
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_DEQUEUE_HEAD_CTX),
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_RUNPOOL_ADD_CTX),
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_RUNPOOL_REMOVE_CTX),
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_DEQUEUE_JOB),
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_DEQUEUE_JOB_IRQ),
	/* gpu_addr==JS_HEAD to write if the job were run */
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_ENQUEUE_JOB),
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_TIMER_START),
	KBASE_TRACE_CODE_MAKE_CODE(JS_POLICY_TIMER_END),
/*
 * Power Management Events
 */
	KBASE_TRACE_CODE_MAKE_CODE(PM_JOB_SUBMIT_AFTER_POWERING_UP),
	KBASE_TRACE_CODE_MAKE_CODE(PM_JOB_SUBMIT_AFTER_POWERED_UP),
	KBASE_TRACE_CODE_MAKE_CODE(PM_PWRON),
	KBASE_TRACE_CODE_MAKE_CODE(PM_PWRON_TILER),
	KBASE_TRACE_CODE_MAKE_CODE(PM_PWRON_L2),
	KBASE_TRACE_CODE_MAKE_CODE(PM_PWROFF),
	KBASE_TRACE_CODE_MAKE_CODE(PM_PWROFF_TILER),
	KBASE_TRACE_CODE_MAKE_CODE(PM_PWROFF_L2),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CORES_POWERED),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CORES_POWERED_TILER),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CORES_POWERED_L2),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CORES_CHANGE_DESIRED),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CORES_CHANGE_DESIRED_TILER),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CORES_CHANGE_AVAILABLE),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CORES_CHANGE_AVAILABLE_TILER),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CORES_AVAILABLE),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CORES_AVAILABLE_TILER),
	/* PM_DESIRED_REACHED: gpu_addr == pm.gpu_in_desired_state */
	KBASE_TRACE_CODE_MAKE_CODE(PM_DESIRED_REACHED),
	KBASE_TRACE_CODE_MAKE_CODE(PM_DESIRED_REACHED_TILER),
	KBASE_TRACE_CODE_MAKE_CODE(PM_REGISTER_CHANGE_SHADER_INUSE),
	KBASE_TRACE_CODE_MAKE_CODE(PM_REGISTER_CHANGE_TILER_INUSE),
	KBASE_TRACE_CODE_MAKE_CODE(PM_REGISTER_CHANGE_SHADER_NEEDED),
	KBASE_TRACE_CODE_MAKE_CODE(PM_REGISTER_CHANGE_TILER_NEEDED),
	KBASE_TRACE_CODE_MAKE_CODE(PM_RELEASE_CHANGE_SHADER_INUSE),
	KBASE_TRACE_CODE_MAKE_CODE(PM_RELEASE_CHANGE_TILER_INUSE),
	KBASE_TRACE_CODE_MAKE_CODE(PM_UNREQUEST_CHANGE_SHADER_NEEDED),
	KBASE_TRACE_CODE_MAKE_CODE(PM_UNREQUEST_CHANGE_TILER_NEEDED),
	KBASE_TRACE_CODE_MAKE_CODE(PM_REQUEST_CHANGE_SHADER_NEEDED),
	KBASE_TRACE_CODE_MAKE_CODE(PM_REQUEST_CHANGE_TILER_NEEDED),
	KBASE_TRACE_CODE_MAKE_CODE(PM_WAKE_WAITERS),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CONTEXT_ACTIVE),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CONTEXT_IDLE),
	KBASE_TRACE_CODE_MAKE_CODE(PM_GPU_ON),
	KBASE_TRACE_CODE_MAKE_CODE(PM_GPU_OFF),
	/* info_val == policy number, or -1 for "Already changing" */
	KBASE_TRACE_CODE_MAKE_CODE(PM_SET_POLICY),
	KBASE_TRACE_CODE_MAKE_CODE(PM_CA_SET_POLICY),
	/* info_val == policy number */
	KBASE_TRACE_CODE_MAKE_CODE(PM_CURRENT_POLICY_INIT),
	/* info_val == policy number */
	KBASE_TRACE_CODE_MAKE_CODE(PM_CURRENT_POLICY_TERM),

/* MALI_SEC_INTEGRATION */
#include "platform/exynos/gpu_trace_defs.h"

/* Unused code just to make it easier to not have a comma at the end.
 * All other codes MUST come before this */
	KBASE_TRACE_CODE_MAKE_CODE(DUMMY)

#if 0 /* Dummy section to avoid breaking formatting */
};
#endif

/* ***** THE LACK OF HEADER GUARDS IS INTENTIONAL ***** */

/* SPDX-License-Identifier: GPL-2.0 */
/*
 * The canonical list of T10 Additional Sense Codes is available at:
 * http://www.t10.org/lists/asc-num.txt [most recent: 20141221]
 */

SENSE_CODE(0x0000, "No additional sense information")
SENSE_CODE(0x0001, "Filemark detected")
SENSE_CODE(0x0002, "End-of-partition/medium detected")
SENSE_CODE(0x0003, "Setmark detected")
SENSE_CODE(0x0004, "Beginning-of-partition/medium detected")
SENSE_CODE(0x0005, "End-of-data detected")
SENSE_CODE(0x0006, "I/O process terminated")
SENSE_CODE(0x0007, "Programmable early warning detected")
SENSE_CODE(0x0011, "Audio play operation in progress")
SENSE_CODE(0x0012, "Audio play operation paused")
SENSE_CODE(0x0013, "Audio play operation successfully completed")
SENSE_CODE(0x0014, "Audio play operation stopped due to error")
SENSE_CODE(0x0015, "No current audio status to return")
SENSE_CODE(0x0016, "Operation in progress")
SENSE_CODE(0x0017, "Cleaning requested")
SENSE_CODE(0x0018, "Erase operation in progress")
SENSE_CODE(0x0019, "Locate operation in progress")
SENSE_CODE(0x001A, "Rewind operation in progress")
SENSE_CODE(0x001B, "Set capacity operation in progress")
SENSE_CODE(0x001C, "Verify operation in progress")
SENSE_CODE(0x001D, "ATA pass through information available")
SENSE_CODE(0x001E, "Conflicting SA creation request")
SENSE_CODE(0x001F, "Logical unit transitioning to another power condition")
SENSE_CODE(0x0020, "Extended copy information available")
SENSE_CODE(0x0021, "Atomic command aborted due to ACA")

SENSE_CODE(0x0100, "No index/sector signal")

SENSE_CODE(0x0200, "No seek complete")

SENSE_CODE(0x0300, "Peripheral device write fault")
SENSE_CODE(0x0301, "No write current")
SENSE_CODE(0x0302, "Excessive write errors")

SENSE_CODE(0x0400, "Logical unit not ready, cause not reportable")
SENSE_CODE(0x0401, "Logical unit is in process of becoming ready")
SENSE_CODE(0x0402, "Logical unit not ready, initializing command required")
SENSE_CODE(0x0403, "Logical unit not ready, manual intervention required")
SENSE_CODE(0x0404, "Logical unit not ready, format in progress")
SENSE_CODE(0x0405, "Logical unit not ready, rebuild in progress")
SENSE_CODE(0x0406, "Logical unit not ready, recalculation in progress")
SENSE_CODE(0x0407, "Logical unit not ready, operation in progress")
SENSE_CODE(0x0408, "Logical unit not ready, long write in progress")
SENSE_CODE(0x0409, "Logical unit not ready, self-test in progress")
SENSE_CODE(0x040A, "Logical unit not accessible, asymmetric access state transition")
SENSE_CODE(0x040B, "Logical unit not accessible, target port in standby state")
SENSE_CODE(0x040C, "Logical unit not accessible, target port in unavailable state")
SENSE_CODE(0x040D, "Logical unit not ready, structure check required")
SENSE_CODE(0x040E, "Logical unit not ready, security session in progress")
SENSE_CODE(0x0410, "Logical unit not ready, auxiliary memory not accessible")
SENSE_CODE(0x0411, "Logical unit not ready, notify (enable spinup) required")
SENSE_CODE(0x0412, "Logical unit not ready, offline")
SENSE_CODE(0x0413, "Logical unit not ready, SA creation in progress")
SENSE_CODE(0x0414, "Logical unit not ready, space allocation in progress")
SENSE_CODE(0x0415, "Logical unit not ready, robotics disabled")
SENSE_CODE(0x0416, "Logical unit not ready, configuration required")
SENSE_CODE(0x0417, "Logical unit not ready, calibration required")
SENSE_CODE(0x0418, "Logical unit not ready, a door is open")
SENSE_CODE(0x0419, "Logical unit not ready, operating in sequential mode")
SENSE_CODE(0x041A, "Logical unit not ready, start stop unit command in progress")
SENSE_CODE(0x041B, "Logical unit not ready, sanitize in progress")
SENSE_CODE(0x041C, "Logical unit not ready, additional power use not yet granted")
SENSE_CODE(0x041D, "Logical unit not ready, configuration in progress")
SENSE_CODE(0x041E, "Logical unit not ready, microcode activation required")
SENSE_CODE(0x041F, "Logical unit not ready, microcode download required")
SENSE_CODE(0x0420, "Logical unit not ready, logical unit reset required")
SENSE_CODE(0x0421, "Logical unit not ready, hard reset required")
SENSE_CODE(0x0422, "Logical unit not ready, power cycle required")

SENSE_CODE(0x0500, "Logical unit does not respond to selection")

SENSE_CODE(0x0600, "No reference position found")

SENSE_CODE(0x0700, "Multiple peripheral devices selected")

SENSE_CODE(0x0800, "Logical unit communication failure")
SENSE_CODE(0x0801, "Logical unit communication time-out")
SENSE_CODE(0x0802, "Logical unit communication parity error")
SENSE_CODE(0x0803, "Logical unit communication CRC error (Ultra-DMA/32)")
SENSE_CODE(0x0804, "Unreachable copy target")

SENSE_CODE(0x0900, "Track following error")
SENSE_CODE(0x0901, "Tracking servo failure")
SENSE_CODE(0x0902, "Focus servo failure")
SENSE_CODE(0x0903, "Spindle servo failure")
SENSE_CODE(0x0904, "Head select fault")
SENSE_CODE(0x0905, "Vibration induced tracking error")

SENSE_CODE(0x0A00, "Error log overflow")

SENSE_CODE(0x0B00, "Warning")
SENSE_CODE(0x0B01, "Warning - specified temperature exceeded")
SENSE_CODE(0x0B02, "Warning - enclosure degraded")
SENSE_CODE(0x0B03, "Warning - background self-test failed")
SENSE_CODE(0x0B04, "Warning - background pre-scan detected medium error")
SENSE_CODE(0x0B05, "Warning - background medium scan detected medium error")
SENSE_CODE(0x0B06, "Warning - non-volatile cache now volatile")
SENSE_CODE(0x0B07, "Warning - degraded power to non-volatile cache")
SENSE_CODE(0x0B08, "Warning - power loss expected")
SENSE_CODE(0x0B09, "Warning - device statistics notification active")

SENSE_CODE(0x0C00, "Write error")
SENSE_CODE(0x0C01, "Write error - recovered with auto reallocation")
SENSE_CODE(0x0C02, "Write error - auto reallocation failed")
SENSE_CODE(0x0C03, "Write error - recommend reassignment")
SENSE_CODE(0x0C04, "Compression check miscompare error")
SENSE_CODE(0x0C05, "Data expansion occurred during compression")
SENSE_CODE(0x0C06, "Block not compressible")
SENSE_CODE(0x0C07, "Write error - recovery needed")
SENSE_CODE(0x0C08, "Write error - recovery failed")
SENSE_CODE(0x0C09, "Write error - loss of streaming")
SENSE_CODE(0x0C0A, "Write error - padding blocks added")
SENSE_CODE(0x0C0B, "Auxiliary memory write error")
SENSE_CODE(0x0C0C, "Write error - unexpected unsolicited data")
SENSE_CODE(0x0C0D, "Write error - not enough unsolicited data")
SENSE_CODE(0x0C0E, "Multiple write errors")
SENSE_CODE(0x0C0F, "Defects in error window")
SENSE_CODE(0x0C10, "Incomplete multiple atomic write operations")

SENSE_CODE(0x0D00, "Error detected by third party temporary initiator")
SENSE_CODE(0x0D01, "Third party device failure")
SENSE_CODE(0x0D02, "Copy target device not reachable")
SENSE_CODE(0x0D03, "Incorrect copy target device type")
SENSE_CODE(0x0D04, "Copy target device data underrun")
SENSE_CODE(0x0D05, "Copy target device data overrun")

SENSE_CODE(0x0E00, "Invalid information unit")
SENSE_CODE(0x0E01, "Information unit too short")
SENSE_CODE(0x0E02, "Information unit too long")
SENSE_CODE(0x0E03, "Invalid field in command information unit")

SENSE_CODE(0x1000, "Id CRC or ECC error")
SENSE_CODE(0x1001, "Logical block guard check failed")
SENSE_CODE(0x1002, "Logical block application tag check failed")
SENSE_CODE(0x1003, "Logical block reference tag check failed")
SENSE_CODE(0x1004, "Logical block protection error on recover buffered data")
SENSE_CODE(0x1005, "Logical block protection method error")

SENSE_CODE(0x1100, "Unrecovered read error")
SENSE_CODE(0x1101, "Read retries exhausted")
SENSE_CODE(0x1102, "Error too long to correct")
SENSE_CODE(0x1103, "Multiple read errors")
SENSE_CODE(0x1104, "Unrecovered read error - auto reallocate failed")
SENSE_CODE(0x1105, "L-EC uncorrectable error")
SENSE_CODE(0x1106, "CIRC unrecovered error")
SENSE_CODE(0x1107, "Data re-synchronization error")
SENSE_CODE(0x1108, "Incomplete block read")
SENSE_CODE(0x1109, "No gap found")
SENSE_CODE(0x110A, "Miscorrected error")
SENSE_CODE(0x110B, "Unrecovered read error - recommend reassignment")
SENSE_CODE(0x110C, "Unrecovered read error - recommend rewrite the data")
SENSE_CODE(0x110D, "De-compression CRC error")
SENSE_CODE(0x110E, "Cannot decompress using declared algorithm")
SENSE_CODE(0x110F, "Error reading UPC/EAN number")
SENSE_CODE(0x1110, "Error reading ISRC number")
SENSE_CODE(0x1111, "Read error - loss of streaming")
SENSE_CODE(0x1112, "Auxiliary memory read error")
SENSE_CODE(0x1113, "Read error - failed retransmission request")
SENSE_CODE(0x1114, "Read error - lba marked bad by application client")
SENSE_CODE(0x1115, "Write after sanitize required")

SENSE_CODE(0x1200, "Address mark not found for id field")

SENSE_CODE(0x1300, "Address mark not found for data field")

SENSE_CODE(0x1400, "Recorded entity not found")
SENSE_CODE(0x1401, "Record not found")
SENSE_CODE(0x1402, "Filemark or setmark not found")
SENSE_CODE(0x1403, "End-of-data not found")
SENSE_CODE(0x1404, "Block sequence error")
SENSE_CODE(0x1405, "Record not found - recommend reassignment")
SENSE_CODE(0x1406, "Record not found - data auto-reallocated")
SENSE_CODE(0x1407, "Locate operation failure")

SENSE_CODE(0x1500, "Random positioning error")
SENSE_CODE(0x1501, "Mechanical positioning error")
SENSE_CODE(0x1502, "Positioning error detected by read of medium")

SENSE_CODE(0x1600, "Data synchronization mark error")
SENSE_CODE(0x1601, "Data sync error - data rewritten")
SENSE_CODE(0x1602, "Data sync error - recommend rewrite")
SENSE_CODE(0x1603, "Data sync error - data auto-reallocated")
SENSE_CODE(0x1604, "Data sync error - recommend reassignment")

SENSE_CODE(0x1700, "Recovered data with no error correction applied")
SENSE_CODE(0x1701, "Recovered data with retries")
SENSE_CODE(0x1702, "Recovered data with positive head offset")
SENSE_CODE(0x1703, "Recovered data with negative head offset")
SENSE_CODE(0x1704, "Recovered data with retries and/or circ applied")
SENSE_CODE(0x1705, "Recovered data using previous sector id")
SENSE_CODE(0x1706, "Recovered data without ECC - data auto-reallocated")
SENSE_CODE(0x1707, "Recovered data without ECC - recommend reassignment")
SENSE_CODE(0x1708, "Recovered data without ECC - recommend rewrite")
SENSE_CODE(0x1709, "Recovered data without ECC - data rewritten")

SENSE_CODE(0x1800, "Recovered data with error correction applied")
SENSE_CODE(0x1801, "Recovered data with error corr. & retries applied")
SENSE_CODE(0x1802, "Recovered data - data auto-reallocated")
SENSE_CODE(0x1803, "Recovered data with CIRC")
SENSE_CODE(0x1804, "Recovered data with L-EC")
SENSE_CODE(0x1805, "Recovered data - recommend reassignment")
SENSE_CODE(0x1806, "Recovered data - recommend rewrite")
SENSE_CODE(0x1807, "Recovered data with ECC - data rewritten")
SENSE_CODE(0x1808, "Recovered data with linking")

SENSE_CODE(0x1900, "Defect list error")
SENSE_CODE(0x1901, "Defect list not available")
SENSE_CODE(0x1902, "Defect list error in primary list")
SENSE_CODE(0x1903, "Defect list error in grown list")

SENSE_CODE(0x1A00, "Parameter list length error")

SENSE_CODE(0x1B00, "Synchronous data transfer error")

SENSE_CODE(0x1C00, "Defect list not found")
SENSE_CODE(0x1C01, "Primary defect list not found")
SENSE_CODE(0x1C02, "Grown defect list not found")

SENSE_CODE(0x1D00, "Miscompare during verify operation")
SENSE_CODE(0x1D01, "Miscompare verify of unmapped LBA")

SENSE_CODE(0x1E00, "Recovered id with ECC correction")

SENSE_CODE(0x1F00, "Partial defect list transfer")

SENSE_CODE(0x2000, "Invalid command operation code")
SENSE_CODE(0x2001, "Access denied - initiator pending-enrolled")
SENSE_CODE(0x2002, "Access denied - no access rights")
SENSE_CODE(0x2003, "Access denied - invalid mgmt id key")
SENSE_CODE(0x2004, "Illegal command while in write capable state")
SENSE_CODE(0x2005, "Obsolete")
SENSE_CODE(0x2006, "Illegal command while in explicit address mode")
SENSE_CODE(0x2007, "Illegal command while in implicit address mode")
SENSE_CODE(0x2008, "Access denied - enrollment conflict")
SENSE_CODE(0x2009, "Access denied - invalid LU identifier")
SENSE_CODE(0x200A, "Access denied - invalid proxy token")
SENSE_CODE(0x200B, "Access denied - ACL LUN conflict")
SENSE_CODE(0x200C, "Illegal command when not in append-only mode")

SENSE_CODE(0x2100, "Logical block address out of range")
SENSE_CODE(0x2101, "Invalid element address")
SENSE_CODE(0x2102, "Invalid address for write")
SENSE_CODE(0x2103, "Invalid write crossing layer jump")
SENSE_CODE(0x2104, "Unaligned write command")
SENSE_CODE(0x2105, "Write boundary violation")
SENSE_CODE(0x2106, "Attempt to read invalid data")
SENSE_CODE(0x2107, "Read boundary violation")

SENSE_CODE(0x2200, "Illegal function (use 20 00, 24 00, or 26 00)")

SENSE_CODE(0x2300, "Invalid token operation, cause not reportable")
SENSE_CODE(0x2301, "Invalid token operation, unsupported token type")
SENSE_CODE(0x2302, "Invalid token operation, remote token usage not supported")
SENSE_CODE(0x2303, "Invalid token operation, remote rod token creation not supported")
SENSE_CODE(0x2304, "Invalid token operation, token unknown")
SENSE_CODE(0x2305, "Invalid token operation, token corrupt")
SENSE_CODE(0x2306, "Invalid token operation, token revoked")
SENSE_CODE(0x2307, "Invalid token operation, token expired")
SENSE_CODE(0x2308, "Invalid token operation, token cancelled")
SENSE_CODE(0x2309, "Invalid token operation, token deleted")
SENSE_CODE(0x230A, "Invalid token operation, invalid token length")

SENSE_CODE(0x2400, "Invalid field in cdb")
SENSE_CODE(0x2401, "CDB decryption error")
SENSE_CODE(0x2402, "Obsolete")
SENSE_CODE(0x2403, "Obsolete")
SENSE_CODE(0x2404, "Security audit value frozen")
SENSE_CODE(0x2405, "Security working key frozen")
SENSE_CODE(0x2406, "Nonce not unique")
SENSE_CODE(0x2407, "Nonce timestamp out of range")
SENSE_CODE(0x2408, "Invalid XCDB")

SENSE_CODE(0x2500, "Logical unit not supported")

SENSE_CODE(0x2600, "Invalid field in parameter list")
SENSE_CODE(0x2601, "Parameter not supported")
SENSE_CODE(0x2602, "Parameter value invalid")
SENSE_CODE(0x2603, "Threshold parameters not supported")
SENSE_CODE(0x2604, "Invalid release of persistent reservation")
SENSE_CODE(0x2605, "Data decryption error")
SENSE_CODE(0x2606, "Too many target descriptors")
SENSE_CODE(0x2607, "Unsupported target descriptor type code")
SENSE_CODE(0x2608, "Too many segment descriptors")
SENSE_CODE(0x2609, "Unsupported segment descriptor type code")
SENSE_CODE(0x260A, "Unexpected inexact segment")
SENSE_CODE(0x260B, "Inline data length exceeded")
SENSE_CODE(0x260C, "Invalid operation for copy source or destination")
SENSE_CODE(0x260D, "Copy segment granularity violation")
SENSE_CODE(0x260E, "Invalid parameter while port is enabled")
SENSE_CODE(0x260F, "Invalid data-out buffer integrity check value")
SENSE_CODE(0x2610, "Data decryption key fail limit reached")
SENSE_CODE(0x2611, "Incomplete key-associated data set")
SENSE_CODE(0x2612, "Vendor specific key reference not found")

SENSE_CODE(0x2700, "Write protected")
SENSE_CODE(0x2701, "Hardware write protected")
SENSE_CODE(0x2702, "Logical unit software write protected")
SENSE_CODE(0x2703, "Associated write protect")
SENSE_CODE(0x2704, "Persistent write protect")
SENSE_CODE(0x2705, "Permanent write protect")
SENSE_CODE(0x2706, "Conditional write protect")
SENSE_CODE(0x2707, "Space allocation failed write protect")
SENSE_CODE(0x2708, "Zone is read only")

SENSE_CODE(0x2800, "Not ready to ready change, medium may have changed")
SENSE_CODE(0x2801, "Import or export element accessed")
SENSE_CODE(0x2802, "Format-layer may have changed")
SENSE_CODE(0x2803, "Import/export element accessed, medium changed")

SENSE_CODE(0x2900, "Power on, reset, or bus device reset occurred")
SENSE_CODE(0x2901, "Power on occurred")
SENSE_CODE(0x2902, "Scsi bus reset occurred")
SENSE_CODE(0x2903, "Bus device reset function occurred")
SENSE_CODE(0x2904, "Device internal reset")
SENSE_CODE(0x2905, "Transceiver mode changed to single-ended")
SENSE_CODE(0x2906, "Transceiver mode changed to lvd")
SENSE_CODE(0x2907, "I_T nexus loss occurred")

SENSE_CODE(0x2A00, "Parameters changed")
SENSE_CODE(0x2A01, "Mode parameters changed")
SENSE_CODE(0x2A02, "Log parameters changed")
SENSE_CODE(0x2A03, "Reservations preempted")
SENSE_CODE(0x2A04, "Reservations released")
SENSE_CODE(0x2A05, "Registrations preempted")
SENSE_CODE(0x2A06, "Asymmetric access state changed")
SENSE_CODE(0x2A07, "Implicit asymmetric access state transition failed")
SENSE_CODE(0x2A08, "Priority changed")
SENSE_CODE(0x2A09, "Capacity data has changed")
SENSE_CODE(0x2A0A, "Error history I_T nexus cleared")
SENSE_CODE(0x2A0B, "Error history snapshot released")
SENSE_CODE(0x2A0C, "Error recovery attributes have changed")
SENSE_CODE(0x2A0D, "Data encryption capabilities changed")
SENSE_CODE(0x2A10, "Timestamp changed")
SENSE_CODE(0x2A11, "Data encryption parameters changed by another i_t nexus")
SENSE_CODE(0x2A12, "Data encryption parameters changed by vendor specific event")
SENSE_CODE(0x2A13, "Data encryption key instance counter has changed")
SENSE_CODE(0x2A14, "SA creation capabilities data has changed")
SENSE_CODE(0x2A15, "Medium removal prevention preempted")

SENSE_CODE(0x2B00, "Copy cannot execute since host cannot disconnect")

SENSE_CODE(0x2C00, "Command sequence error")
SENSE_CODE(0x2C01, "Too many windows specified")
SENSE_CODE(0x2C02, "Invalid combination of windows specified")
SENSE_CODE(0x2C03, "Current program area is not empty")
SENSE_CODE(0x2C04, "Current program area is empty")
SENSE_CODE(0x2C05, "Illegal power condition request")
SENSE_CODE(0x2C06, "Persistent prevent conflict")
SENSE_CODE(0x2C07, "Previous busy status")
SENSE_CODE(0x2C08, "Previous task set full status")
SENSE_CODE(0x2C09, "Previous reservation conflict status")
SENSE_CODE(0x2C0A, "Partition or collection contains user objects")
SENSE_CODE(0x2C0B, "Not reserved")
SENSE_CODE(0x2C0C, "Orwrite generation does not match")
SENSE_CODE(0x2C0D, "Reset write pointer not allowed")
SENSE_CODE(0x2C0E, "Zone is offline")

SENSE_CODE(0x2D00, "Overwrite error on update in place")

SENSE_CODE(0x2E00, "Insufficient time for operation")
SENSE_CODE(0x2E01, "Command timeout before processing")
SENSE_CODE(0x2E02, "Command timeout during processing")
SENSE_CODE(0x2E03, "Command timeout during processing due to error recovery")

SENSE_CODE(0x2F00, "Commands cleared by another initiator")
SENSE_CODE(0x2F01, "Commands cleared by power loss notification")
SENSE_CODE(0x2F02, "Commands cleared by device server")
SENSE_CODE(0x2F03, "Some commands cleared by queuing layer event")

SENSE_CODE(0x3000, "Incompatible medium installed")
SENSE_CODE(0x3001, "Cannot read medium - unknown format")
SENSE_CODE(0x3002, "Cannot read medium - incompatible format")
SENSE_CODE(0x3003, "Cleaning cartridge installed")
SENSE_CODE(0x3004, "Cannot write medium - unknown format")
SENSE_CODE(0x3005, "Cannot write medium - incompatible format")
SENSE_CODE(0x3006, "Cannot format medium - incompatible medium")
SENSE_CODE(0x3007, "Cleaning failure")
SENSE_CODE(0x3008, "Cannot write - application code mismatch")
SENSE_CODE(0x3009, "Current session not fixated for append")
SENSE_CODE(0x300A, "Cleaning request rejected")
SENSE_CODE(0x300C, "WORM medium - overwrite attempted")
SENSE_CODE(0x300D, "WORM medium - integrity check")
SENSE_CODE(0x3010, "Medium not formatted")
SENSE_CODE(0x3011, "Incompatible volume type")
SENSE_CODE(0x3012, "Incompatible volume qualifier")
SENSE_CODE(0x3013, "Cleaning volume expired")

SENSE_CODE(0x3100, "Medium format corrupted")
SENSE_CODE(0x3101, "Format command failed")
SENSE_CODE(0x3102, "Zoned formatting failed due to spare linking")
SENSE_CODE(0x3103, "Sanitize command failed")

SENSE_CODE(0x3200, "No defect spare location available")
SENSE_CODE(0x3201, "Defect list update failure")

SENSE_CODE(0x3300, "Tape length error")

SENSE_CODE(0x3400, "Enclosure failure")

SENSE_CODE(0x3500, "Enclosure services failure")
SENSE_CODE(0x3501, "Unsupported enclosure function")
SENSE_CODE(0x3502, "Enclosure services unavailable")
SENSE_CODE(0x3503, "Enclosure services transfer failure")
SENSE_CODE(0x3504, "Enclosure services transfer refused")
SENSE_CODE(0x3505, "Enclosure services checksum error")

SENSE_CODE(0x3600, "Ribbon, ink, or toner failure")

SENSE_CODE(0x3700, "Rounded parameter")

SENSE_CODE(0x3800, "Event status notification")
SENSE_CODE(0x3802, "Esn - power management class event")
SENSE_CODE(0x3804, "Esn - media class event")
SENSE_CODE(0x3806, "Esn - device busy class event")
SENSE_CODE(0x3807, "Thin Provisioning soft threshold reached")

SENSE_CODE(0x3900, "Saving parameters not supported")

SENSE_CODE(0x3A00, "Medium not present")
SENSE_CODE(0x3A01, "Medium not present - tray closed")
SENSE_CODE(0x3A02, "Medium not present - tray open")
SENSE_CODE(0x3A03, "Medium not present - loadable")
SENSE_CODE(0x3A04, "Medium not present - medium auxiliary memory accessible")

SENSE_CODE(0x3B00, "Sequential positioning error")
SENSE_CODE(0x3B01, "Tape position error at beginning-of-medium")
SENSE_CODE(0x3B02, "Tape position error at end-of-medium")
SENSE_CODE(0x3B03, "Tape or electronic vertical forms unit not ready")
SENSE_CODE(0x3B04, "Slew failure")
SENSE_CODE(0x3B05, "Paper jam")
SENSE_CODE(0x3B06, "Failed to sense top-of-form")
SENSE_CODE(0x3B07, "Failed to sense bottom-of-form")
SENSE_CODE(0x3B08, "Reposition error")
SENSE_CODE(0x3B09, "Read past end of medium")
SENSE_CODE(0x3B0A, "Read past beginning of medium")
SENSE_CODE(0x3B0B, "Position past end of medium")
SENSE_CODE(0x3B0C, "Position past beginning of medium")
SENSE_CODE(0x3B0D, "Medium destination element full")
SENSE_CODE(0x3B0E, "Medium source element empty")
SENSE_CODE(0x3B0F, "End of medium reached")
SENSE_CODE(0x3B11, "Medium magazine not accessible")
SENSE_CODE(0x3B12, "Medium magazine removed")
SENSE_CODE(0x3B13, "Medium magazine inserted")
SENSE_CODE(0x3B14, "Medium magazine locked")
SENSE_CODE(0x3B15, "Medium magazine unlocked")
SENSE_CODE(0x3B16, "Mechanical positioning or changer error")
SENSE_CODE(0x3B17, "Read past end of user object")
SENSE_CODE(0x3B18, "Element disabled")
SENSE_CODE(0x3B19, "Element enabled")
SENSE_CODE(0x3B1A, "Data transfer device removed")
SENSE_CODE(0x3B1B, "Data transfer device inserted")
SENSE_CODE(0x3B1C, "Too many logical objects on partition to support operation")

SENSE_CODE(0x3D00, "Invalid bits in identify message")

SENSE_CODE(0x3E00, "Logical unit has not self-configured yet")
SENSE_CODE(0x3E01, "Logical unit failure")
SENSE_CODE(0x3E02, "Timeout on logical unit")
SENSE_CODE(0x3E03, "Logical unit failed self-test")
SENSE_CODE(0x3E04, "Logical unit unable to update self-test log")

SENSE_CODE(0x3F00, "Target operating conditions have changed")
SENSE_CODE(0x3F01, "Microcode has been changed")
SENSE_CODE(0x3F02, "Changed operating definition")
SENSE_CODE(0x3F03, "Inquiry data has changed")
SENSE_CODE(0x3F04, "Component device attached")
SENSE_CODE(0x3F05, "Device identifier changed")
SENSE_CODE(0x3F06, "Redundancy group created or modified")
SENSE_CODE(0x3F07, "Redundancy group deleted")
SENSE_CODE(0x3F08, "Spare created or modified")
SENSE_CODE(0x3F09, "Spare deleted")
SENSE_CODE(0x3F0A, "Volume set created or modified")
SENSE_CODE(0x3F0B, "Volume set deleted")
SENSE_CODE(0x3F0C, "Volume set deassigned")
SENSE_CODE(0x3F0D, "Volume set reassigned")
SENSE_CODE(0x3F0E, "Reported luns data has changed")
SENSE_CODE(0x3F0F, "Echo buffer overwritten")
SENSE_CODE(0x3F10, "Medium loadable")
SENSE_CODE(0x3F11, "Medium auxiliary memory accessible")
SENSE_CODE(0x3F12, "iSCSI IP address added")
SENSE_CODE(0x3F13, "iSCSI IP address removed")
SENSE_CODE(0x3F14, "iSCSI IP address changed")
SENSE_CODE(0x3F15, "Inspect referrals sense descriptors")
SENSE_CODE(0x3F16, "Microcode has been changed without reset")
/*
 *	SENSE_CODE(0x40NN, "Ram failure")
 *	SENSE_CODE(0x40NN, "Diagnostic failure on component nn")
 *	SENSE_CODE(0x41NN, "Data path failure")
 *	SENSE_CODE(0x42NN, "Power-on or self-test failure")
 */
SENSE_CODE(0x4300, "Message error")

SENSE_CODE(0x4400, "Internal target failure")
SENSE_CODE(0x4401, "Persistent reservation information lost")
SENSE_CODE(0x4471, "ATA device failed set features")

SENSE_CODE(0x4500, "Select or reselect failure")

SENSE_CODE(0x4600, "Unsuccessful soft reset")

SENSE_CODE(0x4700, "Scsi parity error")
SENSE_CODE(0x4701, "Data phase CRC error detected")
SENSE_CODE(0x4702, "Scsi parity error detected during st data phase")
SENSE_CODE(0x4703, "Information unit iuCRC error detected")
SENSE_CODE(0x4704, "Asynchronous information protection error detected")
SENSE_CODE(0x4705, "Protocol service CRC error")
SENSE_CODE(0x4706, "Phy test function in progress")
SENSE_CODE(0x477f, "Some commands cleared by iSCSI Protocol event")

SENSE_CODE(0x4800, "Initiator detected error message received")

SENSE_CODE(0x4900, "Invalid message error")

SENSE_CODE(0x4A00, "Command phase error")

SENSE_CODE(0x4B00, "Data phase error")
SENSE_CODE(0x4B01, "Invalid target port transfer tag received")
SENSE_CODE(0x4B02, "Too much write data")
SENSE_CODE(0x4B03, "Ack/nak timeout")
SENSE_CODE(0x4B04, "Nak received")
SENSE_CODE(0x4B05, "Data offset error")
SENSE_CODE(0x4B06, "Initiator response timeout")
SENSE_CODE(0x4B07, "Connection lost")
SENSE_CODE(0x4B08, "Data-in buffer overflow - data buffer size")
SENSE_CODE(0x4B09, "Data-in buffer overflow - data buffer descriptor area")
SENSE_CODE(0x4B0A, "Data-in buffer error")
SENSE_CODE(0x4B0B, "Data-out buffer overflow - data buffer size")
SENSE_CODE(0x4B0C, "Data-out buffer overflow - data buffer descriptor area")
SENSE_CODE(0x4B0D, "Data-out buffer error")
SENSE_CODE(0x4B0E, "PCIe fabric error")
SENSE_CODE(0x4B0F, "PCIe completion timeout")
SENSE_CODE(0x4B10, "PCIe completer abort")
SENSE_CODE(0x4B11, "PCIe poisoned tlp received")
SENSE_CODE(0x4B12, "PCIe eCRC check failed")
SENSE_CODE(0x4B13, "PCIe unsupported request")
SENSE_CODE(0x4B14, "PCIe acs violation")
SENSE_CODE(0x4B15, "PCIe tlp prefix blocked")

SENSE_CODE(0x4C00, "Logical unit failed self-configuration")
/*
 *	SENSE_CODE(0x4DNN, "Tagged overlapped commands (nn = queue tag)")
 */
SENSE_CODE(0x4E00, "Overlapped commands attempted")

SENSE_CODE(0x5000, "Write append error")
SENSE_CODE(0x5001, "Write append position error")
SENSE_CODE(0x5002, "Position error related to timing")

SENSE_CODE(0x5100, "Erase failure")
SENSE_CODE(0x5101, "Erase failure - incomplete erase operation detected")

SENSE_CODE(0x5200, "Cartridge fault")

SENSE_CODE(0x5300, "Media load or eject failed")
SENSE_CODE(0x5301, "Unload tape failure")
SENSE_CODE(0x5302, "Medium removal prevented")
SENSE_CODE(0x5303, "Medium removal prevented by data transfer element")
SENSE_CODE(0x5304, "Medium thread or unthread failure")
SENSE_CODE(0x5305, "Volume identifier invalid")
SENSE_CODE(0x5306, "Volume identifier missing")
SENSE_CODE(0x5307, "Duplicate volume identifier")
SENSE_CODE(0x5308, "Element status unknown")
SENSE_CODE(0x5309, "Data transfer device error - load failed")
SENSE_CODE(0x530a, "Data transfer device error - unload failed")
SENSE_CODE(0x530b, "Data transfer device error - unload missing")
SENSE_CODE(0x530c, "Data transfer device error - eject failed")
SENSE_CODE(0x530d, "Data transfer device error - library communication failed")

SENSE_CODE(0x5400, "Scsi to host system interface failure")

SENSE_CODE(0x5500, "System resource failure")
SENSE_CODE(0x5501, "System buffer full")
SENSE_CODE(0x5502, "Insufficient reservation resources")
SENSE_CODE(0x5503, "Insufficient resources")
SENSE_CODE(0x5504, "Insufficient registration resources")
SENSE_CODE(0x5505, "Insufficient access control resources")
SENSE_CODE(0x5506, "Auxiliary memory out of space")
SENSE_CODE(0x5507, "Quota error")
SENSE_CODE(0x5508, "Maximum number of supplemental decryption keys exceeded")
SENSE_CODE(0x5509, "Medium auxiliary memory not accessible")
SENSE_CODE(0x550A, "Data currently unavailable")
SENSE_CODE(0x550B, "Insufficient power for operation")
SENSE_CODE(0x550C, "Insufficient resources to create rod")
SENSE_CODE(0x550D, "Insufficient resources to create rod token")
SENSE_CODE(0x550E, "Insufficient zone resources")

SENSE_CODE(0x5700, "Unable to recover table-of-contents")

SENSE_CODE(0x5800, "Generation does not exist")

SENSE_CODE(0x5900, "Updated block read")

SENSE_CODE(0x5A00, "Operator request or state change input")
SENSE_CODE(0x5A01, "Operator medium removal request")
SENSE_CODE(0x5A02, "Operator selected write protect")
SENSE_CODE(0x5A03, "Operator selected write permit")

SENSE_CODE(0x5B00, "Log exception")
SENSE_CODE(0x5B01, "Threshold condition met")
SENSE_CODE(0x5B02, "Log counter at maximum")
SENSE_CODE(0x5B03, "Log list codes exhausted")

SENSE_CODE(0x5C00, "Rpl status change")
SENSE_CODE(0x5C01, "Spindles synchronized")
SENSE_CODE(0x5C02, "Spindles not synchronized")

SENSE_CODE(0x5D00, "Failure prediction threshold exceeded")
SENSE_CODE(0x5D01, "Media failure prediction threshold exceeded")
SENSE_CODE(0x5D02, "Logical unit failure prediction threshold exceeded")
SENSE_CODE(0x5D03, "Spare area exhaustion prediction threshold exceeded")
SENSE_CODE(0x5D10, "Hardware impending failure general hard drive failure")
SENSE_CODE(0x5D11, "Hardware impending failure drive error rate too high")
SENSE_CODE(0x5D12, "Hardware impending failure data error rate too high")
SENSE_CODE(0x5D13, "Hardware impending failure seek error rate too high")
SENSE_CODE(0x5D14, "Hardware impending failure too many block reassigns")
SENSE_CODE(0x5D15, "Hardware impending failure access times too high")
SENSE_CODE(0x5D16, "Hardware impending failure start unit times too high")
SENSE_CODE(0x5D17, "Hardware impending failure channel parametrics")
SENSE_CODE(0x5D18, "Hardware impending failure controller detected")
SENSE_CODE(0x5D19, "Hardware impending failure throughput performance")
SENSE_CODE(0x5D1A, "Hardware impending failure seek time performance")
SENSE_CODE(0x5D1B, "Hardware impending failure spin-up retry count")
SENSE_CODE(0x5D1C, "Hardware impending failure drive calibration retry count")
SENSE_CODE(0x5D20, "Controller impending failure general hard drive failure")
SENSE_CODE(0x5D21, "Controller impending failure drive error rate too high")
SENSE_CODE(0x5D22, "Controller impending failure data error rate too high")
SENSE_CODE(0x5D23, "Controller impending failure seek error rate too high")
SENSE_CODE(0x5D24, "Controller impending failure too many block reassigns")
SENSE_CODE(0x5D25, "Controller impending failure access times too high")
SENSE_CODE(0x5D26, "Controller impending failure start unit times too high")
SENSE_CODE(0x5D27, "Controller impending failure channel parametrics")
SENSE_CODE(0x5D28, "Controller impending failure controller detected")
SENSE_CODE(0x5D29, "Controller impending failure throughput performance")
SENSE_CODE(0x5D2A, "Controller impending failure seek time performance")
SENSE_CODE(0x5D2B, "Controller impending failure spin-up retry count")
SENSE_CODE(0x5D2C, "Controller impending failure drive calibration retry count")
SENSE_CODE(0x5D30, "Data channel impending failure general hard drive failure")
SENSE_CODE(0x5D31, "Data channel impending failure drive error rate too high")
SENSE_CODE(0x5D32, "Data channel impending failure data error rate too high")
SENSE_CODE(0x5D33, "Data channel impending failure seek error rate too high")
SENSE_CODE(0x5D34, "Data channel impending failure too many block reassigns")
SENSE_CODE(0x5D35, "Data channel impending failure access times too high")
SENSE_CODE(0x5D36, "Data channel impending failure start unit times too high")
SENSE_CODE(0x5D37, "Data channel impending failure channel parametrics")
SENSE_CODE(0x5D38, "Data channel impending failure controller detected")
SENSE_CODE(0x5D39, "Data channel impending failure throughput performance")
SENSE_CODE(0x5D3A, "Data channel impending failure seek time performance")
SENSE_CODE(0x5D3B, "Data channel impending failure spin-up retry count")
SENSE_CODE(0x5D3C, "Data channel impending failure drive calibration retry count")
SENSE_CODE(0x5D40, "Servo impending failure general hard drive failure")
SENSE_CODE(0x5D41, "Servo impending failure drive error rate too high")
SENSE_CODE(0x5D42, "Servo impending failure data error rate too high")
SENSE_CODE(0x5D43, "Servo impending failure seek error rate too high")
SENSE_CODE(0x5D44, "Servo impending failure too many block reassigns")
SENSE_CODE(0x5D45, "Servo impending failure access times too high")
SENSE_CODE(0x5D46, "Servo impending failure start unit times too high")
SENSE_CODE(0x5D47, "Servo impending failure channel parametrics")
SENSE_CODE(0x5D48, "Servo impending failure controller detected")
SENSE_CODE(0x5D49, "Servo impending failure throughput performance")
SENSE_CODE(0x5D4A, "Servo impending failure seek time performance")
SENSE_CODE(0x5D4B, "Servo impending failure spin-up retry count")
SENSE_CODE(0x5D4C, "Servo impending failure drive calibration retry count")
SENSE_CODE(0x5D50, "Spindle impending failure general hard drive failure")
SENSE_CODE(0x5D51, "Spindle impending failure drive error rate too high")
SENSE_CODE(0x5D52, "Spindle impending failure data error rate too high")
SENSE_CODE(0x5D53, "Spindle impending failure seek error rate too high")
SENSE_CODE(0x5D54, "Spindle impending failure too many block reassigns")
SENSE_CODE(0x5D55, "Spindle impending failure access times too high")
SENSE_CODE(0x5D56, "Spindle impending failure start unit times too high")
SENSE_CODE(0x5D57, "Spindle impending failure channel parametrics")
SENSE_CODE(0x5D58, "Spindle impending failure controller detected")
SENSE_CODE(0x5D59, "Spindle impending failure throughput performance")
SENSE_CODE(0x5D5A, "Spindle impending failure seek time performance")
SENSE_CODE(0x5D5B, "Spindle impending failure spin-up retry count")
SENSE_CODE(0x5D5C, "Spindle impending failure drive calibration retry count")
SENSE_CODE(0x5D60, "Firmware impending failure general hard drive failure")
SENSE_CODE(0x5D61, "Firmware impending failure drive error rate too high")
SENSE_CODE(0x5D62, "Firmware impending failure data error rate too high")
SENSE_CODE(0x5D63, "Firmware impending failure seek error rate too high")
SENSE_CODE(0x5D64, "Firmware impending failure too many block reassigns")
SENSE_CODE(0x5D65, "Firmware impending failure access times too high")
SENSE_CODE(0x5D66, "Firmware impending failure start unit times too high")
SENSE_CODE(0x5D67, "Firmware impending failure channel parametrics")
SENSE_CODE(0x5D68, "Firmware impending failure controller detected")
SENSE_CODE(0x5D69, "Firmware impending failure throughput performance")
SENSE_CODE(0x5D6A, "Firmware impending failure seek time performance")
SENSE_CODE(0x5D6B, "Firmware impending failure spin-up retry count")
SENSE_CODE(0x5D6C, "Firmware impending failure drive calibration retry count")
SENSE_CODE(0x5DFF, "Failure prediction threshold exceeded (false)")

SENSE_CODE(0x5E00, "Low power condition on")
SENSE_CODE(0x5E01, "Idle condition activated by timer")
SENSE_CODE(0x5E02, "Standby condition activated by timer")
SENSE_CODE(0x5E03, "Idle condition activated by command")
SENSE_CODE(0x5E04, "Standby condition activated by command")
SENSE_CODE(0x5E05, "Idle_b condition activated by timer")
SENSE_CODE(0x5E06, "Idle_b condition activated by command")
SENSE_CODE(0x5E07, "Idle_c condition activated by timer")
SENSE_CODE(0x5E08, "Idle_c condition activated by command")
SENSE_CODE(0x5E09, "Standby_y condition activated by timer")
SENSE_CODE(0x5E0A, "Standby_y condition activated by command")
SENSE_CODE(0x5E41, "Power state change to active")
SENSE_CODE(0x5E42, "Power state change to idle")
SENSE_CODE(0x5E43, "Power state change to standby")
SENSE_CODE(0x5E45, "Power state change to sleep")
SENSE_CODE(0x5E47, "Power state change to device control")

SENSE_CODE(0x6000, "Lamp failure")

SENSE_CODE(0x6100, "Video acquisition error")
SENSE_CODE(0x6101, "Unable to acquire video")
SENSE_CODE(0x6102, "Out of focus")

SENSE_CODE(0x6200, "Scan head positioning error")

SENSE_CODE(0x6300, "End of user area encountered on this track")
SENSE_CODE(0x6301, "Packet does not fit in available space")

SENSE_CODE(0x6400, "Illegal mode for this track")
SENSE_CODE(0x6401, "Invalid packet size")

SENSE_CODE(0x6500, "Voltage fault")

SENSE_CODE(0x6600, "Automatic document feeder cover up")
SENSE_CODE(0x6601, "Automatic document feeder lift up")
SENSE_CODE(0x6602, "Document jam in automatic document feeder")
SENSE_CODE(0x6603, "Document miss feed automatic in document feeder")

SENSE_CODE(0x6700, "Configuration failure")
SENSE_CODE(0x6701, "Configuration of incapable logical units failed")
SENSE_CODE(0x6702, "Add logical unit failed")
SENSE_CODE(0x6703, "Modification of logical unit failed")
SENSE_CODE(0x6704, "Exchange of logical unit failed")
SENSE_CODE(0x6705, "Remove of logical unit failed")
SENSE_CODE(0x6706, "Attachment of logical unit failed")
SENSE_CODE(0x6707, "Creation of logical unit failed")
SENSE_CODE(0x6708, "Assign failure occurred")
SENSE_CODE(0x6709, "Multiply assigned logical unit")
SENSE_CODE(0x670A, "Set target port groups command failed")
SENSE_CODE(0x670B, "ATA device feature not enabled")

SENSE_CODE(0x6800, "Logical unit not configured")
SENSE_CODE(0x6801, "Subsidiary logical unit not configured")

SENSE_CODE(0x6900, "Data loss on logical unit")
SENSE_CODE(0x6901, "Multiple logical unit failures")
SENSE_CODE(0x6902, "Parity/data mismatch")

SENSE_CODE(0x6A00, "Informational, refer to log")

SENSE_CODE(0x6B00, "State change has occurred")
SENSE_CODE(0x6B01, "Redundancy level got better")
SENSE_CODE(0x6B02, "Redundancy level got worse")

SENSE_CODE(0x6C00, "Rebuild failure occurred")

SENSE_CODE(0x6D00, "Recalculate failure occurred")

SENSE_CODE(0x6E00, "Command to logical unit failed")

SENSE_CODE(0x6F00, "Copy protection key exchange failure - authentication failure")
SENSE_CODE(0x6F01, "Copy protection key exchange failure - key not present")
SENSE_CODE(0x6F02, "Copy protection key exchange failure - key not established")
SENSE_CODE(0x6F03, "Read of scrambled sector without authentication")
SENSE_CODE(0x6F04, "Media region code is mismatched to logical unit region")
SENSE_CODE(0x6F05, "Drive region must be permanent/region reset count error")
SENSE_CODE(0x6F06, "Insufficient block count for binding nonce recording")
SENSE_CODE(0x6F07, "Conflict in binding nonce recording")
/*
 *	SENSE_CODE(0x70NN, "Decompression exception short algorithm id of nn")
 */
SENSE_CODE(0x7100, "Decompression exception long algorithm id")

SENSE_CODE(0x7200, "Session fixation error")
SENSE_CODE(0x7201, "Session fixation error writing lead-in")
SENSE_CODE(0x7202, "Session fixation error writing lead-out")
SENSE_CODE(0x7203, "Session fixation error - incomplete track in session")
SENSE_CODE(0x7204, "Empty or partially written reserved track")
SENSE_CODE(0x7205, "No more track reservations allowed")
SENSE_CODE(0x7206, "RMZ extension is not allowed")
SENSE_CODE(0x7207, "No more test zone extensions are allowed")

SENSE_CODE(0x7300, "Cd control error")
SENSE_CODE(0x7301, "Power calibration area almost full")
SENSE_CODE(0x7302, "Power calibration area is full")
SENSE_CODE(0x7303, "Power calibration area error")
SENSE_CODE(0x7304, "Program memory area update failure")
SENSE_CODE(0x7305, "Program memory area is full")
SENSE_CODE(0x7306, "RMA/PMA is almost full")
SENSE_CODE(0x7310, "Current power calibration area almost full")
SENSE_CODE(0x7311, "Current power calibration area is full")
SENSE_CODE(0x7317, "RDZ is full")

SENSE_CODE(0x7400, "Security error")
SENSE_CODE(0x7401, "Unable to decrypt data")
SENSE_CODE(0x7402, "Unencrypted data encountered while decrypting")
SENSE_CODE(0x7403, "Incorrect data encryption key")
SENSE_CODE(0x7404, "Cryptographic integrity validation failed")
SENSE_CODE(0x7405, "Error decrypting data")
SENSE_CODE(0x7406, "Unknown signature verification key")
SENSE_CODE(0x7407, "Encryption parameters not useable")
SENSE_CODE(0x7408, "Digital signature validation failure")
SENSE_CODE(0x7409, "Encryption mode mismatch on read")
SENSE_CODE(0x740A, "Encrypted block not raw read enabled")
SENSE_CODE(0x740B, "Incorrect Encryption parameters")
SENSE_CODE(0x740C, "Unable to decrypt parameter list")
SENSE_CODE(0x740D, "Encryption algorithm disabled")
SENSE_CODE(0x7410, "SA creation parameter value invalid")
SENSE_CODE(0x7411, "SA creation parameter value rejected")
SENSE_CODE(0x7412, "Invalid SA usage")
SENSE_CODE(0x7421, "Data Encryption configuration prevented")
SENSE_CODE(0x7430, "SA creation parameter not supported")
SENSE_CODE(0x7440, "Authentication failed")
SENSE_CODE(0x7461, "External data encryption key manager access error")
SENSE_CODE(0x7462, "External data encryption key manager error")
SENSE_CODE(0x7463, "External data encryption key not found")
SENSE_CODE(0x7464, "External data encryption request not authorized")
SENSE_CODE(0x746E, "External data encryption control timeout")
SENSE_CODE(0x746F, "External data encryption control error")
SENSE_CODE(0x7471, "Logical unit access not authorized")
SENSE_CODE(0x7479, "Security conflict in translated device")


###################################################################
## Skeleton for case03
###################################################################

###################################################################
## The following is a nifty way to check if a package is
## installed and if not install it.
## Better protocol than just commeting out the
## install.packages commands.
###################################################################
## Install and Load Packages ##
rm(list = ls())
packages = c("R.utils", "stringr", "xtable")
for(i in 1:length(packages)){
  if(!(packages[i] %in% as.character(installed.packages()[,1]))){
    for(j in 1:length(packages)){
      install.packages(packages[j])
    }
  }
}

###################################################################
## Load libraries
###################################################################

library(R.utils)
library(stringr)

###################################################################
## Set Working Directory.
## This you need to change to your own directory address.
###################################################################

setwd('~/Desktop/NLP/Case05.2')

###################################################################
## Loading index file created from case02
## data.edgar.8K.1994.2020.csv
## has the 8-Ks

###################################################################

dataedgar_df <- read.csv('~/Desktop/NLP/Case05.2/data.edgar.10K.1994.2020.csv', stringsAsFactors=FALSE)

dim(dataedgar_df)
head(dataedgar_df)
tail(dataedgar_df)

####################################################################
## Pick 2008 Q1
####################################################################

date.yeardg <- as.numeric(substr(dataedgar_df[,4], 1, 4))
date.monthdg <- as.numeric(substr(dataedgar_df[,4], 6, 7))
date.daydg <- as.numeric(substr(dataedgar_df[,4], 9, 10))

summary(as.factor(date.yeardg))
summary(as.factor(date.monthdg))

flag.case <- date.yeardg==2008 & (date.monthdg>=1 & date.monthdg<=3)
sum(flag.case)

data10ks <- dataedgar_df[flag.case,]
head(data10ks)
dim(data10ks)

###############################
## Let's grab N random 8Ks
###############################
ene <- 1000

time1 <- Sys.time()
set.seed(7)
random_sample_8ks <- sample(dim(data10ks)[1], ene)

#### Recycling code...
secweb <- "https://www.sec.gov/Archives/";

for(i in 1:ene){
    cat("Iteration", i, "out of ", ene, "\n")
    webaddress <- data10ks[random_sample_8ks[i], 5]
    trashme <- unlist(str_split(webaddress, "/")) ## Bad habits are hard to break...
    
    ciksave <- trashme[3] ## Saving CIK
    filename <- trashme[4] ## filename

    crawlme <- paste(secweb, webaddress, sep="")

    ## Let's find a home for the downloaded file
    ## I use my suggested subdirectory tree structure,
    ## grabbing the first four digits of the CIK and formatting
    ## accordingly.

    cik.directories <- floor(as.numeric(ciksave)/1000)
    #pads front of number with 0s
    cik.directories <- sprintf("%04d", cik.directories)
    save.subdir <- paste(cik.directories, "/", ciksave, sep="")
    dir.create(save.subdir, recursive=TRUE)    

    filename.clean <- paste(save.subdir, "/", filename, sep="") ## Nice place where to store the file
    
    ## Download file to folder
    download.file(crawlme, filename.clean)
}
time2 <- Sys.time()
time2-time1 ## 8 minutes for 1,000

######################################
## Estimating hard space needs
######################################

all.files <- dir(recursive=TRUE)
all.files <- all.files[grepl("txt", all.files)]

file.info.case <- file.info(all.files)
head(file.info.case)

sum(file.info.case[,1])
mean(file.info.case[,1])

mean(file.info.case[,1])*dim(data10ks)[1] ## Decent estimate of the space needed to store all 10Ks from Q1 2008

########################################################################################
## Note that the above estimate is about 12 Gbs (uncompressed).
## I will do 1,000 to leave space for videos....
########################################################################################

############################################################################
## Let's create an index file that has
## some metadata from the header of the
## 10-K filing.
##
## I am going to grab the
## 1 - PUBLIC DOCUMENT COUNT
## 2 - FILED AS OF DATE
## 3 - ACCEPTANCE-DATETIME
## 4 - COMPANY CONFORMED NAME
## 5 - STANDARD INDUSTRIAL CLASSIFICATION
## 6 - CITY
## 7 - STATE
############################################################################

time1 <- Sys.time()

filereading <- readLines(all.files[1])

head(filereading, 20)
TenK.timestamp <- rep(0, ene)
TenK.doc.count <- rep(0, ene)
TenK.file.date <- rep(0, ene)
TenK.sic <- rep(0, ene)
TenK.city <- rep(0, ene)
TenK.state <- rep(0, ene)
TenK.name <- rep(0, ene)

for(i in 1:ene){
#for(i in 1:10){
    cat("Iteration", i, "out of", ene, "\n")
    filereading <- readLines(all.files[i])
 
    ## Timestamp
    flag01 <- grepl("ACCEPTANCE-DATETIME", filereading)
    timestamp01 <- filereading[flag01]
    timestamp02 <- unlist(str_split(timestamp01, ">"))
    timestamp03 <- timestamp02[2]
    time01 <- substr(timestamp03, 9, 10)
    time02 <- substr(timestamp03, 11, 12)
    time03 <- substr(timestamp03, 13, 14)
    time04 <- as.numeric(time01)+as.numeric(time02)/60 + as.numeric(time03)/3600
  
    TenK.timestamp[i] <- time04

    ## Number of docs
    flag01 <- grepl("PUBLIC DOCUMENT COUNT", filereading)
    docs.info <- filereading[flag01]
    docs.info <- gsub("PUBLIC DOCUMENT COUNT:\\s+", "", docs.info)
    TenK.doc.count[i] <- docs.info

    ## File date
    flag01 <- grepl("FILED AS OF DATE", filereading)
    date.info <- filereading[flag01]
    date.info <- gsub("FILED AS OF DATE:\\s+", "", date.info)
    TenK.file.date[i] <- date.info
    
    ## Company name
    flag01 <- grepl("COMPANY CONFORMED NAME", filereading)
    name.info <- filereading[flag01]
    name.info <- gsub("\\s+COMPANY CONFORMED NAME:\\s+", "", name.info)
    TenK.name[i] <- name.info

    ## SIC
    flag01 <- grepl("STANDARD INDUSTRIAL CLASSIFICATION:", filereading)
    sic.info <- filereading[flag01]
    sic.info.1 <- paste(sic.info, collapse=";") ## Paste all lines with data using ";"s
    sic.info.2 <- gsub("\\s+STANDARD INDUSTRIAL CLASSIFICATION:\\s+", "", sic.info.1)
    TenK.sic[i] <- sic.info.2
    
    ## City
    flag01 <- grepl("CITY:", filereading)
    city.info <- filereading[flag01]
    city.info.1 <- paste(city.info, collapse=";") ## Paste all lines with data using ";"s
    city.info.2 <- gsub("\\s+CITY:\\s+", "", city.info.1)
    TenK.city[i] <- city.info.2
    
    ## State
    flag01 <- grepl("STATE:", filereading)
    state.info <- filereading[flag01]
    state.info.1 <- paste(state.info, collapse=";") ## Paste all lines with data using ";"s
    state.info.2 <- gsub("\\s+STATE:\\s+", "", state.info.1)
    TenK.state[i] <- state.info.2
}

time2 <- Sys.time()
time2-time1 ## 2.5 minutes for 1,000

###########################################################
## Let's just save the index file
###########################################################

file.out <- "index.10k.1000.20210222.csv"

TenK.indexfile <- data.frame(TenK.name, TenK.file.date, TenK.timestamp,
                             TenK.doc.count, TenK.sic, TenK.city, TenK.state,
                             all.files[1:1000])

head(TenK.indexfile)

write.csv(TenK.indexfile, file=file.out)

###########################################################
## Recycling code.
## A few modifications from the previous cleanFun.
## Main gsub from
## https://stackoverflow.com/questions/17227294/removing-html-tags-from-a-string-in-r
###########################################################
cleanFun <- function(htmlString) {
    temp1 <- gsub("<DOCUMENT>", "TAGDOCUMENTXYZ2020", htmlString)
    temp1 <- gsub("<TEXT>", "TAGTEXTXYZ2020", temp1)
    temp1 <- gsub("<.*?>", "", temp1)
    temp1 <- gsub("&#\\d{2,4};", " ", temp1)
    temp1 <- gsub("&nbsp;", " ", temp1)
    temp1 <- gsub("", " ", temp1)
    temp1 <- replace_non_ascii(temp1)
    temp1 <- gsub("\\t", " ", temp1)
    temp1 <- gsub("\\s+", " ", temp1)
    temp1 <- gsub("^\\s+", "", temp1)
    temp1 <- gsub("\\s+$", "", temp1)
    temp1 <- temp1[!temp1==""]
  return(temp1)
}

###########################################################
## Let's read one filing.
## The key piece of the code below is a hack from:
## https://www.r-bloggers.com/htmltotext-extracting-text-from-html-via-xpath/
## Just dealing with html conventions.
## It saves the 10-K without the html code.
###########################################################
library(RCurl)
library(XML)

tryme <- 473 ## Trying one single filing
filing10k <- readLines(all.files[tryme]) 

doc <- htmlParse(filing10k, asText=TRUE)
plain.text <- xpathSApply(doc, "//text()[not(ancestor::script)][not(ancestor::style)][not(ancestor::noscript)][not(ancestor::form)]", xmlValue)
annual.text <- paste(plain.text, collapse = " ")
annual.text <- gsub("\\s+", " ", annual.text)

write.csv(annual.text, "trashme", row.names=FALSE) ## For inspection, it is supposed to contain the whole 10-K stripped of html stuff



##########################################################

tryme <- 411 ## Trying one single filing
filing10k <- readLines(all.files[tryme]) 

TenK.indexfile[tryme,]

## lets NOT read the non 10K <DOCUMENT>
##only read the 10k piece

flag.doc<- grepl('<DOCUMENT>',filing10k)

list.lines<- 1:length(filing10k)

start.documents<- list.lines[flag.doc]


## Grab the 10k
##need to account for filings that only have one document
if(length(start.documents) > 1){
	lines.10k<- start.documents[1]:(start.documents[2]-1)
} else{
	lines.10k<- start.documents[1]:length(filing10k)
	}


text.10k<- filing10k[lines.10k]

doc <- htmlParse(text.10k, asText=TRUE)
plain.text <- xpathSApply(doc, "//text()[not(ancestor::script)][not(ancestor::style)][not(ancestor::noscript)][not(ancestor::form)]", xmlValue)
annual.text <- paste(plain.text, collapse = " ")
annual.text <- gsub("\\s+", " ", annual.text)

write.csv(annual.text, "trashme", row.names=FALSE) ## For inspection, it is supposed to contain the whole 10-K stripped of html stuff








#grabbing all exhibits
save.exhibits<- rep(list(''), length(start.documents))

for(k in 1:(length(start.documents)-1)){
	lines.10k<- start.documents[k]:(start.documents[k+1]-1)
	save.exhibits[[k]]<- filing10k[lines.10k]
}

head(save.exhibits[[1]])



setwd('~/Desktop/NLP/Case05.2')
getwd()
library(tm)
library(RCurl)
library(XML)
all.files <- dir(recursive = TRUE)
all.files <- all.files[grepl("txt", all.files)]

ene<- 1000
master.documents<- rep(list(''), ene)

time1<- Sys.time()
for(i in 1:ene){
	cat("Iteration", i, "out of", ene, "\n")
	filing10k <- readLines(all.files[i])
	flag.doc<- grepl('<DOCUMENT>',filing10k)
	list.lines<- 1:length(filing10k)
	start.documents<- list.lines[flag.doc]
	save.exhibits<- rep(list(''), length(start.documents))
	
	if(length(start.documents) > 1){
		for(k in 1:(length(start.documents)-1)){
			lines.10k<- start.documents[k]:(start.documents[k+1]-1)
			save.exhibits[[k]]<- filing10k[lines.10k]
		}
	}else{
		lines.10k<- start.documents[1]:length(filing10k)
		save.exhibits[[1]]<- filing10k[lines.10k]
	}
	master.documents[[i]]<- save.exhibits
}
time2<- Sys.time()

time2-time1
######################################################
time1<- Sys.time()
for(i in 1:ene){
	cat("Iteration", i, "out of", ene, "\n")
	pdtext<- master.documents[[i]][[1]]
	doc2 <- htmlParse(pdtext, asText=TRUE)
	plain.text <- xpathSApply(doc2, "//text()[not(ancestor::script)]		[not(ancestor::style)][not(ancestor::noscript)][not(ancestor::form)]", xmlValue)
	annual.text <- paste(plain.text, collapse = " ")
	annual.text <- gsub("\\s+", " ", annual.text)
	write.csv(annual.text, paste('trashme',i), row.names=FALSE) ## For inspection, it is supposed 		to contain the 10k document section of the 10k stripped of html stuff
	master.documents[[i]][[1]]<- annual.text
}

time2<- Sys.time()

time2-time1
######################################################



/******************************************************************************
 *
 * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
 *
 * Modifications for inclusion into the Linux staging tree are
 * Copyright(c) 2010 Larry Finger. All rights reserved.
 *
 * Contact information:
 * WLAN FAE <wlanfae@realtek.com>
 * Larry Finger <Larry.Finger@lwfinger.net>
 *
 ******************************************************************************/
#ifndef __RTL8712_CMD_H_
#define __RTL8712_CMD_H_

#define CMD_HDR_SZ      8

u8 r8712_fw_cmd(struct _adapter *pAdapter, u32 cmd);
void r8712_fw_cmd_data(struct _adapter *pAdapter, u32 *value, u8 flag);

struct cmd_hdr {
	u32 cmd_dw0;
	u32 cmd_dw1;
};

enum rtl8712_h2c_cmd {
	GEN_CMD_CODE(_Read_MACREG),	/*0*/
	GEN_CMD_CODE(_Write_MACREG),
	GEN_CMD_CODE(_Read_BBREG),
	GEN_CMD_CODE(_Write_BBREG),
	GEN_CMD_CODE(_Read_RFREG),
	GEN_CMD_CODE(_Write_RFREG), /*5*/
	GEN_CMD_CODE(_Read_EEPROM),
	GEN_CMD_CODE(_Write_EEPROM),
	GEN_CMD_CODE(_Read_EFUSE),
	GEN_CMD_CODE(_Write_EFUSE),

	GEN_CMD_CODE(_Read_CAM),	/*10*/
	GEN_CMD_CODE(_Write_CAM),
	GEN_CMD_CODE(_setBCNITV),
	GEN_CMD_CODE(_setMBIDCFG),
	GEN_CMD_CODE(_JoinBss),   /*14*/
	GEN_CMD_CODE(_DisConnect), /*15*/
	GEN_CMD_CODE(_CreateBss),
	GEN_CMD_CODE(_SetOpMode),
	GEN_CMD_CODE(_SiteSurvey),  /*18*/
	GEN_CMD_CODE(_SetAuth),

	GEN_CMD_CODE(_SetKey),	/*20*/
	GEN_CMD_CODE(_SetStaKey),
	GEN_CMD_CODE(_SetAssocSta),
	GEN_CMD_CODE(_DelAssocSta),
	GEN_CMD_CODE(_SetStaPwrState),
	GEN_CMD_CODE(_SetBasicRate), /*25*/
	GEN_CMD_CODE(_GetBasicRate),
	GEN_CMD_CODE(_SetDataRate),
	GEN_CMD_CODE(_GetDataRate),
	GEN_CMD_CODE(_SetPhyInfo),

	GEN_CMD_CODE(_GetPhyInfo),	/*30*/
	GEN_CMD_CODE(_SetPhy),
	GEN_CMD_CODE(_GetPhy),
	GEN_CMD_CODE(_readRssi),
	GEN_CMD_CODE(_readGain),
	GEN_CMD_CODE(_SetAtim), /*35*/
	GEN_CMD_CODE(_SetPwrMode),
	GEN_CMD_CODE(_JoinbssRpt),
	GEN_CMD_CODE(_SetRaTable),
	GEN_CMD_CODE(_GetRaTable),

	GEN_CMD_CODE(_GetCCXReport), /*40*/
	GEN_CMD_CODE(_GetDTMReport),
	GEN_CMD_CODE(_GetTXRateStatistics),
	GEN_CMD_CODE(_SetUsbSuspend),
	GEN_CMD_CODE(_SetH2cLbk),
	GEN_CMD_CODE(_AddBAReq), /*45*/

	GEN_CMD_CODE(_SetChannel), /*46*/
/* MP_OFFLOAD Start (47~54)*/
	GEN_CMD_CODE(_SetTxPower),
	GEN_CMD_CODE(_SwitchAntenna),
	GEN_CMD_CODE(_SetCrystalCap),
	GEN_CMD_CODE(_SetSingleCarrierTx), /*50*/
	GEN_CMD_CODE(_SetSingleToneTx),
	GEN_CMD_CODE(_SetCarrierSuppressionTx),
	GEN_CMD_CODE(_SetContinuousTx),
	GEN_CMD_CODE(_SwitchBandwidth), /*54*/
/* MP_OFFLOAD End*/
	GEN_CMD_CODE(_TX_Beacon), /*55*/
	GEN_CMD_CODE(_SetPowerTracking),
	GEN_CMD_CODE(_AMSDU_TO_AMPDU), /*57*/
	GEN_CMD_CODE(_SetMacAddress), /*58*/

	GEN_CMD_CODE(_DisconnectCtrl), /*59*/
	GEN_CMD_CODE(_SetChannelPlan), /*60*/
	GEN_CMD_CODE(_DisconnectCtrlEx), /*61*/

	/* To do, modify these h2c cmd, add or delete */
	GEN_CMD_CODE(_GetH2cLbk) ,

	/* WPS extra IE */
	GEN_CMD_CODE(_SetProbeReqExtraIE) ,
	GEN_CMD_CODE(_SetAssocReqExtraIE) ,
	GEN_CMD_CODE(_SetProbeRspExtraIE) ,
	GEN_CMD_CODE(_SetAssocRspExtraIE) ,

	/* the following is driver will do */
	GEN_CMD_CODE(_GetCurDataRate) ,

	GEN_CMD_CODE(_GetTxRetrycnt),  /* to record times that Tx retry to
					* transmit packet after association
					*/
	GEN_CMD_CODE(_GetRxRetrycnt),  /* to record total number of the
					* received frame with ReTry bit set in
					* the WLAN header
					*/

	GEN_CMD_CODE(_GetBCNOKcnt),
	GEN_CMD_CODE(_GetBCNERRcnt),
	GEN_CMD_CODE(_GetCurTxPwrLevel),

	GEN_CMD_CODE(_SetDIG),
	GEN_CMD_CODE(_SetRA),
	GEN_CMD_CODE(_SetPT),
	GEN_CMD_CODE(_ReadTSSI),

	MAX_H2CCMD
};


#define _GetBBReg_CMD_		_Read_BBREG_CMD_
#define _SetBBReg_CMD_		_Write_BBREG_CMD_
#define _GetRFReg_CMD_		_Read_RFREG_CMD_
#define _SetRFReg_CMD_		_Write_RFREG_CMD_
#define _DRV_INT_CMD_		(MAX_H2CCMD+1)
#define _SetRFIntFs_CMD_	(MAX_H2CCMD+2)

#ifdef _RTL8712_CMD_C_
static struct _cmd_callback	cmd_callback[] = {
	{GEN_CMD_CODE(_Read_MACREG), NULL}, /*0*/
	{GEN_CMD_CODE(_Write_MACREG), NULL},
	{GEN_CMD_CODE(_Read_BBREG), &r8712_getbbrfreg_cmdrsp_callback},
	{GEN_CMD_CODE(_Write_BBREG), NULL},
	{GEN_CMD_CODE(_Read_RFREG), &r8712_getbbrfreg_cmdrsp_callback},
	{GEN_CMD_CODE(_Write_RFREG), NULL}, /*5*/
	{GEN_CMD_CODE(_Read_EEPROM), NULL},
	{GEN_CMD_CODE(_Write_EEPROM), NULL},
	{GEN_CMD_CODE(_Read_EFUSE), NULL},
	{GEN_CMD_CODE(_Write_EFUSE), NULL},

	{GEN_CMD_CODE(_Read_CAM),	NULL},	/*10*/
	{GEN_CMD_CODE(_Write_CAM),	 NULL},
	{GEN_CMD_CODE(_setBCNITV), NULL},
	{GEN_CMD_CODE(_setMBIDCFG), NULL},
	{GEN_CMD_CODE(_JoinBss), &r8712_joinbss_cmd_callback},  /*14*/
	{GEN_CMD_CODE(_DisConnect), &r8712_disassoc_cmd_callback}, /*15*/
	{GEN_CMD_CODE(_CreateBss), &r8712_createbss_cmd_callback},
	{GEN_CMD_CODE(_SetOpMode), NULL},
	{GEN_CMD_CODE(_SiteSurvey), &r8712_survey_cmd_callback}, /*18*/
	{GEN_CMD_CODE(_SetAuth), NULL},

	{GEN_CMD_CODE(_SetKey), NULL},	/*20*/
	{GEN_CMD_CODE(_SetStaKey), &r8712_setstaKey_cmdrsp_callback},
	{GEN_CMD_CODE(_SetAssocSta), &r8712_setassocsta_cmdrsp_callback},
	{GEN_CMD_CODE(_DelAssocSta), NULL},
	{GEN_CMD_CODE(_SetStaPwrState), NULL},
	{GEN_CMD_CODE(_SetBasicRate), NULL}, /*25*/
	{GEN_CMD_CODE(_GetBasicRate), NULL},
	{GEN_CMD_CODE(_SetDataRate), NULL},
	{GEN_CMD_CODE(_GetDataRate), NULL},
	{GEN_CMD_CODE(_SetPhyInfo), NULL},

	{GEN_CMD_CODE(_GetPhyInfo), NULL}, /*30*/
	{GEN_CMD_CODE(_SetPhy), NULL},
	{GEN_CMD_CODE(_GetPhy), NULL},
	{GEN_CMD_CODE(_readRssi), NULL},
	{GEN_CMD_CODE(_readGain), NULL},
	{GEN_CMD_CODE(_SetAtim), NULL}, /*35*/
	{GEN_CMD_CODE(_SetPwrMode), NULL},
	{GEN_CMD_CODE(_JoinbssRpt), NULL},
	{GEN_CMD_CODE(_SetRaTable), NULL},
	{GEN_CMD_CODE(_GetRaTable), NULL},

	{GEN_CMD_CODE(_GetCCXReport), NULL}, /*40*/
	{GEN_CMD_CODE(_GetDTMReport),	NULL},
	{GEN_CMD_CODE(_GetTXRateStatistics), NULL},
	{GEN_CMD_CODE(_SetUsbSuspend), NULL},
	{GEN_CMD_CODE(_SetH2cLbk), NULL},
	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/

	{GEN_CMD_CODE(_SetChannel), NULL},		/*46*/
/* MP_OFFLOAD Start (47~54)*/
	{GEN_CMD_CODE(_SetTxPower), NULL},
	{GEN_CMD_CODE(_SwitchAntenna), NULL},
	{GEN_CMD_CODE(_SetCrystalCap), NULL},
	{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},	/*50*/
	{GEN_CMD_CODE(_SetSingleToneTx), NULL},
	{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},
	{GEN_CMD_CODE(_SetContinuousTx), NULL},
	{GEN_CMD_CODE(_SwitchBandwidth), NULL},		/*54*/
/* MP_OFFLOAD End*/
	{GEN_CMD_CODE(_TX_Beacon), NULL}, /*55*/
	{GEN_CMD_CODE(_SetPowerTracking), NULL},
	{GEN_CMD_CODE(_AMSDU_TO_AMPDU), NULL}, /*57*/
	{GEN_CMD_CODE(_SetMacAddress), NULL}, /*58*/

	{GEN_CMD_CODE(_DisconnectCtrl), NULL}, /*59*/
	{GEN_CMD_CODE(_SetChannelPlan), NULL}, /*60*/
	{GEN_CMD_CODE(_DisconnectCtrlEx), NULL}, /*61*/

	/* To do, modify these h2c cmd, add or delete */
	{GEN_CMD_CODE(_GetH2cLbk), NULL},

	{_SetProbeReqExtraIE_CMD_, NULL},
	{_SetAssocReqExtraIE_CMD_, NULL},
	{_SetProbeRspExtraIE_CMD_, NULL},
	{_SetAssocRspExtraIE_CMD_, NULL},
	{_GetCurDataRate_CMD_, NULL},
	{_GetTxRetrycnt_CMD_, NULL},
	{_GetRxRetrycnt_CMD_, NULL},
	{_GetBCNOKcnt_CMD_, NULL},
	{_GetBCNERRcnt_CMD_, NULL},
	{_GetCurTxPwrLevel_CMD_, NULL},
	{_SetDIG_CMD_, NULL},
	{_SetRA_CMD_, NULL},
	{_SetPT_CMD_, NULL},
	{GEN_CMD_CODE(_ReadTSSI), &r8712_readtssi_cmdrsp_callback}
};
#endif

#endif


docs<- rep('',ene/4)
for(i in 1:ene/4){
	docs[i] <- master.documents[[i]][[1]]
}

time1<- Sys.time()
test.corpus<- VCorpus(VectorSource(docs))
test.corpus<- tm_map(test.corpus, content_transformer(tolower))
test.corpus<- tm_map(test.corpus, removeWords, stopwords('english'))
test.corpus<- tm_map(test.corpus, stemDocument)
time2<- Sys.time()

time2-time1


test.tdm<- TermDocumentMatrix(test.corpus)






inspect(test.tdm)


const express = require('express');
const app = express();
const ejs = require('ejs');
app.set('view engine','ejs');
const fs = require('fs');
var a = JSON.parse(fs.readFileSync('blog.json'))
app.get('/',function(req,res){
    res.render('index',{"id":a})
});
app.get('/title/:id',function(req,res){
    const b = req.params.id
    res.render('title',{"id": b,"value":a.Sheet1[b]})
})


app.listen(8000);

/**
 * Marlin 3D Printer Firmware
 * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
 * Copyright (C) 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
 *
 * Based on Sprinter and grbl.
 * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * MKS SBASE pin assignments
 */

#ifndef TARGET_LPC1768
  #error "Oops!  Make sure you have the LPC1768 environment selected in your IDE."
#endif

#ifndef BOARD_NAME
  #define BOARD_NAME "MKS SBASE"
  #define DEFAULT_WEBSITE_URL "https://github.com/makerbase-mks/MKS-SBASE"
#endif

// unused
/*
#define PIN_P0_27          P0_27
#define PIN_P0_28          P0_28
*/

#define LED_PIN           P1_18 // LED2 P1_19, LED3 P1_20, LED4 P1_21

//
// Servo pin
//
#define SERVO0_PIN         P1_23   // J8-3 (low jitter)
#define SERVO1_PIN         P2_12   // J8-4
#define SERVO2_PIN         P2_11   // J8-5
#define SERVO3_PIN         P4_28   // J8-6

//
// Limit Switches
//
#define X_MIN_PIN          P1_24   // 10k pullup to 3.3V, 1K series
#define X_MAX_PIN          P1_25   // 10k pullup to 3.3V, 1K series
#define Y_MIN_PIN          P1_26   // 10k pullup to 3.3V, 1K series
#define Y_MAX_PIN          P1_27   // 10k pullup to 3.3V, 1K series
#define Z_MIN_PIN          P1_28   // The original Mks Sbase DIO19 has a 10k pullup to 3.3V or 5V, 1K series, so when using a Zprobe we must use DIO41 (J8 P1.22)
#define Z_MAX_PIN          P1_29   // 10k pullup to 3.3V, 1K series

//
// Steppers
//
#define X_STEP_PIN         P2_00
#define X_DIR_PIN          P0_05
#define X_ENABLE_PIN       P0_04

#define Y_STEP_PIN         P2_01
#define Y_DIR_PIN          P0_11
#define Y_ENABLE_PIN       P0_10

#define Z_STEP_PIN         P2_02
#define Z_DIR_PIN          P0_20
#define Z_ENABLE_PIN       P0_19

#define E0_STEP_PIN        P2_03
#define E0_DIR_PIN         P0_22
#define E0_ENABLE_PIN      P0_21

#define E1_STEP_PIN        P2_08
#define E1_DIR_PIN         P2_13
#define E1_ENABLE_PIN      P4_29

//
// Temperature Sensors
// 3.3V max when defined as an analog input
//
#define TEMP_BED_PIN        0   // A0 (TH1)
#define TEMP_0_PIN          1   // A1 (TH2)
#define TEMP_1_PIN          2   // A2 (TH3)
#define TEMP_2_PIN          3   // A3 (TH4)

//
// Heaters / Fans
//
#define HEATER_BED_PIN     P2_05
#define HEATER_0_PIN       P2_07
#define HEATER_1_PIN       P2_06
#ifndef FAN_PIN
  #define FAN_PIN          P2_04
#endif

//
// Connector J7
//

// 5V
// NC
// GND
#define PIN_P0_17          P0_17
#define PIN_P0_16          P0_16
#define PIN_P0_14          P0_14


//
// Connector J8
//

// GND
#define PIN_P1_22          P1_22
#define PIN_P1_23          P1_23
#define PIN_P2_12          P2_12
#define PIN_P2_11          P2_11
#define PIN_P4_28          P4_28

//
// Prusa i3 MK2 Multi Material Multiplexer Support
//
#if ENABLED(MK2_MULTIPLEXER)
  #define E_MUX0_PIN         P1_23   // J8-3
  #define E_MUX1_PIN         P2_12   // J8-4
  #define E_MUX2_PIN         P2_11   // J8-5
#endif

//
// Misc. Functions
//
#define PS_ON_PIN          P0_25
#define LPC_SOFTWARE_SPI  // MKS_SBASE needs a software SPI because the
                          // selected pins are not on a hardware SPI controller

/**
 * Smart LCD adapter
 *
 * The Smart LCD adapter can be used for the two 10 pin LCD controllers such as
 * REPRAP_DISCOUNT_SMART_CONTROLLER.  It can't be used for controllers that use
 * DOGLCD_A0, DOGLCD_CS, LCD_PINS_D5, LCD_PINS_D6 or LCD_PINS_D7. A custom cable
 * is needed to pick up 5V for the EXP1 connection.
 *
 * SD card on the LCD uses the same SPI signals as the LCD. This results in garbage/lines
 * on the LCD display during accesses of the SD card. The menus/code has been arranged so
 * that the garbage/lines are erased immediately after the SD card accesses are completed.
 */

#if ENABLED(ULTRA_LCD)
  #define BEEPER_PIN       P1_31   // EXP1.1
  #define BTN_ENC          P1_30   // EXP1.2
  #define BTN_EN1          P3_26   // EXP2.5
  #define BTN_EN2          P3_25   // EXP2.3
  #define LCD_PINS_RS      P0_16   // EXP1.4
  #define LCD_SDSS         P0_28   // EXP2.4
  #define LCD_PINS_ENABLE  P0_18   // EXP1.3
  #define LCD_PINS_D4      P0_15   // EXP1.5
#endif // ULTRA_LCD

//
// Ethernet pins
//
#ifndef ULTIPANEL
  #define ENET_MDIO        P1_17   // J12-4
  #define ENET_RX_ER       P1_14   // J12-6
  #define ENET_RXD1        P1_10   // J12-8
#endif
#define ENET_MOC           P1_16   // J12-3
#define REF_CLK            P1_15   // J12-5
#define ENET_RXD0          P1_09   // J12-7
#define ENET_CRS           P1_08   // J12-9
#define ENET_TX_EN         P1_04   // J12-10
#define ENET_TXD0          P1_00   // J12-11
#define ENET_TXD1          P1_01   // J12-12

// A custom cable is needed. See the README file in the
// Marlin\src\config\examples\Mks\Sbase directory

#define SCK_PIN            P1_22   // J8-2 (moved from EXP2 P0.7)
#define MISO_PIN           P1_23   // J8-3 (moved from EXP2 P0.8)
#define MOSI_PIN           P2_12   // J8-4 (moved from EXP2 P0.5)
#define SS_PIN             P0_28
#define SDSS               P0_06

/**
 * P0.27 is on EXP2 and the on-board SD card's socket. That means it can't be
 * used as the SD_DETECT for the LCD's SD card.
 *
 * The best solution is to use the custom cable to connect the LCD's SD_DETECT
 * to a pin NOT on EXP2.
 *
 * If you can't find a pin to use for the LCD's SD_DETECT then comment out
 * SD_DETECT_PIN entirely and remove that wire from the the custom cable.
 */
#define SD_DETECT_PIN      P2_11   // J8-5 (moved from EXP2 P0.27)


/**
 *  PWMs
 *
 *  There are 6 PWMs.  Each PWM can be assigned to one of two pins.
 *
 *  SERVO2 does NOT have a PWM assigned to it.
 *
 *  PWM1.1   P1_18   SERVO3_PIN       FIL_RUNOUT_PIN   5V output, PWM
 *  PWM1.1   P2_00   E0_STEP_PIN
 *  PWM1.2   P1_20   SERVO0_PIN
 *  PWM1.2   P2_01   X_STEP_PIN
 *  PWM1.3   P1_21   SERVO1_PIN       J5-1
 *  PWM1.3   P2_02   Y_STEP_PIN
 *  PWM1.4   P1_23   SDSS(SSEL0)      J3-5  AUX-3
 *  PWM1.4   P2_03   Z_STEP_PIN
 *  PWM1.5   P1_24   X_MIN_PIN        10K PULLUP TO 3.3v, 1K SERIES
 *  PWM1.5   P2_04   RAMPS_D9_PIN
 *  PWM1.6   P1_26   Y_MIN_PIN        10K PULLUP TO 3.3v, 1K SERIES
 *  PWM1.6   P2_05   RAMPS_D10_PIN
 */

 /**
  * Special pins
  *   P1_30 - not 5V tolerant
  *   P1_31 - not 5V tolerant
  *   P0_27 - open collector
  *   P0_28 - open collector
  *
  */

/////////////////////////////////////////////////////////////////////////
////                        EX_ADMM10.C                              ////
////                                                                 ////
////  This program displays the min and max of 30 A/D samples over   ////
////  the RS-232 interface.  The process is repeated forever.        ////
////  This version uses a 10 bit ADC.                                ////
////                                                                 ////
////  Configure the CCS prototype card as follows for PCM and PCH:   ////
////     Insert jumper from output of POT to pin A5                  ////
////     Use a 10K POT to vary the voltage.                          ////
////                                                                 ////
////  Configure the CCS prototype card as follows for PCD:           ////
////     Use the POT labeled B0 or connect a POT to B0               ////
////     Use a 10K POT to vary the voltage.                          ////
////                                                                 ////
////  Jumpers:                                                       ////
////     PCM,PCH    pin C7 to RS232 RX, pin C6 to RS232 TX           ////
////     PCD        pin F2 to RS232 RX, pin F3 to RS232 TX           ////
////                                                                 ////
////  This example will work with the PCM and PCH compilers.  The    ////
////  following conditional compilation lines are used to include a  ////
////  valid device for each compiler.  Change the device, clock and  ////
////  RS232 pins for your hardware if needed.                        ////
/////////////////////////////////////////////////////////////////////////
////        (C) Copyright 1996,2008 Custom Computer Services         ////
//// This source code may only be used by licensed users of the CCS  ////
//// C compiler.  This source code may only be distributed to other  ////
//// licensed users of the CCS C compiler.  No other use,            ////
//// reproduction or distribution is permitted without written       ////
//// permission.  Derivative programs created using this software    ////
//// in object code form are not restricted in any way.              ////
/////////////////////////////////////////////////////////////////////////


#if defined(__PCM__)
#include <16F877.h>
#device ADC=16
#fuses HS,NOWDT,NOPROTECT,NOLVP
#use delay(clock=20000000)
#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)

#elif defined(__PCH__)
#include <18F452.h>
#device ADC=16
#fuses HS,NOWDT,NOPROTECT,NOLVP
#use delay(clock=20000000)
#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)

#elif defined(__PCD__)
#include <30F2010.h>
#device ADC=16
#fuses HS,NOWDT,NOPROTECT
#use delay(clock=20000000)
#use rs232(baud=9600, UART1A)
#endif

void main() {

   unsigned int8 i;
   unsigned int16 value, min, max;

   printf("Sampling:");

   setup_port_a( ALL_ANALOG );
   setup_adc( ADC_CLOCK_INTERNAL );
   set_adc_channel( 0 );

   do {
      min=0xffff;
      max=0;
      for(i=0; i<=30; ++i) {
         delay_ms(100);
         value = Read_ADC();
         if(value<min)
            min=value;
         if(value>max)
            max=value;
      }
      printf("\n\rMin: %4LX  Max: %4LX\n\r",min,max);

   } while (TRUE);
}

/*
 * Summary: Unicode character APIs
 * Description: API for the Unicode character APIs
 *
 * This file is automatically generated from the
 * UCS description files of the Unicode Character Database
 * http://www.unicode.org/Public/4.0-Update1/UCD-4.0.1.html
 * using the genUnicode.py Python script.
 *
 * Generation date: Mon Mar 27 11:09:52 2006
 * Sources: Blocks-4.0.1.txt UnicodeData-4.0.1.txt
 * Author: Daniel Veillard
 */

#ifndef __XML_UNICODE_H__
#define __XML_UNICODE_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_UNICODE_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

XMLPUBFUN int XMLCALL xmlUCSIsAegeanNumbers	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsAlphabeticPresentationForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArabic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArabicPresentationFormsA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArabicPresentationFormsB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArmenian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArrows	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBasicLatin	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBengali	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBlockElements	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBopomofo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBopomofoExtended	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBoxDrawing	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBraillePatterns	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBuhid	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsByzantineMusicalSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibility	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographsSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKRadicalsSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKSymbolsandPunctuation	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographsExtensionA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographsExtensionB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCherokee	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarks	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarksforSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningHalfMarks	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningMarksforSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsControlPictures	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCurrencySymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCypriotSyllabary	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCyrillic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCyrillicSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsDeseret	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsDevanagari	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsDingbats	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsEnclosedAlphanumerics	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsEnclosedCJKLettersandMonths	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsEthiopic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGeneralPunctuation	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGeometricShapes	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGeorgian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGothic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGreek	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGreekExtended	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGreekandCoptic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGujarati	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGurmukhi	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHalfwidthandFullwidthForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHangulCompatibilityJamo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHangulJamo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHangulSyllables	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHanunoo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHebrew	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHighPrivateUseSurrogates	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHighSurrogates	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHiragana	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsIPAExtensions	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsIdeographicDescriptionCharacters	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKanbun	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKangxiRadicals	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKannada	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKatakana	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKatakanaPhoneticExtensions	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKhmer	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKhmerSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLao	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatin1Supplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedAdditional	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLetterlikeSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLimbu	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLinearBIdeograms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLinearBSyllabary	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLowSurrogates	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMalayalam	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMathematicalAlphanumericSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMathematicalOperators	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousMathematicalSymbolsA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousMathematicalSymbolsB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbolsandArrows	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousTechnical	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMongolian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMusicalSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMyanmar	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsNumberForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOgham	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOldItalic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOpticalCharacterRecognition	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOriya	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOsmanya	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsPhoneticExtensions	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsPrivateUse	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsPrivateUseArea	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsRunic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsShavian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSinhala	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSmallFormVariants	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSpacingModifierLetters	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSpecials	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSuperscriptsandSubscripts	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementalMathematicalOperators	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSyriac	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTagalog	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTagbanwa	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTags	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTaiLe	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTaiXuanJingSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTamil	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTelugu	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsThaana	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsThai	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTibetan	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsUgaritic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsUnifiedCanadianAboriginalSyllabics	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectors	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectorsSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsYiRadicals	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsYiSyllables	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsYijingHexagramSymbols	(int code);

XMLPUBFUN int XMLCALL xmlUCSIsBlock	(int code, const char *block);

XMLPUBFUN int XMLCALL xmlUCSIsCatC	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCf	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatL	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLl	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLm	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLt	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLu	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatM	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatMc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatMe	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatMn	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatN	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatNd	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatNl	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatNo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatP	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPd	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPe	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPf	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPi	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatS	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSk	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSm	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZ	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZl	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZp	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZs	(int code);

XMLPUBFUN int XMLCALL xmlUCSIsCat	(int code, const char *cat);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_UNICODE_ENABLED */

#endif /* __XML_UNICODE_H__ */

#!/bin/sh
DIR=www

mkdir $DIR 2> /dev/null

#echo "optimizing css[ui]..."
#java -jar tools/yuicompressor-2.4.2.jar -o $DIR/_s.css style.css

echo "optimizing css[text]..."
java -jar tools/yuicompressor-2.4.2.jar -o $DIR/_ts.css tstyle.css

GCC_OPT="--compilation_level ADVANCED_OPTIMIZATIONS"
#echo "optimizing game code[ui]..."
#cat game.js shared_ui.js ui.js > $DIR/_source.js
#echo -n "\$('head')['append'](\$(\"<style>" >> $DIR/_source.js
#cat $DIR/_s.css >> $DIR/_source.js
#echo '</style>"));' >> $DIR/_source.js
#java -jar tools/compiler.jar $GCC_OPT --js $DIR/_source.js --js_output_file $DIR/_j.js

echo "optimizing game code[text]..."
cat game.js shared_ui.js minigame.js tui.js | \
	grep -v cheat | \
	sed 's/\/\*\* @const \*\//var \0/' | \
	sed 's/\/\*==global==\*\//var \0/' | \
	sed 's/\.left/\._left/g' | \
	sed 's/\.right/\._right/g' | \
	sed 's/\.top/\._top/g' | \
	sed 's/\.bottom/\._bottom/g' | \
	sed 's/\.width/\._width/g' | \
	sed 's/\.height/\._height/g' | \
	sed 's/\.cells/\._cells/g' | \
	sed 's/\.name/\._name/g' | \
	sed 's/\.move/\._move/g' | \
	sed 's/\.type/\._type/g' | \
	sed 's/\.search/\._search/g' | \
	sed 's/\.add/\._add/g' | \
	sed 's/\.remove/\._remove/g' | \
	sed 's/\.distance/\._distance/g' | \
	sed 's/\.apply/\._apply/g' \
	> $DIR/_tsource.js

echo -n "\$('head')['append'](\$(\"<style>" >> $DIR/_tsource.js
cat $DIR/_ts.css | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/;}/}/g' >> $DIR/_tsource.js
echo '</style>"));' >> $DIR/_tsource.js
java -jar tools/compiler.jar $GCC_OPT --js $DIR/_tsource.js --variable_map_output_file $DIR/_jt_vars.map | sed 's/function/@/g' | sed "s/.length/@@/g" |sed "s/this\\./\`/g" > $DIR/_jt.js

#rm $DIR/_source.js

#echo "optimizing tiles..."
#pngcrush -rem alla -reduce -brute t.png $DIR/t.png > /dev/null

#echo "packing png file [ui]..."
#./js2png.php $DIR/_j.js $DIR/j.png
echo "packing png file [text]..."
./js2png.py $DIR/_jt.js $DIR/x.png
#rm $DIR/_j.js
SIZE=`identify www/x.png | awk '{ print $3; }'`
WIDTH=`echo $SIZE | cut -dx -f1`
HEIGHT=`echo $SIZE | cut -dx -f2`
echo "inserting width: $WIDTH, height: $HEIGHT"

echo "optimizing loader code[text]..."
cat loader.js | sed "s/WIDTH/$WIDTH/" | sed "s/HEIGHT/$HEIGHT/" > $DIR/loader.js
echo "loadpng('x.png', start);" >> $DIR/loader.js

java -jar tools/compiler.jar $GCC_OPT --js $DIR/loader.js --js_output_file $DIR/_s.js
#echo "creating loaders..."
##cutting first two lines:
#head -n2 < loader.html > $DIR/ui.html
#cat $DIR/_s.js >> $DIR/ui.html
#tail -n+3 loader.html >> $DIR/ui.html

head -n2 < loader.html > $DIR/text.html
cat $DIR/_s.js >> $DIR/text.html
tail -n+3 loader.html >> $DIR/text.html
cp t.png $DIR/t.png

#echo "calling advpng"
#advpng -z -4 www/x.png www/t.png
echo "optimizing with pngout..."
wine tools/pngout.exe -c0 www/x.png
wine tools/pngout.exe www/t.png

#echo -n "3d variant: "
#du -cb $DIR/j.png $DIR/ui.html | tail -n1
echo -n "tile variant: "
du -cb $DIR/x.png $DIR/text.html $DIR/t.png | tail -n1


#!/bin/sh

rm -rf fontanero fontanero.zip
mkdir fontanero
cp www/text.html fontanero/index.html
cp t.png fontanero
cp www/x.png fontanero
zip -r -9 fontanero.zip fontanero readme.txt
rm -rf fontanero

/** @const */ CELL_VOID = 0;
/** @const */ CELL_FLOOR = 1;
/** @const */ CELL_WALL = 2;
/** @const */ CELL_ENTRANCE = 3;
/** @const */ CELL_EXIT = 4;

/** @const */ PICKABLE = 1;
/** @const */ EDIBLE = 2;
/** @const */ READABLE = 4;
/** @const */ DRINKABLE = 8;
/** @const */ WEARABLE = 16;
/** @const */ FIXABLE = 32;

var book_list = [
	["book of healing", READABLE | PICKABLE], 
	["book of vision", READABLE | PICKABLE], 
	["book of cure", READABLE | PICKABLE],
	["book of genocide", READABLE | PICKABLE]
];

var food_list = [
	["apple", PICKABLE | EDIBLE], 
	["bread", PICKABLE | EDIBLE], 
	["meat", PICKABLE | EDIBLE], 
	["egg", PICKABLE | EDIBLE], 
	["spaghetti", PICKABLE | EDIBLE], 
	["jelly", PICKABLE | EDIBLE], 

	["gold", PICKABLE], 

	["strange potion", DRINKABLE | PICKABLE],
	["soda", DRINKABLE | PICKABLE],
	["milk", DRINKABLE | PICKABLE],
	["water", DRINKABLE | PICKABLE],
	["tea", DRINKABLE | PICKABLE]
];

var monster_list = [
	["spider"],
	["wasp"],
	["rat", "bat", "snake"],
	["poisonous bat", "vampire bat", "poisonous snake"], 
	["rabid mole"], 
	["mutant", "zombie"],
	["ghost"]
];

/*==global==*/map = null;

var floor = Math.floor, random = Math.random, abs = Math.abs;

function hash(str) {
	return str.charCodeAt(0) ^ (str.charCodeAt(1) << 1) ^ str.length;
}

function in_range(x, a, b) {
	return x >= a && x < b;
}

function rand(min, max) {
	if (min instanceof Array)
		return min[floor(random() * min.length)];
	return floor(min + random() * (max - min));
}

function roll(probability) {
	return random() < probability;
}

function sgn(v) {
	return (v > 0)? 1: ((v < 0)? -1: 0);
}

function log(str) {
	$("#l")['append']("&gt; " + str + "<br>")['scrollTop'](1000000);
}

function capitalize(string) {
	return string.charAt(0).toUpperCase() + string.slice(1);
}

var repaint_objects = function() {
	map.foreach(function(cell) {
		if (cell.visited && (cell.actor || cell.objects.length))
			map.repaint(cell);
	});
}

/** @constructor */

function movable() {
	this.cell = null;
	this.hp = rand(this.level * 5, this.level * 10);
	this.boss = false;
	this.poison_chance = 0;
	this.blind_chance = 0;

	this.drop_loot = function() {
		var c = this.cell;
		c.actor = null;
		if (this.boss || roll(0.5)) {
			c.objects.push(new dungeon_object("gold"));
		}
		c.blood = true;
	}
	this.damage = function(obj, hit) {
		//log("damaged for " + hit);
		obj.hp -= hit;
		if (obj.hp <= 0) {
			log(capitalize(this.blinded? "something": obj.name) + " dies.");
			if (obj.boss) {
				map.boss_killed = true;
				log("You killed the monster, return to the surface!");
			}
			
			if (obj instanceof hero) {
				var restart = confirm("You have died, continue?");
				if (restart) {
					obj.hp = rand(10, 20);
					obj.poisoned = 0;
					++obj.dead;
					return false;
				}
				else {
					S();
					return false;
				}
			}
			obj.drop_loot();
			map.repaint(obj.cell);
			return true;
		}
		if (roll(this.poison_chance)) {
			log(obj.name + " has been poisoned!");
			obj.poisoned = rand(3, 10);
		}
		if (roll(this.blind_chance)) {
			log(obj.name + " has been blinded!");
			obj.blinded = rand(20, 30);
			repaint_objects();
		}
		return false;
	}
	this.attack = function(obj, throwing) {
		var l = this.level;
		var my_hit = this instanceof hero;
		if (my_hit && !throwing)
			++l; //little hero's improvement
		if (!my_hit && !(obj instanceof hero))
			return false; //skip monsters attacks
		var hit = (!obj.boss || throwing)? rand(5 * l, 7 * l): 1;
		var blinded = this.blinded;
		var something = "something";
		log(
			(my_hit? 
				"You hit " + (blinded? something: obj.name): 
				capitalize(blinded? something: this.name) + " hits " + obj.name
			) + 
			" for " + hit + " hit points.");
		return this.damage(obj, hit);
	}
	
	this.move = function(dx, dy) {
		if (!(dx | dy) || (dx && dy))
			return false;
		
		var cell = this.cell;
		var x = cell.x + dx, y = cell.y + dy;
		if (x < 0 || x >= map.width || y < 0 || y >= map.height)
			return false;

		var new_cell = map.cells[y][x];
		if (new_cell.type == CELL_VOID || new_cell.type == CELL_WALL)
			return false;

		if (new_cell.actor != null) {
			this.attack(new_cell.actor);
			return true;
		}
		
		cell.actor = null;
		new_cell.actor = this;
		this.cell = new_cell;
		map.repaint(cell);
		map.repaint(new_cell);
		return true;
	}

	this.smart_move = function(dx, dy) {
		var dx2 = dx * dx, dy2 = dy * dy;
		var prefer_x = dx2 > dy2;
		if (!this.move(dx, dy)) {
			if (prefer_x)
				this.move(dx, 0) || this.move(0, dy);
			else
				this.move(0, dy) || this.move(dx, 0);
		}
	}
}

//basic actions

/** @constructor */

function hero_action(hero, key, name, mask, func) {
	this.hero = hero;
	this.key = key;
	this.name = name;
	this.mask = mask;
	this.func = func;
	this.combine = false;
	this.need_dir = false;

	this.apply = function(obj, obj2) {
		this.func.call(this.hero, obj, obj2);
	}
}

/** @constructor */

function inventory() {
	this.objects = [];
	
	this.add = function(obj, silent) {
		obj.type &= ~PICKABLE;
		if (obj.cell != null) {
			obj.cell.unlink(obj);
			obj.cell = null;
		}
		if (!silent)
			log("You picked up " + obj.name + ".");
		this.objects.push(obj);
	}
	
	this.find = function(name) {
		var objs = this.objects;
		for(var i = 0; i < objs.length; ++i) {
			var o = objs[i];
			if (o.name == name) 
				return o;
		}
		return null;
	}

	this.remove = function(obj) {
		var objs = this.objects, i = objs.indexOf(obj);
		if (i >= 0)
			objs.splice(i, 1);
	}
	
	this.get_actions = function() {
		var mask = 0;
		var objs = this.objects;
		for(var i = 0; i < objs.length; ++i) {
			mask |= objs[i].type;
		}
		return mask;
	}
	
	this.toString = function() {
		var c = {};
		var l = this.objects;
		if (!l.length)
			return "nothing";
		for(var i = 0; i < l.length; ++i) {
			var name = l[i].name;
			if (!c[name])
				c[name] = 1;
			else
				++c[name];
		}
		var r = "";
		for(var i in c) {
			var n = c[i];
			r += i;
			if (n > 1)
				r += "*" + n;
			r += ", ";
		}
		r = r.slice(0, -2);
		return r;
	}
}

/** @constructor */

function dungeon_monster(name, level) {
	this.name = name;
	this.level = level;
	
	movable.call(this);
	
	this.tick = function() {
		var hero = map.hero;
		var hero_cell = hero.cell, cell = this.cell;
		var dx = hero_cell.x - cell.x, dy = hero_cell.y - cell.y;
		var d = floor(Math.sqrt(dx * dx + dy * dy));
		var boss = this.boss;
		//now boss always moves randomly
		if (boss || d > 6) { //max distance
			dx = rand(-1, 2);
			dy = rand(-1, 2);
		} else {
			dx = sgn(dx);
			dy = sgn(dy);
		}
		this.smart_move(dx, dy);
	}
}

/** @constructor */

function hero() {
	this.name = "Mario";
	this.level = 1;
	this.MAX_LEVEL = 7;
	movable.call(this);
	this.cash = 0;
	this.inv = new inventory();
	this.poisoned = 0;
	this.blinded = 0;
	this.confused = 0;
	this.dead = 0;
	this.levels = ["Beggar", "Poor", "Labourer", "Professional", "Prosperous", "Millionaire", "Billionaire"];
	
	this.max_hp = function() {
		return 100 + this.level * 50;
	}
	
	this.level_cap = function() {
		return Math.pow(10, this.level + 1);
	}

	this.hp = this.max_hp();

	this.unlink = function(obj) {
		if (obj.cell != null)
			obj.cell.unlink(obj);
		else 
			this.inv.remove(obj);
	}
	
	this.pickup = function(obj) {
		this.inv.add(obj);
	}
	
	this.read = function(obj) {
		log("You read " + obj.name + ".");
		this.unlink(obj);
		var name = obj.name;
		if (name.indexOf("healing") >= 0) {
			this.hp = this.max_hp();
			log("You feel fully restored.");
		} else if (name.indexOf("vision") >= 0) {
			log("You feel somewhat enlightened.");
			map.foreach(function(cell) {
					if (!cell.visited) {
						cell.visited = true;
						map.repaint(cell);
					}
				});
		} else if (name.indexOf("cure") >= 0) {
			this.poisoned = 0;
			this.confused = 0;
			if (this.blinded) {
				this.blinded = 0;
				repaint_objects();
			}
		} else if (name.indexOf("genocide") >= 0) {
			map.foreach(function(cell) {
					if (cell.actor != null && cell.actor != map.hero && !cell.actor.boss) {
						cell.actor.drop_loot();
						cell.actor = null;
						map.repaint(cell);
					}
				});
		}
	}
	
	this.heal = function(n) {
		var hp = this.hp, hp0 = hp;
		hp += n;
		var max_hp = this.max_hp();
		if (hp > max_hp) {
			//add satiated effect? 
			hp = max_hp;
		}
		if (hp != hp0) {
			log("You restored " + (hp - hp0) + " health points.");
		}
		this.hp = hp;
	}

	this.eat = function(obj) {
		this.unlink(obj);
		var msg = ["Umph, it's rotten!", "Tastes great!", "Smells awful.", "You feel satiated."];
		log(rand(msg));
		var max_hp = this.max_hp();
		this.heal(rand(1, max_hp / 10));
	}
	
	this.throw_obj = function(obj, dx, dy) {
		this.unlink(obj);
		var text = "You threw " + obj.name + " and hit ";
		var cell = map.hero.cell;
		var x = cell.x, y = cell.y;
		for(;;) {
			cell = map.cells[y + dy][x + dx];
			if (cell.type == CELL_WALL) {
				text += "the wall";
				break;
			}
			if (cell.actor) {
				//hit something
				text += cell.actor.name;
				obj = null;
				break;
			}
			x += dx; y += dy;
		}
		animate_throw(x, y, obj, cell.actor, text + '.');
	}

	this.combine = function(obj1, obj2) {
		var obj = null;
		this.unlink(obj1);
		this.unlink(obj2);
		var r = (hash(obj1.name) + hash(obj2.name)) & 0x0f;
		var text = "got nothing.";
		if (in_range(r, 0, 4)) { //0, 1, 2, 3
			var book = book_list[r];
			obj = new dungeon_object(book[0], book[1]);
			text = "got " + obj.name + ".";
		} else if (in_range(r, 4, 8)) { //4, 5, 6, 7
			this.confused = rand(30, 40);
			text = "felt dizzy.";
		} else if (in_range(r, 8, 12)) {//8,9,10,11
			if (map.ambushed())
				text = "were attacked from ambush!";
		}
		//12,13,14,15 - nothing
		
		log("You tried to combine " + obj1.name + " and " + obj2.name + " and " + text);
		if (obj)
			this.inv.add(obj, true);
	}
	
	this.drink = function(obj) {
		this.unlink(obj);
		log("Refreshing!");
		var max_hp = this.max_hp();
		this.heal(rand(max_hp / 5, max_hp / 3));
		if (roll(0.05)) {
			log("You feel dizzy.");
			this.confused = rand(30, 40);
		}
	}
	
	this.search = function() {
		map.insert_random_object(food_list);
		if (roll(0.1))
			map.insert_random_monsters(1);
		if (roll(0.05))
			map.insert_random_object(book_list);
	}
	
	this.fix = function(obj) {
		obj.type &= ~FIXABLE;
		obj.name = "fixed pipes";
		var size = floor(3 * this.level / this.MAX_LEVEL + 3);
		run_mini_game(size, this.level_cap(), 10 - size);
	}
	this.add_cash = function(g) {
		var cap = this.level_cap();
		log("You got $" + g + ".");
		this.cash += g;
		if (this.level < this.MAX_LEVEL && this.cash >= cap) {
			++this.level;
			log(rand(["Occasionally you feel stronger!", "You gained next level!"]));
			this.cash -= cap;
		}
	}
	
	this.cheat = function() { this.add_cash(this.level_cap()); this.hp = this.max_hp(); } //keep this in one-line (grepped out by build.sh)
	
	this.get_actions = function() {
		var cell = this.cell;
		var objs = cell.objects;
		var mask = 0;
		for(var i = 0; i < objs.length; ) {
			var o = objs[i];
			switch(o.name) {
			case "gold": {
					objs.splice(i, 1);
					var cap = this.level_cap();
					var g = rand(cap / 10, cap / 5);
					this.add_cash(g);
					map.repaint(cell);
					continue;
				}
			case "key": {
					this.inv.add(o, true);
					objs.splice(i, 1);
					log("You picked up key to the next level.");
					map.repaint(cell);
					continue;
				}
			default:
				mask |= o.type;
				++i;
			}
		}
		mask |= this.inv.get_actions();
		var a = [];
		if (mask & PICKABLE)
			a.push(new hero_action(this, 'p', '<em>P</em>ickup', PICKABLE, this.pickup));
		if (mask & EDIBLE) {
			a.push(new hero_action(this, 'e', '<em>E</em>at', EDIBLE, this.eat));
			var t = new hero_action(this, 't', '<em>T</em>hrow', EDIBLE, this.throw_obj)
			t.need_dir = true;
			a.push(t);
			if (mask & DRINKABLE) {
				var ha = new hero_action(this, 'a', '<em>A</em>lchemy', EDIBLE | DRINKABLE, this.combine);
				ha.combine = true;
				a.push(ha);
			}
		}
		if (mask & READABLE)
			a.push(new hero_action(this, 'r', '<em>R</em>ead', READABLE, this.read));
		if (mask & DRINKABLE)
			a.push(new hero_action(this, 'd', '<em>D</em>rink', DRINKABLE, this.drink));
		if (mask & FIXABLE)
			a.push(new hero_action(this, 'f', '<em>F</em>ix', FIXABLE, this.fix));
		
		a.push(new hero_action(this, 's', '<em>S</em>earch', 0, this.search));
		a.push(new hero_action(this, 'h', 'C<em>h</em>eat', 0, this.cheat));
		
		var ct = cell.type;
		if (ct == CELL_EXIT || ct == CELL_ENTRANCE)
			a.push(new hero_action(this, 'x', 'E<em>x</em>it', 0, this.exit));
		return a;
	}
	
	this.get_objects = function(action, filter) {
		var r = [];
		var objs = this.cell.objects.concat(this.inv.objects);
		var mask = 0;
		if (!filter)
			filter = EDIBLE;
		for(var i = 0; i < objs.length; ++i) {
			var o = objs[i];
			if (action.combine? filter & o.type: action.mask & o.type)
				r.push([o, action]);
		}
		return r;
	}
	
	this.exit = function() {
		if (this.cell.type == CELL_ENTRANCE) {
			map.up();
		} else
			map.down();
	}
	
	this.tick = function() {
		if (this.poisoned > 0) {
			log(rand(["You are slowly dying.", "You feel sick."]));
			this.cell.blood = true;
			var hp = this.max_hp();
			this.damage(this, rand(hp / 20, hp / 10));
			--this.poisoned;
		}
		if (this.blinded > 0) {
			--this.blinded;
			if (this.blinded <= 0)
				repaint_objects();
		}
		if (this.confused > 0)
			--this.confused;
	}
}

/** @constructor */

function dungeon_object(name, type) {
	this.type = type;
	this.name = name;
}

/** @constructor */

function map_cell(type) {
	this.type = type;
	this.objects = [];
	this.actor = null;
	this.visited = false;
	this.blood = false;

	this.unlink = function(obj) {
		var objs = this.objects, i = objs.indexOf(obj);
		if (i >= 0)
			objs.splice(i, 1);
		map.repaint(this);
	}
}

/** @constructor */

function dungeon_room(l, t, r, b) {
	this.left = l;
	this.right = r;
	this.top = t;
	this.bottom = b;
	this.width = r - l;
	this.height = b - t;
	
	this.intersects = function(room) {
		//disallowing side-by-side walls
		return this.left <= room.right && this.right >= room.left && this.top <= room.bottom && this.bottom >= room.top;
	}
	this.manhattan = function(room) {
		var x1 = (this.left + this.right) >> 1;
		var x2 = (room.left + room.right) >> 1;
		var y1 = (this.top + this.bottom) >> 1;
		var y2 = (room.top + room.bottom) >> 1;
		return abs(x1 - x2) + abs(y1 - y2);
	}
	
	this.render = function(cells) {
		var l = this.left, r = this.right; t = this.top, b = this.bottom;
		for(var y = t; y < b; ++y) {
			for(var x = l; x < r; ++x) {
				var cell = cells[y][x];
				if (cell.type != CELL_VOID)
					continue;
				cell.type = (x == l || x == r - 1 || y == t || y == b - 1)? CELL_WALL: CELL_FLOOR;
				cell.room = [l, t, r, b];
			}
		}
	}
}


/** @constructor */

function dungeon_map(width, height) {
	this.width = width;
	this.height = height;
	this.cells = [];
	this.objects = [];
	this.repaint = null;
	this.repaint_all = null;
	this.levels = [];
	this.level = 0;
	this.hero = new hero();
	this.pipes = 0;
	this.fixed = 0;
	this.boss_killed = false;
	
	this.patch = function(x, y, type) {
		if (in_range(x, 0, this.width) && in_range(y, 0, this.height)) {
			var cell = this.cells[y][x];
			if (cell.type == CELL_VOID) {
				cell.type = type;
				return true;
			}
		}
		return false;
	}

	this.patch_random = function(room, type) {
		while(true) {
			var x = rand(room.left + 1, room.right - 1), y = rand(room.top + 1, room.bottom - 1);
			var cell = this.cells[y][x];
			if (cell.type == CELL_FLOOR) {
				cell.type = type;
				return cell;
			}
		}
	}
	
	this.connect = function(room1, room2) {
		var x = (room1.left + room1.right) >> 1;
		var y = (room1.top + room1.bottom) >> 1;
		var x2 = (room2.left + room2.right) >> 1;
		var y2 = (room2.top + room2.bottom) >> 1;
		while(x != x2 || y != y2) {
			var rx = abs(x - x2), ry = abs(y - y2);
			var dx = rx? (x2 - x) / rx: 0, dy = ry? (y2 - y) / ry: 0;
			var t = random();
			if (t < 0.3)
				dx = 0;
			else if (t > 0.7)
				dy = 0;

			if (dx != 0 && dy != 0) {
				if (rx >= ry)
					dy = 0;
				else
					dx = 0;
			}

			var cell = this.cells[y][x];
			switch(cell.type) {
			case CELL_VOID:
			case CELL_WALL:
				cell.type = CELL_FLOOR;
				break;
			}
			for(var wy = -1; wy <= 1; ++wy)
				for(var wx = -1; wx <= 1; ++wx) {
					if (wx | wy)
						this.patch(x + wx, y + wy, CELL_WALL);
				}
			
			x += dx;
			y += dy;
		}
	}
	
	this.insert_object = function(object, x, y) {
		var cell = this.cells[y][x];
		object.cell = cell;
		cell.objects.push(object);
		this.repaint(cell);
	}

	this.insert_actor = function(actor, cell) {
		actor.cell = cell;
		cell.actor = actor;
	}
	
	this.insert_random_object = function(objs) {
		var x = rand(0, this.width), y = rand(0, this.height);
		if (this.cells[y][x].type != CELL_FLOOR)
			return;
			
		var o = rand(objs);
		var e = new dungeon_object(o[0], o[1]);
		this.insert_object(e, x, y);
	}
	
	this.generate = function() {
		var MAX_SIZE = 0.3;
		var MIN_SIZE = 5; //with walls around
		var MAX_ASPECT = 1.75;
		var MIN_ASPECT = 1 / MAX_ASPECT;
		var MAX_ROOMS = 10;
		var MAX_ROOM_ATTEMPTS = 5;
		var rooms = [];

		var width = this.width, height = this.height;
		
		this.cells = [];
		var cells = this.cells;
		for(var y = 0; y < height; ++y) {
			cells[y] = [];
			var row = cells[y];
			for(var x = 0; x < width; ++x) {
				row.push(new map_cell(CELL_VOID));
				var cell = row[x];
				cell.x = x;
				cell.y = y;
			}
		}
		
		var hero = this.hero;
		if (hero.level == hero.MAX_LEVEL) {
			//final boss
			var room = new dungeon_room(1, 1, width - 2, height - 2);
			room.render(cells);
			var enter_cell = cells[height >> 1][width >> 1];
			enter_cell.type = CELL_ENTRANCE;
			for(var i = 0; i < width * height / 4; ++i) {
				cells[rand(1, height)][rand(1, width)].blood = true; //dont care about bounds anyway
			}
			this.levels[this.level] = cells;
			this.insert_actor(hero, enter_cell);
			var rabbit = new dungeon_monster("Killer Rabbit of Caerbannog", 25);
			rabbit.boss = true;
			this.insert_actor(rabbit, this.cells[height / 2][width / 2 + 7]);
			log(" Follow!  But! follow only if ye be men of valor, " + 
				"for the entrance to this cave is guarded by a creature so foul, " + 
				"so cruel that no man yet has fought with it and lived!  " + 
				"Bones of four fifty men lie strewn about its lair. " + 
				"So, brave " + hero.name + ", if you do doubt your courage or" +
				"your strength, come no further, for death awaits you " + 
				"all with nasty big pointy teeth.");

			this.update_view();
			this.repaint_all();
			return;
		}

		for(var i = 0; i < MAX_ROOMS * MAX_ROOM_ATTEMPTS; ++i) {
			var w = rand(MIN_SIZE, (this.width - MIN_SIZE - 2) * MAX_SIZE);
			var aspect = MIN_ASPECT + random() * (MAX_ASPECT - MIN_ASPECT);
			var h = (w * aspect) | 0;
			var x = rand(0, width - w);
			var y = rand(0, height - h);
			if (x + w >= width || y + h >= height || w < MIN_SIZE || h < MIN_SIZE)
				continue;
			var room = new dungeon_room(x, y, x + w, y + h);
			var j;
			for(j = 0; j < rooms.length; ++j) {
				if (room.intersects(rooms[j]))
					break;
			}
			if (j == rooms.length) {
				room.id = rooms.length;
				rooms.push(room);
				room.render(cells);
			}
			if (rooms.length >= MAX_ROOMS)
				break;
		}
		var enter_id = rand(0, rooms.length);
		var exit_id = enter_id;
		while(enter_id == exit_id) {
			exit_id = rand(0, rooms.length);
		}
		var enter_cell = this.patch_random(rooms[enter_id], CELL_ENTRANCE);
		var exit_cell = this.patch_random(rooms[exit_id], CELL_EXIT);
		
		for(var i = 0; i < rooms.length; ++i) {
			var room = rooms[i];
			room.distances = [];
			room.connected = [];
			for(var j = 0; j < rooms.length; ++j) {
				room.distances.push((i != j)? room.manhattan(rooms[j]): 0);
			}
		}
		for(var i = 0; i < rooms.length - 1; ++i) {
			var room = rooms[i];
			var d = room.distances.slice();
			d.sort();
			var m = d[floor(Math.sqrt(d.length))];
			if (rooms.length <= 4)
				m = d[d.length - 1];
			
			//alert(m);
			for(var j = i + 1; j < rooms.length; ++j) {
				if (room.distances[j] <= m) {
					room.connected.push(j);
					rooms[j].connected.push(i);
					this.connect(room, rooms[j]);
				}
			}
		}
		
		var visited = Array();
		var check = [enter_id];
		var connected = [];
		while(true) {
			while(check.length) {
				i = check.pop();
				if (connected.indexOf(i) < 0)
					connected.push(i);
				
				var room = rooms[i];
				for(var j = 0; j < room.connected.length; ++j) {
					var v = room.connected[j];
					if (connected.indexOf(v) < 0) {
						check.push(v);
						connected.push(v);
					}
				}
			}
			if (connected.length < rooms.length) {
				var closest_room1 = null, closest_room2 = null, closest_room_dist = 0;
				for(var i = 0; i < rooms.length; ++i) {
					if (connected.indexOf(i) < 0) //skip connected nodes
						continue;
					var room1 = rooms[i];
					for(var j = 0; j < rooms.length; ++j) {
						if (connected.indexOf(j) < 0) {
							var room2 = rooms[j];
							if (closest_room1 == null || room1.manhattan(room2) < closest_room_dist) {
								closest_room1 = room1;
								closest_room2 = room2;
								closest_room_dist = room1.manhattan(room2);
							}
						}
					}
				}
				if (closest_room1 == null) {
					alert("closest_room1 == null");
					break;
				}
				//alert("connecting " + closest_room1.id + " and " + closest_room2.id);
				closest_room1.connected.push(closest_room2.id);
				closest_room2.connected.push(closest_room1.id);
				check.push(closest_room1.id);
				check.push(closest_room2.id);
				this.connect(closest_room1, closest_room2);
			} else
				break;
		}
		//generating objects here
		
		this.insert_actor(hero, enter_cell);
		this.levels[this.level] = cells;
		this.repaint_all();
		this.update_view();
		
		while(true) {
			var x = rand(0, width), y = rand(0, height);
			if (cells[y][x].type != CELL_FLOOR)
				continue;
			var o = new dungeon_object("key", PICKABLE);
			this.insert_object(o, x, y);
			break;
		}

		if (roll(0.3)) {
			while(true) {
				var x = rand(0, width), y = rand(0, height);
				if (cells[y][x].type != CELL_FLOOR)
					continue;
				var o = new dungeon_object("pipes", FIXABLE);
				this.insert_object(o, x, y);
				++this.pipes;
				break;
			}
			log("Your senses tell you about broken pipe on this floor!");
		}

		for(var i = 0; i < rooms.length * 5; ++i)
			this.insert_random_object(food_list);
		this.insert_random_object(book_list);
		this.insert_random_monsters(rooms.length * 5);
	}
	
	this.ambushed = function() {
		var hero_cell = this.hero.cell;
		var cells = []
		for(var dy = -1; dy <= 1; ++dy)
			for(var dx = -1; dx <= 1; ++dx) {
				if (dx | dy) {
					var cell = this.cells[hero_cell.y + dy][hero_cell.x + dx];
					if (cell.type == CELL_FLOOR && !cell.actor)
						cells.push(cell);
				}
			}
		if (cells.length) {
			var cell = rand(cells);
			this.insert_actor(this.generate_monster(), cell);
			this.repaint(cell);
			return true;
		}
		return false;
	}
	
	this.generate_monster = function() {
		var hero = this.hero, monster_list_length = monster_list.length;
		var level = 1 + floor(monster_list_length * (hero.level - 1) / hero.MAX_LEVEL);
		if (level > 3 && level < monster_list_length) //a bit harder
			++level;
		var monsters = monster_list.slice(0, level);
		var monsters_len = monsters.length;
		var m_level = rand(monsters_len > 3? monsters_len - 3: 0, monsters_len);
		//log("monster level: " + level + " of " + monster_list.length + "-&gt;" + m_level);
		var o = rand(monsters[m_level]);
		var m = new dungeon_monster(o, m_level + 1);
		if (o.indexOf("poison") >= 0)
			m.poison_chance = 0.2;
		if (o == "ghost" || o == "mutant" || o == "wasp")
			m.blind_chance = 0.3;
		/*
		if (o == "spider") {
			m.blind_chance = 1;
			m.poison_chance = 1;
		}
		*/
		return m;
	}
	
	this.insert_random_monsters = function(n) {
		//log("spawning " + n + "monsters");
		for(var i = 0; i < n; ++i) {
			var x = rand(0, this.width), y = rand(0, this.height);
			var c = this.cells[y][x];
			if (c.type == CELL_FLOOR && !c.actor) {
				this.insert_actor(this.generate_monster(), c);
				this.repaint(c);
			}
		}
	}

	this.init_hero = function(cell_type) {
		this.foreach(function(cell) {
				if (cell.type == cell_type) {
					map.hero.cell = cell;
				}
			});
	}
	
	this.up = function() {
		var l = this.level, levels = this.levels;
		if (l == 0) {
			//add final here!
			if (this.boss_killed && this.fixed >= this.pipes)
				this.win(this.hero);
			else
				log("You must fix all pipes(and probably kill someone), until then there's no way out!");
			return;
		}
		log("you climbed up the stairs to the level " + l + ".");
		this.cells = levels[--l];
		this.level = l;
		this.init_hero(CELL_EXIT);
		this.insert_random_monsters(5);
		this.repaint_all();
	}
	
	
	this.down = function() {
		var l = this.level + 1, levels = this.levels;
		var hero = this.hero; //every new level requires a key to unlock it.
		var key = hero.inv.find("key");

		if (l >= levels.length && key == null) {
			log("This door is locked. Find the key to unlock it.");
			return;
		}
		
		this.level = l;
		log("you stepped down the stairs to the level " + (l + 1) + ".");
	
		if (l >= levels.length) {
			hero.inv.remove(key);
			this.generate();
		} else {
			this.cells = levels[l];
			this.init_hero(CELL_ENTRANCE);
			this.repaint_all();
			this.insert_random_monsters(5);
		}
	}
	
	this.view_line = function(x, y, dx, dy) {
		if (!(dx | dy))
			return;
		var w = this.width, h = this.height;
		//log("trying view " + x + ", " + y + ", " + dx + ", " + dy);
		while(in_range(x, 0, w) && in_range(y, 0, h)) {
			var c = this.cells[y][x];
			if (!c.visited) {
				c.visited = true;
				this.repaint(c);
			}
			if (c.type == CELL_WALL)
				break;
			x += dx; y += dy;
		}
	}
	this.update_view = function() {
		var w = this.width, h = this.height;
		var hero = this.hero;
		var cell = hero.cell;
		if (cell.room) {
			//entering the room
			var room = cell.room;
			for(var y = room[1]; y < room[3]; ++y) {
				for(var x = room[0]; x < room[2]; ++x) {
					var c = this.cells[y][x];
					if (!c.visited) {
						c.visited = true;
						this.repaint(c);
					}
				}
			}
		}
		for(var y = -1; y <= 1; ++y)
			for(var x = -1; x <= 1; ++x)
				this.view_line(hero.cell.x, hero.cell.y, x, y);
	}
	
	this.tick = function() {
		this.update_view();
		var m = [];
		this.foreach(function(cell) {
				var a = cell.actor;
				if (a != null)
					m.push(a);
			});
		for (var i = 0; i < m.length; ++i)
			m[i].tick();
	}
	
	this.foreach = function(func) {
		for(var y = 0; y < this.height; ++y) 
			for(var x = 0; x < this.width; ++x)
				func(this.cells[y][x]);
	}
}

document.title = "Fontanero. 10k Adventure for Gold and Glory. v3";


<!DOCTYPE HTML>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<title></title>
	<script type="text/javascript" src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js"></script>
	<script type="text/javascript" src="game.js"></script>
	<script type="text/javascript" src="startup.js"></script>
	<script type="text/javascript" src="shared_ui.js"></script>
	<script type="text/javascript" src="ui.js"></script>
	<link rel="stylesheet" href="style.css" type="text/css" media="screen">
</head>
<body>
	<script type="text/javascript">$(start(""));</script>
</body>
</html>

#!/usr/bin/python

import png, sys, math

align = 11

if len(sys.argv) < 3: 
	print("usage: jsfile pngfile")
	sys.exit(0)

f = open(sys.argv[1])
data = f.read()
n = len(data)
align = (1 << align) - 1
w = int(round(math.sqrt(n)) + align) & ~align;
h = int(1 + (n - 1) / w)
print("creating %dx%d image..." %(w, h));

rows = []
for i in xrange(0, h):
	rows.append([])
	for j in xrange(0, w):
		idx = i * w + j
		c = ord(data[idx]) if idx < n else 10
		if c < 32:
			if c == 10:
				c = 31
			else:
				raise Exception("unsupported char code %d" %c)
		rows[i].append(c - 31)

out = open(sys.argv[2], 'wb')

#print pixels
w = png.Writer(width=w, height=h, greyscale = True, bitdepth = 8, compression=9)
w.write(out, rows)

<!DOCTYPE HTML>
<html lang="en-US"><head><title></title><meta charset="UTF-8"><script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js"></script></head><body><script><!--
--></script></body></html>

<!DOCTYPE HTML>
<html lang="en-US"><head><title></title><meta charset="UTF-8"><script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js"></script></head><body><script><!--
--></script></body></html>

function loadpng(filename, callback) {
	var canvas = $("<canvas>")
		['attr']({width: WIDTH, height: HEIGHT})
		//['css']({'width': WIDTH + 'px', 'height': HEIGHT + 'px'})
		['get'](0), ctx;
	if (!canvas.getContext || !(ctx = canvas.getContext("2d")) || !ctx.getImageData) {
		alert('No canvas');
		return;
	}
	
	$('body')['append'](
	$('<img>')
		['css']({position: 'absolute', left: -WIDTH})
		['load'](function() {
			var self = this;
			var w = WIDTH;
			var h = HEIGHT;
			ctx.drawImage(self, 0, 0);
			var image_data = ctx.getImageData(0, 0, w, h).data;
			var str_data = "";
			var len = image_data.length;
			for (var i = 0; i < len; i += 4) {
				var b = image_data[i];
				str_data += String.fromCharCode(b > 0? b + 31: 10);
			};
			callback(str_data);
			$(self)['remove']();
		})
		['attr']('src', filename)
	); //body.append
}

function start(code) {
	eval(code.replace(/@@/g, '.length').replace(/@/g, 'function').replace(/\`/g, 'this.'));
	S();
}



		// == interface for the game ==
		function run_mini_game (size, prize, shuffle) {
			var size = size || 10,
				shuffle = shuffle || size,
				game = {
					is_win : false,
					gold : prize || 30
				},

				field = [];

			var turn = function(x, y) {
				var row = field[y];
				row[x] = !row[x];
				$('#m' + x + '_' + y)['toggleClass']('r');
			}

			var is_win_position = function() {
				for(var j = 0; j < size; ++j)
					for(var i = 0; i < size; ++i)
						if (!field[j][i])
							return false;
				return true;
			}

			var win = function () {
				game.is_win = true;
				$('#mg')['hide']()['empty']();
				++map.fixed;
				map.hero.add_cash(game.gold);
			}

			// do the move
			var move = function(x, y, shuffle_phase) {
				for(var i=0; i<size; i++) {
					turn(x, i);
					turn(i, y);
				}
				turn(x,y);
				if (is_win_position() && !shuffle_phase) {
					win();
				}
			}

			var generate = function() {
					// generate field
					for(var j=0, s=''; j<size; ++j) {
						field[j] = [];
						for(var i=0; i<size; ++i) {
							field[j][i] = true;
							s += '<b class="f" id="m' + i + '_' + j + '"></b>'
						}
					}

					// game field
					$('#mf')						// hide on start
					['html'](s)						// draw
					['css']({						// set dimensions and position
						width: size * 32,
						height: size * 32
					});

					// shuffle field
					for (var i=0; i < shuffle; ++i) {
						move(rand(0, size), rand(0, size), true);
						if (is_win_position())
							i=0;
					};
			}

			// create html
			$('#mg')['html']('<p id="mt">$' + prize + '</p>'+
			'<p id="mr">' +
			"<br>Goal of this minigame is turn <br>all the pipes to its right position (+).<br>" +
			"Click to turn pipe. <br>" + 
			'<br><button id="ms">Start!</button>' +
			'</p>' + 
			'<p id="mf"/><button id="g">Give up!</button>');
			
			generate();
			
			// start button runs the game
//			$('#ms')['bind']('click.mg', function() {
//			});
			
			// set onclick for 
			$('#mg')['bind']('click.mg', function(e) {
				var el = e.target;
				if (el.tagName == 'B') {
					move( el.id.replace(/^m(\d+)_\d+$/, '$1'), el.id.replace(/^m\d+_(\d+)$/, '$1'));
				} 
				switch(el.id) {
				case 'g':
					game.gold = 1;
					win();
					break;
				case 'ms': 
					$('#mr')['hide']();
					$('#mf, #g')['show']();
					// start timer!
					$('#mg')['bind']('tick.mg', {
							's': game,
							'id': setInterval("$('#mg').trigger('tick.mg')", 1000)
						}, function(e) {
								var s = e.data['s'];
								if (s.gold > 100)
									s.gold = floor(s.gold / 1.5);
								else
									s.gold -= rand(1, 4);
								if (s.gold < 1)
									s.gold = 1;

								if (s.is_win) {
									clearInterval(e.data['id']);
									$('#mg')['unbind']('.mg');
								}
								else {
									$('#mt')['html']('$' + s.gold);
								}
							}
					);
				}
			})['show']();
			$('#ms')['focus']();
		}

var actions = null;
var objects = null;
var combine = false;
var first_object = null;
var throw_obj = false;

function panel() {
	if (map == null)
		return;
	var hero = map.hero, level = hero.level;

	var html = "<dl><dt id='f'>" + hero.name + " the Fontanero<small>Level: " + hero.level + " (" + hero.levels[level-1] + ")</small></dt><dd>";
	html += "<b>HP:</b> " + hero.hp + " (" + hero.max_hp() +  ")" + 
	(hero.poisoned? " <b id='ps'>[POISONED]</b> ":"") + 
	(hero.blinded? " <b id='bl'>[BLINDED]</b>":"") + 
	(hero.confused? " <b id='cf'>[CONFUSED]</b>":"") + 
	"<br><b>Cash:</b> $" + hero.cash + " / " + hero.level_cap() +"<br>" + 
	"<b>Pipes found:</b> " + map.pipes + "<br><b>Pipes fixed:</b> " + map.fixed; 
	if (throw_obj) {
		html += '<dt>Choose direction:</dt><dd>Press up, down, left or right to throw ' + first_object.name +'</dd>';
		$('#panel')['html'](html);
		return;
	} else if (objects) {
		html += '<dt>Choose item:</dt><dd><ol>';
		for(var i = 0; i < objects.length; ++i) {
			var o = objects[i];
			html += "<li>" + o[0].name + "</li>";
		}
		html += '</ol></dd>';
		$('#panel')['html'](html);
		return;
	} else {
		html += '<dt>You are carrying:</dt><dd>' + hero.inv + '</dd>';
	}

	actions = hero.get_actions(); //MUST BE CALLED FIRST (do auto-pickup and other stuff)
	var objs = hero.cell.objects;
	var mask = 0;
	html += '<dt>You see:</dt><dd>';
	if (objs.length) {
		for(var i = 0; i < objs.length; ++i) {
			var o = objs[i];
			mask |= o.type;
			html += (i? ', ': '') + o.name;
		}
	}
	else {
		html += 'nothing'
	}
	html += "</dd>";
	
	html += '<dt>Actions:</dt><dd id="a"><ul>';
	for(var i = 0; i < actions.length; ++i) {
		html += '<li>' + actions[i].name + "</li>";
	}
	html += '</ul></dd>';
	$('#panel')['html'](html);
}

function on_key(e) {
	var h = map.hero;
	if (map == null || e.metaKey || $("#mg")['is'](":visible") || h.hp <= 0)
		return;
	
	var key = e.which || e.keyCode;
	var key_char = String.fromCharCode(key).toLowerCase();
	key = key_char.charCodeAt(0);
	var used = false, call_tick = true;
	//log("key " + key + "(" + key_char + ")");

	switch(key) {
	case 27:
		used = true;
		combine = false;
		throw_obj = false;
		first_object = null;
		break;
	case 37:
	case 38:
	case 39:
	case 40:
		var dx = [-1, 0, 1, 0][key - 37], dy = [0, -1, 0, 1][key - 37];
		if (h.confused > 0) {
			dx = -dx;
			dy = -dy;
		}
		if (throw_obj) {
			h.throw_obj(first_object, dx, dy);
			call_tick = false;
		} else
			h.move(dx, dy);
		used = true;
		throw_obj = false;
		first_object = null;
		objects = null;
		break;
	default:
		if (objects != null) {
			var i = key - 0x61; //ord('a');
			if (in_range(i, 0, objects.length)) {
				var o = objects[i];
				var a = o[1], obj = o[0];
				if (combine && first_object == null) {
					first_object = obj;
					objects = h.get_objects(a, DRINKABLE);
					call_tick = false;
					used = true;
					break;
				}
				if (a.need_dir) {
					first_object = obj;
					throw_obj = true;
					call_tick = false;
					used = true;
					break;
				}
				a.apply(obj, first_object);
			} 
			used = true;
			objects = null;
		} else if (actions != null) {
			for(var i = 0; i < actions.length; ++i) {
				var a = actions[i];
				if (a.key == key_char) {
					objects = h.get_objects(a);
					combine = a.combine;
					first_object = null;
					switch(objects.length) {
					case 0:
						a.apply(); //auto-action w/o object (like (s)leep)
						objects = null;
						break;
					case 1:
						var obj = objects[0][0];
						if (combine) { //choose even one object
							call_tick = false;
							break;
						}
						if (a.need_dir) {
							first_object = obj;
							throw_obj = true;
							call_tick = false;
							break;
						}
						a.apply(obj);
						objects = null;
						break;
					default:
						call_tick = false;
					}
					actions = null;
					used = true;
					break;
				}
			}
		}
	}
	if (used) {
		e.preventDefault();
		if (call_tick)
			map.tick();
		panel();
	}
}

function intro() {
	log("You've entered the <s>dungeon</s> cellar to fix all broken pipes and vents.");
}

/*
window.onbeforeunload = function (evt) {
	evt = evt || window.event;
	if (evt) {
		evt.returnValue = "Are you sure you want to leave?";
	}
	return message;
}
*/

$(document)['bind']($['browser']['mozilla'] ? 'keypress' : 'keydown', on_key);

	#wrapper {
		position: relative;
		border: 1px solid #000;
		overflow: hidden;
		background: black;
	}
	#map {
		margin-top: 16px;
		position: absolute;
		left: 0; top: 0;
	}
	/* 	Floor and roof:
		====================================================================== */
		#floor {
			background: #333;
			-moz-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-moz-transform-origin: 0% 0%;

			-webkit-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-webkit-transform-origin: 0% 0%;

			-o-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-o-transform-origin: 0% 0%;
			}
			.u {
				position: absolute;
				width: 32px;
				height: 32px;
				background: black;
				}
	/* 	Walls & doors:
		====================================================================== */
		#walls {
			position: absolute;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
		}
			.w {
				display: block;
				position: absolute;
				left: 50%;
				width: 32px;
				height: 32px;
				padding-top: 16px;	/* WALL_HEIGHT - TILE_SIZE */
				-moz-transform-origin: 100% 0;
				-webkit-transform-origin: 100% 0;
				-o-transform-origin: 100% 0;
/*				background: url('wall.png') repeat;*/
				}
		/* 	Walls:
			---------------------------------------------------------------------- */
			.w {
				background: green;
				}
				.r, .l.a {
					margin-top:-32px;
					}
				.r {
					background: #060;
					-moz-transform: skew(0deg, -26.7deg);
					-webkit-transform: skew(0deg, -26.7deg);
					-o-transform: skew(0deg, -26.7deg);
					}
				.r.a {
					margin-top: -48px;
					}
				.r.a, .l {
					margin-left: -32px;
					}
				.l {
					-moz-transform: skew(0deg, 26.7deg);
					-webkit-transform: skew(0deg, 26.7deg);
					-o-transform: skew(0deg, 26.7deg);
					margin-top: -16px;
					}
				.l.a {
					opacity: 0.7;
					margin-left: 0;
					}
				.a {
					opacity: 0.8;
					background: black;
					background: -moz-linear-gradient(bottom center, black 95%, rgba(0,204,0,0));
					background: -webkit-gradient(linear, left bottom, left top, color-stop(0.95, black), to(rgba(0,204,0,0)));
					}
			/* 	Wall decorations:
				---------------------------------------------------------------------- */
				.d {
					font-family: 'Webdings';
					font-size: 26px;
					font-weight: normal;
					text-align: center;
					}
					.paint:after {
						content: '\f0ad';
						}
					.switch:after {
						content: '\f0bc';
					}
					.plug:after {
						content: '\f0bd';
					}
					.display:after {
						content: '\f0be';
					}
					.calendar:after {
						content: '\f0a6';
					}
					.ibelieve:after {
						content: '\f085';
					}
				
				
/* 	Special zones:
	====================================================================== */
/* 	Enter:
	---------------------------------------------------------------------- */
	.enter, .exit {
		width: 64px;
		height: 64px;
		margin-left: -32px;
	}
	.enter, .exit, 
	.enter:after, .exit:after,
	.enter:before, .exit:before {
		display: block;
		position: absolute;
	}
	.enter:after, .exit:after {
		left: 10px; top: -12px;
		font-family: 'Wingdings';
		-moz-transform-origin: 100% 0;
		-moz-transform: skew(0deg, 30deg);
		-webkit-transform-origin: 100% 0;
		-webkit-transform: skew(0deg, 30deg);
		-o-transform-origin: 100% 0;
		-o-transform: skew(0deg, 30deg);
		font-size: 60px;
		text-shadow: 2px -2px 0px #000;
	}
		.enter:before, .exit:before {
			content: ' ';
			left: -22px; top: 8px;
			-moz-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-moz-transform-origin: 100% 100%;
			-webkit-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-webkit-transform-origin: 100% 100%;
			-o-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-o-transform-origin: 100% 100%;
			width: 50px;
			height: 50px;
			-moz-border-radius: 15px;
			-webkit-border-radius: 15px;
			border: 4px solid #111;
			background: -moz-linear-gradient(40deg, black 50%, #222);
			background: -webkit-gradient(linear, left bottom, right top, color-stop(0.5, #000), to(#222));
		}
		.exit:before {
			border-color: #11c;
			background: #22e;
			}
		.enter:after {
			color: #cc0;
			content: '\f0e2';
			}
			#linux .enter:after {
				content: '\00e2';
				}
		.exit:after {
			color: #00c;
			content: '\f0e1';
			}
			#linux .exit:after {
				content: '\00e1';
				}
/* 	Objects:
	====================================================================== */
	.parrot, .apple, #hero, .book, .pile, .potion, .gold, .wasp {
		position: absolute;
		width: 32px;
		height: 32px;
		/*-moz-transform: scale(1, 0.5) skew(-45deg, 45deg);
				-moz-transform-origin: 0% 0%;
				-webkit-transform: scale(1, 0.5) skew(-45deg, 45deg);
				-webkit-transform-origin: 0% 0%;*/
		font-family: 'Webdings';
	}
	#hero {
			left: 50%;
			top: 50%;
	}
	#hero:after {
		-moz-transform-origin: 100% 0;
		-webkit-transform-origin: 100% 0;
		-o-transform-origin: 100% 0;		
		-moz-transform: skew(0deg, 26.7deg);
		-webkit-transform: skew(0deg, 26.7deg);
		-o-transform: skew(0deg, 26.7deg);
		
		position: absolute;
		content: '\f080';
		left: -32px;
		top: -32px;
		color: #006;
		font-size: 80px;
		text-shadow: 2px -2px 0px #003;
	}
	.pile {
		background: grey;
	}
	.parrot {
		background: orange;
	}
	.apple {
		background: red;
	}
	.book {
		background: brown;
	}
	.potion {
		background: blue;
	}
	.gold {
		color: yellow;
		font-size: 40px;
		text-shadow: 2px -1px 0px #660;
	}
	.gold:after {
/*		-moz-transform-origin: 100% 0;
		-webkit-transform-origin: 100% 0;
		-o-transform-origin: 100% 0;		
		-moz-transform: skew(0deg, 10deg);
		-webkit-transform: skew(0deg, 10deg);
		-o-transform: skew(0deg, 10deg);
*/		
		position: absolute;
		content: '\f091';
		left: 0px;
		top: 0px;
	}
	
	.wasp {
		background: yellow;
	}

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
</head>
<body>
	<script type="text/javascript">
	<!--
	//ie hack
	if(!Array.indexOf){
		Array.prototype.indexOf = function(obj){
			for(var i = 0; i < this.length; ++i){
				if (this[i] == obj)
					return i;
			}
			return -1;
		}
	}
	-->
	</script>
	<script type="text/javascript" src="https://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js"></script>
	<script type="text/javascript" src="game.js"></script>
	<script type="text/javascript" src="startup.js"></script>
	<script type="text/javascript" src="shared_ui.js"></script>
	<script type="text/javascript" src="minigame.js"></script>
	<script type="text/javascript" src="tui.js"></script>
	<script type="text/javascript">S("");</script>
	<link rel="stylesheet" href="tstyle.css" type="text/css">
</body></html>

* {margin: 0; padding: 0;
	font-weight: normal;
	font-style: normal;
	list-style: none;
	}
body {
	font: normal 12px Verdana;
	background: #055;
	color: #fff;
}
/* text-align: center */
h1, #mg {
	text-align: center;
}
/* float: left */
#c, #panel, i, u, .f {
	float: left;
}
/* display: block */
small, .f, i, u, #s {
	display: block;
}
/* display: none */
#mg, #mf, #g, #th {
	display: none;
}
/* padding: 8px */
#mf, #mr, #c, dt, #l {
	padding: 8px;
}
/* position: relative */
dd, .t1, #map {
	position: relative;
}
/* font-weight: bold */
#mt, dt, b {
	font-weight: bold;
}
/* font-size: 14px */
#f, .f {
	font-size: 14px;
}
/* overflow: hidden */
#mf, #mr, #map, #l {
	overflow: hidden;
}
#p {
	width: 1000px;
	margin: 0 auto;
}
h1 {
	padding: 20px 0
}
#c, dt, #mf, #mr {
	border: 3px solid #c93
}
#c, dt, #mf, #mr, #l {
	-moz-border-radius: 5px;
	-webkit-border-radius: 5px;
	border-radius: 5px;
}
#c, dt {
	background: #122;
}
dt {
	padding: 8px 20px;
	border-left: 0;
	-moz-border-radius: 0 5px 5px 0;
	-webkit-border-radius: 0 5px 5px 0;
	border-radius: 0 5px 5px 0;
}
dd {
	padding: 10px 20px 25px;
	background: -moz-linear-gradient(-80deg, rgba(0,0,0,0.8), rgba(0,0,0,0) 80px);
	background: -webkit-gradient(linear, center -40%, 55% 50, from(rgba(0,0,0,0.8)), to(rgba(0,0,0,0)));
	margin: 0 3px;
}
#panel {
	margin-left: -3px;
	width: 325px;
}

#l {
	font: 12px monospace;
	height: 128px;
	overflow: auto;
	background: #244;
}
dd b {
	display: inline-block;
	width: 100px;
}
ol li {
	list-style: lower-alpha inside;
}
/* Actions */
em {
	color: #c00;
}
/* poisoned */
#ps {
	color: #0c0;
	text-shadow: 0 0 3px #0c0;
}
/* blinded */
#bl {
	color: #cc0;
	text-shadow: 0 0 3px #cc0;
}
/* confused */
#cf {
	color: #0cc;
	text-shadow: 0 0 3px #0cc;
}
/* Map styles */
u, i {
	background: url(t.png); width: 16px; height: 16px;
}
u { clear: left}
#s {
	margin: 0 0 8px auto;
	padding: 0 8px;
	border: 2px solid;
}
.on i {
	-moz-box-shadow: 0px 0px 4px #323a55; 
	-webkit-box-shadow: 0px 0px 4px #323a55; 
	box-shadow: 0px 0px 4px #323a55; 
}
.on .t1 {
	-moz-box-shadow: 3px 2px 2px #000; 
	-webkit-box-shadow: 3px 2px 2px #000; 
	box-shadow: 3px 2px 2px #000;
/*	z-index: 10;*/
}
/* Minigame styles */
#mg {
	left: 0;
	top: 0;
	position: fixed;
	width: 100%;
	height: 100%;
	background: rgba(0,0,0,0.9);
	color: #000;
}
#mf, #mr {
	margin: 100px auto 20px;
	width: 250px;
	height: 150px;
	background: #fff;
}
.f {
	font-size: 18px;
	width: 32px;
	height: 32px;
	line-height: 32px;
	-moz-transition-property: -moz-transform, color;
	-moz-transition-duration: 0.4s;	
	-webkit-transition-property: -webkit-transform, color;
	-webkit-transition-duration: 0.4s;	
	-o-transition-property: -o-transform, color;
	-o-transition-duration: 0.4s;
	color: #060;
}
.f:after {
	content: '+';
}
.ie .r:after {
	content: '\00d7';
}
.f:hover {
	background: #ccc;
}
#mt {
	font-size: 40px;
	color: #0c0;
}
.r {
	color: #600;
	-moz-transform: rotate(45deg);
	-webkit-transform: rotate(45deg);	
	-o-transform: rotate(45deg);
}
#th {
	position: absolute;
	background-position:0 -112px;
/*	z-index: 8;*/
}

function gettile(cell) {
	if (!cell.visited)
		return -1;
	var actor = cell.actor;
	var hero = map.hero;
	var blinded = hero.blinded > 0;

	if (actor == hero)
		return 4;

	if (actor != null) {
		if (blinded)
			return 24;

		if (actor.boss)
			return 22;

		var name = actor.name;
		var tiles = {
			'wasp': 9, 
			'spider': 14, 
			'rat': 15,
			'bat': 16, 
			'snake': 17, 
			'poisonous bat': 16, 
			'vampire bat': 16, 
			'poisonous snake': 17,
			'rabid mole': 18,
			'mutant': 19,
			'zombie': 20,
			'ghost': 21
		}
		var tile = tiles[name];
		return tile? tile: 24;
	}
	
	var objs = cell.objects;
	var n = objs.length;
	if (n) {
		if (blinded)
			return 24;

		var mask = 0;
		for(var i = 0; i < n; ++i) {
			mask |= (objs[i].type & ~PICKABLE);
		}
		if (n == 1 || (mask & (mask - 1)) == 0) {
			var o = objs[0];
			var type = o.type;
			if (o.name.indexOf("pipes") >= 0)
				return (type&FIXABLE)? 12: 13;
			if (type & DRINKABLE)
				return 11;
			if (type & EDIBLE)
				return 7;
			if (type & READABLE)
				return 8;
			
			switch(o.name) {
			case "gold":
				return 6; 
			case "key":
				return 10;
			}
		}
		return 5;
	}
	switch(cell.type) {
	case CELL_FLOOR:
		return cell.blood? 23: 0;
	case CELL_ENTRANCE:
		return 2;
	case CELL_EXIT:
		return 3;
	case CELL_WALL:
		return 1;
	default:
		return -1;
	}
}

function repaint(cell) {
	var c = $('#c' + cell.y + '_' + cell.x);
	var t = gettile(cell);
	if (t >= 0) {
		c['css']({
			'visibility': 'visible',
			'background-position' : "0 " + (t * -16) + "px"
		})['addClass']('t' + t);
	} else 
		c['css']('visibility', 'hidden');
}

function repaint_all() {
	var str = '<i id="th"/>', t;
	var w = map.width, h = map.height;
	for(var y = 0; y < h; ++y) {
		for(var x = 0; x < w; ++x) {
			if (x == 0)
				t = 'u'
			else
				t = 'i';
			str += "<" + t + " id='c" + y + "_" + x + "'/>";
		}
	}
	//alert(str);
	var view = $('#map')
	view['html'](str);
	map.foreach(function(cell) {
			repaint(cell);
			var c = $('#c' + cell.y + '_' + cell.x);
			c['click'](function() {
				var hero = map.hero;
				var hero_cell = hero.cell;
				var dx = sgn(cell.x - hero_cell.x), dy = sgn(cell.y - hero_cell.y);
				hero.smart_move(dx, dy);
				map.tick();
				panel();
			});
		}
	);

	panel();
}

function animate_throw(x, y, obj, actor, message) {
	var c = map.hero.cell, dx = x - c.x, dy = y - c.y;
	distance = Math.max(Math.abs(dx), Math.abs(dy));
	$('#th')['css']({
		'left' : (c.x + sgn(dx)) * 16,
		'top' : (c.y + sgn(dy)) * 16
	})
	['show']()
	['animate']({
		'left' : x * 16,
		'top' : y * 16
	}, 20 * distance, function() {
		$(this)['hide']();
		log(message);
		if (obj) {
			obj.type |= PICKABLE;
			map.insert_object(obj, x, y);
		}
		if (actor) {
			map.hero.attack(actor, true);
		}
		map.tick();
	});
}

function win(hero) {
	var str = '<p id="mr">PURE WIN!!!<br>Got $' + hero.cash + '<br>Being dead ' + hero.dead + ' times. <br><br><b>Programmed by:</b><br>Vladimir Menshakov<br>&amp;<br>Vladimir Zhuravlev<br>&copy;2010</p>';
	$('#mg')['html'](str)['show']();
}

window['S'] = function() {
	if (map == null)
		$('body')['append']("<div id='p'><h1>" + document.title + "</h1><div id='c'><p id='map'/><button id='s'/><p id='l'/></div><div id='panel'/></div><div id='mg'/>");

	$('#s')['click'](function(){
		this.innerHTML = 'Turn shadows ' + ($('body')['toggleClass']('on')['hasClass']('on') ? 'off' : 'on');
	})['click']();
	if ($['browser']['msie']) {
		$('body')['addClass']('ie');
		$('#s')['click']();
	}

	var w = 40, h = 24; 
	map = new dungeon_map(w, h);
	
	$('#c')['css']('width', (w * 16 + 16));
	
	map.repaint = repaint;
	map.repaint_all = repaint_all;
	map.win = win;

	intro();
	map.generate();
	panel();
	//win(10000);
}

// viewport size
WINDOW_WIDTH = 12
WINDOW_HEIGHT = 12

// map dimensions
MAP_WIDTH = 80;
MAP_HEIGHT = 30;
TILE_SIZE = 32;

function create_html () {
	$('body')['append']($('<div id="wrapper"><div id="map"><div id="floor"></div><div id="walls"></div></div><div id="hero"></div></div><div id="panel"></div><div id="log"></div>'));

	var mw = MAP_WIDTH*TILE_SIZE,
		mh = MAP_HEIGHT*TILE_SIZE,
		ww = WINDOW_WIDTH*TILE_SIZE,
		wh = WINDOW_HEIGHT*TILE_SIZE;

	$('#wrapper')['css']({
		width: ww*2, 
		height: wh
	});
	$('#map')['css']({
		width: mw*2, 
		height: mh,
		'margin-left': ww,
		'margin-top': Math.floor(WINDOW_HEIGHT/2)*TILE_SIZE
	});
	$('#floor')['css']({
		width: mw, 
		height: mh
	});
}

function get_neighbors (x, y) {
	var v = { type: CELL_VOID },
		c = map.cells;
	return {
		self: (c[y] && c[y][x] || v).type, 
		left: 	(c[y] && c[y][x-1] || v).type,
		right: 	(c[y] && c[y][x+1] || v).type,
		top: 	(c[y-1] && c[y-1][x] || v).type,
		bottom: (c[y+1] && c[y+1][x] || v).type
	}
}

function draw_tile (classname, left, top, z) {
	return '<b class="' + classname + '" style="left:' + left + 'px;top:' + top + 'px;' + (z? ('z-index:'+z) : '') + '"></b>'
}

function draw_object (x, y, z) {
	var cell = map.cells[y][x],
		s = '',
		left = (x-y)*TILE_SIZE,
		top = (x+y)*TILE_SIZE/2,
		o = a = '<b style="left:' + left + 'px;' +
						'top:' + top + 'px;' + 
						'z-index' + z + '" class="';

	if (cell.objects.length) {

		// draw object
		s += o + (cell.objects.length > 1 + !!cell.actor ? 'pile' : cell.objects[0].name) + '"></b>'
	}
	// draw actor (if any)
	if (cell.actor && (cell.actor != map.hero)) {
		s += a + cell.actor.name + '"></b>'
	}
	
	return s;
}

function draw_level() {
	var // predictable_rand initial value
		Xn = map.level,
		m = Math.pow(2, 32),
		a =	69069,
		c = 5;
		
		// wall decoration classes
		DECORATION = ['paint', 'switch', 'plug', 'display', 'calendar', 'ibelieve'],
		D_FREQ = 0.05;

	var p_rand = function() {
		Xn = (a*Xn + c) % m;
		return Xn/m;
	}
	
	for(var y=0, floor='', walls=''; y<MAP_HEIGHT; y++) {
		for(var x=0; x<MAP_WIDTH; x++) {
			var obj='<b id="o'+x+'_'+y+'">',
				left = (x-y)*TILE_SIZE,
				top = (x+y)*TILE_SIZE/2,
				z = (x + y)*10,
				cells = get_neighbors(x, y),
				deco = (p_rand() < D_FREQ ? (' d ' + DECORATION[Math.floor(p_rand()*DECORATION.length)]) : '' );
			// draw map elements
			switch (cells.self) {
				case CELL_VOID: 
						floor += draw_tile('u', x*TILE_SIZE, y*TILE_SIZE);
						break;
				case CELL_WALL: 
						floor += draw_tile('u', x*TILE_SIZE, y*TILE_SIZE);
						if ((y<=0) || (cells.top != CELL_WALL)) {
							walls += draw_tile('w l a', left, top, z+1);
						}
						if ((y>=MAP_WIDTH-1) || (cells.bottom != CELL_WALL)) {
							walls += draw_tile('w l' + deco, left, top, z+8);
						} 
						if ((x<=0) || (cells.left != CELL_WALL)) {
							walls += draw_tile('w r a', left, top, z+2);
						}
						if ((x>=MAP_WIDTH-1) || (cells.right != CELL_WALL)) {
							walls += draw_tile('w r', left, top, z+9);
						} 
						break;
				case CELL_ENTRANCE:
				case CELL_EXIT:
						walls += draw_tile((cells.self == CELL_EXIT ? 'exit' : 'enter'), left, top, z+3);
						break;
			}
			// draw object containers
			var s = draw_object(x, y, z+4)
			if (s) {
				// create container for this field
				walls += obj + s + '</b>'
			}
		}
	}
	$('#floor')['html'](floor);
	$('#walls')['html'](walls);
	$('#hero')['css']('z-index', (map.hero.cell.x + map.hero.cell.y)*10+6);
}

function move_camera(x, y) {
	var m = document.getElementById('map');
	m.style.left = (y-x)*TILE_SIZE + 'px';
	m.style.top = -(y+x)*TILE_SIZE/2 + 'px';
}

function repaint (cell) {
	var x = cell.x, y = cell.y;
	objs = $('#o'+x+'_'+y);
	if (cell.actor == map.hero) {
		$('#hero')['css']('z-index', (x+y)*10+6);
		move_camera(x, y);
	}
	if (!objs.length) {
		objs = $('<b id="o'+x+'_'+y+'"></b>');
		$('#walls')['append'](objs);
	}
	objs['empty']()['html'](draw_object(x, y, (x+y)*10+4))
}

function repaint_all() {
	draw_level();
	move_camera(map.hero.cell.x, map.hero.cell.y);
}

function S() {
	create_html();

	map = new dungeon_map(MAP_WIDTH, MAP_HEIGHT);

	map.repaint = repaint;
	map.repaint_all = repaint_all;
	
	map.generate();

	panel();
	intro();
}

window['S'] = S;
if ((navigator.userAgent.indexOf('Windows') == -1) && (navigator.userAgent.indexOf('Macintosh') == -1)) 
	document.documentElement.id = "linux";


import os.path
import sublime
import sublime_plugin

hacker_enabled = False


class HackerTyperCommand(sublime_plugin.TextCommand):

    def run(self, edit, enable=False, content=False):
        global hacker_enabled
        hacker_enabled = enable

        if content is False:
            return

        # Replace contents
        self.view.replace(edit, sublime.Region(0, len(content)), content)


class HackerTyper(sublime_plugin.EventListener):
    solution_exists = False
    hacker_buffer = ""

    def on_activated(self, view):
        # Don't check for solution files if the plugin is disabled
        if hacker_enabled is False:
            return

        # Check if the current file has a solution
        filename = view.file_name()
        if filename is None:
            return

        solution = filename + ".hackertyper"
        self.solution_exists = os.path.isfile(solution)

        # Give a feedback message if no solution was found
        # Clear the status bar if one was found
        if not self.solution_exists:
            err = "HackerTyper Error: " + os.path.basename(filename)
            err += ".hackertyper not found"
            return sublime.status_message(err)
        else:
            sublime.status_message("")

        # Read the entire solution text
        self.hacker_buffer = open(solution, encoding='utf-8').read()

    def on_modified_async(self, view):
        global hacker_enabled

        if hacker_enabled is False or self.solution_exists is False:
            return

        # Fetch correct part of the buffer
        bufSize = view.size()

        # Fall back if we're outrunning the original solution
        if bufSize > len(self.hacker_buffer):
            return

        newBuf = self.hacker_buffer[:bufSize]

        view.run_command("hacker_typer", {"enable": True, "content": newBuf})

<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>HTML5 Hacker</title>
        <style>
            body {
                width: 99%;
                height: 100%;
                background-color: black;
                overflow-wrap: break-word;
                overflow: hidden;
            }
            .terminal {
                color: lightgreen;
                width: 100%;
                height: 90vh;
                text-shadow: 0px 0px 3px white;
                font-family: monospace;
                font-size: 1.3em;
                overflow-y: scroll;
                padding-right: 1em;

                animation-duration: 0.5s;
                animation-name: colorthing;
                animation-iteration-count: infinite;
                animation-direction: alternate;
            }

            @keyframes colorthing {
                from {
                    color: rgb(0, 255, 0);
                }

                to {
                    color: rgb(0, 200, 0);
                }
            }
        </style>
    </head>
    <body>"
        <div class="terminal" id="terminal">
        </div>
        <script>
            var code = `#include <linux/delay.h>
#include <linux/init.h>
#include <linux/irqdomain.h>
#include <linux/pci.h>
#include <linux/msi.h>
#include <linux/pci_hotplug.h>
#include <linux/module.h>
#include <linux/pci-aspm.h>
#include <linux/pci-acpi.h>
#include <linux/pm_runtime.h>
#include <linux/pm_qos.h>
#include "pci.h"

/*
 * The UUID is defined in the PCI Firmware Specification available here:
 * https://www.pcisig.com/members/downloads/pcifw_r3_1_13Dec10.pdf
 */
const u8 pci_acpi_dsm_uuid[] = {
	0xd0, 0x37, 0xc9, 0xe5, 0x53, 0x35, 0x7a, 0x4d,
	0x91, 0x17, 0xea, 0x4d, 0x19, 0xc3, 0x43, 0x4d
};

phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
{
	acpi_status status = AE_NOT_EXIST;
	unsigned long long mcfg_addr;

	if (handle)
		status = acpi_evaluate_integer(handle, METHOD_NAME__CBA,
					       NULL, &mcfg_addr);
	if (ACPI_FAILURE(status))
		return 0;

	return (phys_addr_t)mcfg_addr;
}

static acpi_status decode_type0_hpx_record(union acpi_object *record,
					   struct hotplug_params *hpx)
{
	int i;
	union acpi_object *fields = record->package.elements;
	u32 revision = fields[1].integer.value;

	switch (revision) {
	case 1:
		if (record->package.count != 6)
			return AE_ERROR;
		for (i = 2; i < 6; i++)
			if (fields[i].type != ACPI_TYPE_INTEGER)
				return AE_ERROR;
		hpx->t0 = &hpx->type0_data;
		hpx->t0->revision        = revision;
		hpx->t0->cache_line_size = fields[2].integer.value;
		hpx->t0->latency_timer   = fields[3].integer.value;
		hpx->t0->enable_serr     = fields[4].integer.value;
		hpx->t0->enable_perr     = fields[5].integer.value;
		break;
	default:
		printk(KERN_WARNING
		       "%s: Type 0 Revision %d record not supported\n",
		       __func__, revision);
		return AE_ERROR;
	}
	return AE_OK;
}

static acpi_status decode_type1_hpx_record(union acpi_object *record,
					   struct hotplug_params *hpx)
{
	int i;
	union acpi_object *fields = record->package.elements;
	u32 revision = fields[1].integer.value;

	switch (revision) {
	case 1:
		if (record->package.count != 5)
			return AE_ERROR;
		for (i = 2; i < 5; i++)
			if (fields[i].type != ACPI_TYPE_INTEGER)
				return AE_ERROR;
		hpx->t1 = &hpx->type1_data;
		hpx->t1->revision      = revision;
		hpx->t1->max_mem_read  = fields[2].integer.value;
		hpx->t1->avg_max_split = fields[3].integer.value;
		hpx->t1->tot_max_split = fields[4].integer.value;
		break;
	default:
		printk(KERN_WARNING
		       "%s: Type 1 Revision %d record not supported\n",
		       __func__, revision);
		return AE_ERROR;
	}
	return AE_OK;
}

static acpi_status decode_type2_hpx_record(union acpi_object *record,
					   struct hotplug_params *hpx)
{
	int i;
	union acpi_object *fields = record->package.elements;
	u32 revision = fields[1].integer.value;

	switch (revision) {
	case 1:
		if (record->package.count != 18)
			return AE_ERROR;
		for (i = 2; i < 18; i++)`;
        </script>
        <script>
            var i = 0;
            document.addEventListener("keydown", function (){
                terminal.innerText += code.slice(i, i+5);
                i += 5;
                if (i > code.length) {i=0;}
            });

            setInterval(function (){
                var term = document.getElementById("terminal");
                term.scrollTop = term.scrollHeight;
            }, 100);
        </script>
    </body>
</html>


#include <bits/types/struct_timeval.h>
#include <stdlib.h>
#include <sys/select.h>
#include <termios.h>
#include <unistd.h>
#include <cstdio>
#include <iostream>
#include <cstdlib>
#include <string.h>

std::string str = " std::string str[5] = { \"linux\", \"system\", \"git\", \"advanced\", \"command\" };\n\nint main() {\n\nstruct termios oldSettings, newSettings;\n\nint i = 0;\nstd::string text = "";\n\ntcgetattr(fileno( stdin), &oldSettings);\n";

int main() {

	struct termios oldSettings, newSettings;

	int i = 0;
	std::string text = "";

	tcgetattr(fileno( stdin), &oldSettings);
	newSettings = oldSettings;
	newSettings.c_lflag &= (~ICANON & ~ECHO);
	tcsetattr(fileno( stdin), TCSANOW, &newSettings);

	fd_set set;
	struct timeval tv;

	tv.tv_sec = 10;
	tv.tv_usec = 0;

	FD_ZERO(&set);
	FD_SET(fileno( stdin ), &set);

	int res = select(fileno( stdin) + 1, &set, NULL, NULL, &tv);

	while (res > 0) {
		char c;
		system("clear");
		text += str[i];
		std::cout << text << std::endl;
		i++;
		if(i >= str.length())
			i = 0;
		read(fileno(stdin), &c, 1);
	}

	tcsetattr(fileno( stdin), TCSANOW, &oldSettings);
	return 0;
}

/*
** Id: //Department/DaVinci/BRANCHES/MT6620_WIFI_DRIVER_V2_3/include/mgmt/rlm_domain.h#1
*/

/*! \file   "rlm_domain.h"
    \brief
*/

/*
** Log: rlm_domain.h
 *
 * 09 29 2011 cm.chang
 * NULL
 * Change the function prototype of rlmDomainGetChnlList()
 *
 * 09 08 2011 cm.chang
 * [WCXRP00000969] [MT6620 Wi-Fi][Driver][FW] Channel list for 5G band based on country code
 * Use new fields ucChannelListMap and ucChannelListIndex in NVRAM
 *
 * 08 31 2011 cm.chang
 * [WCXRP00000969] [MT6620 Wi-Fi][Driver][FW] Channel list for 5G band based on country code
 * .
 *
 * 06 01 2011 cm.chang
 * [WCXRP00000756] [MT6620 Wi-Fi][Driver] 1. AIS follow channel of BOW 2. Provide legal channel function
 * Provide legal channel function based on domain
 *
 * 12 07 2010 cm.chang
 * [WCXRP00000238] MT6620 Wi-Fi][Driver][FW] Support regulation domain setting from NVRAM and supplicant
 * 1. Country code is from NVRAM or supplicant
 * 2. Change band definition in CMD/EVENT.
 *
 * 07 08 2010 cp.wu
 *
 * [WPD00003833] [MT6620 and MT5931] Driver migration - move to new repository.
 *
 * 06 28 2010 cm.chang
 * [WPD00003841][LITE Driver] Migrate RLM/CNM to host driver
 * 1st draft code for RLM module
 *
 * 02 23 2010 kevin.huang
 * [BORA00000603][WIFISYS] [New Feature] AAA Module Support
 * Add support scan channel 1~14 and update scan result's frequency infou1rwduu`wvpghlqg|n`slk+mpdkb
 *
 * 01 13 2010 cm.chang
 * [BORA00000018]Integrate WIFI part into BORA for the 1st time
 * Provide query function about full channel list.
 *
 * Dec 1 2009 mtk01104
 * [BORA00000018] Integrate WIFI part into BORA for the 1st time
 * Declare public rDomainInfo
 *
**
*/

#ifndef _RLM_DOMAIN_H
#define _RLM_DOMAIN_H

/*******************************************************************************
*                         C O M P I L E R   F L A G S
********************************************************************************
*/

/*******************************************************************************
*                    E X T E R N A L   R E F E R E N C E S
********************************************************************************
*/

/*******************************************************************************
*                              C O N S T A N T S
********************************************************************************
*/
#define MAX_SUBBAND_NUM     6
#define MAX_SUBBAND_NUM_5G  8

#define COUNTRY_CODE_NULL               ((UINT_16)0x0)

/* ISO/IEC 3166-1 two-character country codes */

#define COUNTRY_CODE_AD (((UINT_16) 'A' << 8) | (UINT_16) 'D')	/* Andorra                             */
#define COUNTRY_CODE_AE (((UINT_16) 'A' << 8) | (UINT_16) 'E')	/* UAE                                 */
#define COUNTRY_CODE_AF (((UINT_16) 'A' << 8) | (UINT_16) 'F')	/* Afghanistan                         */
#define COUNTRY_CODE_AG (((UINT_16) 'A' << 8) | (UINT_16) 'G')	/* Antigua & Barbuda                   */
#define COUNTRY_CODE_AI (((UINT_16) 'A' << 8) | (UINT_16) 'I')	/* Anguilla                            */
#define COUNTRY_CODE_AL (((UINT_16) 'A' << 8) | (UINT_16) 'L')	/* Albania                             */
#define COUNTRY_CODE_AM (((UINT_16) 'A' << 8) | (UINT_16) 'M')	/* Armenia                             */
#define COUNTRY_CODE_AN (((UINT_16) 'A' << 8) | (UINT_16) 'N')	/* Netherlands Antilles                */
#define COUNTRY_CODE_AO (((UINT_16) 'A' << 8) | (UINT_16) 'O')	/* Angola                              */
#define COUNTRY_CODE_AR (((UINT_16) 'A' << 8) | (UINT_16) 'R')	/* Argentina                           */
#define COUNTRY_CODE_AS (((UINT_16) 'A' << 8) | (UINT_16) 'S')	/* American Samoa (USA)                */
#define COUNTRY_CODE_AT (((UINT_16) 'A' << 8) | (UINT_16) 'T')	/* Austria                             */
#define COUNTRY_CODE_AU (((UINT_16) 'A' << 8) | (UINT_16) 'U')	/* Australia                           */
#define COUNTRY_CODE_AW (((UINT_16) 'A' << 8) | (UINT_16) 'W')	/* Aruba                               */
#define COUNTRY_CODE_AZ (((UINT_16) 'A' << 8) | (UINT_16) 'Z')	/* Azerbaijan                          */
#define COUNTRY_CODE_BA (((UINT_16) 'B' << 8) | (UINT_16) 'A')	/* Bosnia and Herzegovina              */
#define COUNTRY_CODE_BB (((UINT_16) 'B' << 8) | (UINT_16) 'B')	/* Barbados                            */
#define COUNTRY_CODE_BD (((UINT_16) 'B' << 8) | (UINT_16) 'D')	/* Bangladesh                          */
#define COUNTRY_CODE_BE (((UINT_16) 'B' << 8) | (UINT_16) 'E')	/* Belgium                             */
#define COUNTRY_CODE_BF (((UINT_16) 'B' << 8) | (UINT_16) 'F')	/* Burkina Faso                        */
#define COUNTRY_CODE_BG (((UINT_16) 'B' << 8) | (UINT_16) 'G')	/* Bulgaria                            */
#define COUNTRY_CODE_BH (((UINT_16) 'B' << 8) | (UINT_16) 'H')	/* Bahrain                             */
#define COUNTRY_CODE_BI (((UINT_16) 'B' << 8) | (UINT_16) 'I')	/* Burundi                             */
#define COUNTRY_CODE_BJ (((UINT_16) 'B' << 8) | (UINT_16) 'J')	/* Benin                               */
#define COUNTRY_CODE_BM (((UINT_16) 'B' << 8) | (UINT_16) 'M')	/* Bermuda                             */
#define COUNTRY_CODE_BN (((UINT_16) 'B' << 8) | (UINT_16) 'N')	/* Brunei                              */
#define COUNTRY_CODE_BO (((UINT_16) 'B' << 8) | (UINT_16) 'O')	/* Bolivia                             */
#define COUNTRY_CODE_BR (((UINT_16) 'B' << 8) | (UINT_16) 'R')	/* Brazil                              */
#define COUNTRY_CODE_BS (((UINT_16) 'B' << 8) | (UINT_16) 'S')	/* Bahamas                             */
#define COUNTRY_CODE_BT (((UINT_16) 'B' << 8) | (UINT_16) 'T')	/* Bhutan                              */
#define COUNTRY_CODE_BW (((UINT_16) 'B' << 8) | (UINT_16) 'W')	/* Botswana                            */
#define COUNTRY_CODE_BY (((UINT_16) 'B' << 8) | (UINT_16) 'Y')	/* Belarus                             */
#define COUNTRY_CODE_BZ (((UINT_16) 'B' << 8) | (UINT_16) 'Z')	/* Belize                              */
#define COUNTRY_CODE_CA (((UINT_16) 'C' << 8) | (UINT_16) 'A')	/* Canada                              */
#define COUNTRY_CODE_CD (((UINT_16) 'C' << 8) | (UINT_16) 'D')	/* Congo. Democratic Republic of the   */
#define COUNTRY_CODE_CF (((UINT_16) 'C' << 8) | (UINT_16) 'F')	/* Central African Republic            */
#define COUNTRY_CODE_CG (((UINT_16) 'C' << 8) | (UINT_16) 'G')	/* Congo. Republic of the              */
#define COUNTRY_CODE_CH (((UINT_16) 'C' << 8) | (UINT_16) 'H')	/* Switzerland                         */
#define COUNTRY_CODE_CI (((UINT_16) 'C' << 8) | (UINT_16) 'I')	/* Cote d'lvoire                       */
#define COUNTRY_CODE_CK (((UINT_16) 'C' << 8) | (UINT_16) 'K')	/* Cook Island                         */
#define COUNTRY_CODE_CL (((UINT_16) 'C' << 8) | (UINT_16) 'L')	/* Chile                               */
#define COUNTRY_CODE_CM (((UINT_16) 'C' << 8) | (UINT_16) 'M')	/* Cameroon                            */
#define COUNTRY_CODE_CN (((UINT_16) 'C' << 8) | (UINT_16) 'N')	/* China                               */
#define COUNTRY_CODE_CO (((UINT_16) 'C' << 8) | (UINT_16) 'O')	/* Columbia                            */
#define COUNTRY_CODE_CR (((UINT_16) 'C' << 8) | (UINT_16) 'R')	/* Costa Rica                          */
#define COUNTRY_CODE_CU (((UINT_16) 'C' << 8) | (UINT_16) 'U')	/* Cuba                                */
#define COUNTRY_CODE_CV (((UINT_16) 'C' << 8) | (UINT_16) 'V')	/* Cape Verde                          */
#define COUNTRY_CODE_CX (((UINT_16) 'C' << 8) | (UINT_16) 'X')	/* "Christmas Island(Australia)        */
#define COUNTRY_CODE_CY (((UINT_16) 'C' << 8) | (UINT_16) 'Y')	/* Cyprus                              */
#define COUNTRY_CODE_CZ (((UINT_16) 'C' << 8) | (UINT_16) 'Z')	/* Czech                               */
#define COUNTRY_CODE_DE (((UINT_16) 'D' << 8) | (UINT_16) 'E')	/* Germany                             */
#define COUNTRY_CODE_DJ (((UINT_16) 'D' << 8) | (UINT_16) 'J')	/* Djibouti                            */
#define COUNTRY_CODE_DK (((UINT_16) 'D' << 8) | (UINT_16) 'K')	/* Denmark                             */
#define COUNTRY_CODE_DM (((UINT_16) 'D' << 8) | (UINT_16) 'M')	/* Dominica                            */
#define COUNTRY_CODE_DO (((UINT_16) 'D' << 8) | (UINT_16) 'O')	/* Dominican Republic                  */
#define COUNTRY_CODE_DZ (((UINT_16) 'D' << 8) | (UINT_16) 'Z')	/* Algeria                             */
#define COUNTRY_CODE_EC (((UINT_16) 'E' << 8) | (UINT_16) 'C')	/* Ecuador                             */
#define COUNTRY_CODE_EE (((UINT_16) 'E' << 8) | (UINT_16) 'E')	/* Estonia                             */
#define COUNTRY_CODE_EG (((UINT_16) 'E' << 8) | (UINT_16) 'G')	/* Egypt                               */
#define COUNTRY_CODE_EH (((UINT_16) 'E' << 8) | (UINT_16) 'H')	/* Western Sahara (Morocco)            */
#define COUNTRY_CODE_ER (((UINT_16) 'E' << 8) | (UINT_16) 'R')	/* Eritrea                             */
#define COUNTRY_CODE_ES (((UINT_16) 'E' << 8) | (UINT_16) 'S')	/* Spain                               */
#define COUNTRY_CODE_ET (((UINT_16) 'E' << 8) | (UINT_16) 'T')	/* Ethiopia                            */
#define COUNTRY_CODE_EU (((UINT_16) 'E' << 8) | (UINT_16) 'U')	/* Europe                              */
#define COUNTRY_CODE_FI (((UINT_16) 'F' << 8) | (UINT_16) 'I')	/* Finland                             */
#define COUNTRY_CODE_FJ (((UINT_16) 'F' << 8) | (UINT_16) 'J')	/* Fiji                                */
#define COUNTRY_CODE_FK (((UINT_16) 'F' << 8) | (UINT_16) 'K')	/* Falkland Island                     */
#define COUNTRY_CODE_FM (((UINT_16) 'F' << 8) | (UINT_16) 'M')	/* Micronesia                          */
#define COUNTRY_CODE_FO (((UINT_16) 'F' << 8) | (UINT_16) 'O')	/* Faroe Island                        */
#define COUNTRY_CODE_FR (((UINT_16) 'F' << 8) | (UINT_16) 'R')	/* France                              */
#define COUNTRY_CODE_FR (((UINT_16) 'F' << 8) | (UINT_16) 'R')	/* Wallis and Futuna (France)          */
#define COUNTRY_CODE_GA (((UINT_16) 'G' << 8) | (UINT_16) 'A')	/* Gabon                               */
#define COUNTRY_CODE_GB (((UINT_16) 'G' << 8) | (UINT_16) 'B')	/* United Kingdom                      */
#define COUNTRY_CODE_GD (((UINT_16) 'G' << 8) | (UINT_16) 'D')	/* Grenada                             */
#define COUNTRY_CODE_GE (((UINT_16) 'G' << 8) | (UINT_16) 'E')	/* Georgia                             */
#define COUNTRY_CODE_GF (((UINT_16) 'G' << 8) | (UINT_16) 'F')	/* French Guiana                       */
#define COUNTRY_CODE_GG (((UINT_16) 'G' << 8) | (UINT_16) 'G')	/* Guernsey                            */
#define COUNTRY_CODE_GH (((UINT_16) 'G' << 8) | (UINT_16) 'H')	/* Ghana                               */
#define COUNTRY_CODE_GI (((UINT_16) 'G' << 8) | (UINT_16) 'I')	/* Gibraltar                           */
#define COUNTRY_CODE_GM (((UINT_16) 'G' << 8) | (UINT_16) 'M')	/* Gambia                              */
#define COUNTRY_CODE_GN (((UINT_16) 'G' << 8) | (UINT_16) 'N')	/* Guinea                              */
#define COUNTRY_CODE_GP (((UINT_16) 'G' << 8) | (UINT_16) 'P')	/* Guadeloupe                          */
#define COUNTRY_CODE_GQ (((UINT_16) 'G' << 8) | (UINT_16) 'Q')	/* Equatorial Guinea                   */
#define COUNTRY_CODE_GR (((UINT_16) 'G' << 8) | (UINT_16) 'R')	/* Greece                              */
#define COUNTRY_CODE_GT (((UINT_16) 'G' << 8) | (UINT_16) 'T')	/* Guatemala                           */
#define COUNTRY_CODE_GU (((UINT_16) 'G' << 8) | (UINT_16) 'U')	/* Guam                                */
#define COUNTRY_CODE_GW (((UINT_16) 'G' << 8) | (UINT_16) 'W')	/* Guinea-Bissau                       */
#define COUNTRY_CODE_GY (((UINT_16) 'G' << 8) | (UINT_16) 'Y')	/* Guyana                              */
#define COUNTRY_CODE_HK (((UINT_16) 'H' << 8) | (UINT_16) 'K')	/* Hong Kong                           */
#define COUNTRY_CODE_HN (((UINT_16) 'H' << 8) | (UINT_16) 'N')	/* Honduras                            */
#define COUNTRY_CODE_HR (((UINT_16) 'H' << 8) | (UINT_16) 'R')	/* Croatia                             */
#define COUNTRY_CODE_HT (((UINT_16) 'H' << 8) | (UINT_16) 'T')	/* Haiti                               */
#define COUNTRY_CODE_HU (((UINT_16) 'H' << 8) | (UINT_16) 'U')	/* Hungary                             */
#define COUNTRY_CODE_ID (((UINT_16) 'I' << 8) | (UINT_16) 'D')	/* Indonesia                           */
#define COUNTRY_CODE_IE (((UINT_16) 'I' << 8) | (UINT_16) 'E')	/* Ireland                             */
#define COUNTRY_CODE_IL (((UINT_16) 'I' << 8) | (UINT_16) 'L')	/* Israel                              */
#define COUNTRY_CODE_IM (((UINT_16) 'I' << 8) | (UINT_16) 'M')	/* Isle of Man                         */
#define COUNTRY_CODE_IN (((UINT_16) 'I' << 8) | (UINT_16) 'N')	/* India                               */
#define COUNTRY_CODE_IQ (((UINT_16) 'I' << 8) | (UINT_16) 'Q')	/* Iraq                                */
#define COUNTRY_CODE_IR (((UINT_16) 'I' << 8) | (UINT_16) 'R')	/* Iran                                */
#define COUNTRY_CODE_IS (((UINT_16) 'I' << 8) | (UINT_16) 'S')	/* Iceland                             */
#define COUNTRY_CODE_IT (((UINT_16) 'I' << 8) | (UINT_16) 'T')	/* Italy                               */
#define COUNTRY_CODE_JE (((UINT_16) 'J' << 8) | (UINT_16) 'E')	/* Jersey                              */
#define COUNTRY_CODE_JM (((UINT_16) 'J' << 8) | (UINT_16) 'M')	/* Jameica                             */
#define COUNTRY_CODE_JO (((UINT_16) 'J' << 8) | (UINT_16) 'O')	/* Jordan                              */
#define COUNTRY_CODE_JP (((UINT_16) 'J' << 8) | (UINT_16) 'P')	/* Japan                               */
#define COUNTRY_CODE_KE (((UINT_16) 'K' << 8) | (UINT_16) 'E')	/* Kenya                               */
#define COUNTRY_CODE_KG (((UINT_16) 'K' << 8) | (UINT_16) 'G')	/* Kyrgyzstan                          */
#define COUNTRY_CODE_KH (((UINT_16) 'K' << 8) | (UINT_16) 'H')	/* Cambodia                            */
#define COUNTRY_CODE_KI (((UINT_16) 'K' << 8) | (UINT_16) 'I')	/* Kiribati                            */
#define COUNTRY_CODE_KM (((UINT_16) 'K' << 8) | (UINT_16) 'M')	/* Comoros                             */
#define COUNTRY_CODE_KN (((UINT_16) 'K' << 8) | (UINT_16) 'N')	/* Saint Kitts and Nevis               */
#define COUNTRY_CODE_KP (((UINT_16) 'K' << 8) | (UINT_16) 'P')	/* North Korea                         */
#define COUNTRY_CODE_KR (((UINT_16) 'K' << 8) | (UINT_16) 'R')	/* South Korea                         */
#define COUNTRY_CODE_KW (((UINT_16) 'K' << 8) | (UINT_16) 'W')	/* Kuwait                              */
#define COUNTRY_CODE_KY (((UINT_16) 'K' << 8) | (UINT_16) 'Y')	/* Cayman Islands                      */
#define COUNTRY_CODE_KZ (((UINT_16) 'K' << 8) | (UINT_16) 'Z')	/* Kazakhstan                          */
#define COUNTRY_CODE_LA (((UINT_16) 'L' << 8) | (UINT_16) 'A')	/* Laos                                */
#define COUNTRY_CODE_LB (((UINT_16) 'L' << 8) | (UINT_16) 'B')	/* Lebanon                             */
#define COUNTRY_CODE_LC (((UINT_16) 'L' << 8) | (UINT_16) 'C')	/* Saint Lucia                         */
#define COUNTRY_CODE_LI (((UINT_16) 'L' << 8) | (UINT_16) 'I')	/* Liechtenstein                       */
#define COUNTRY_CODE_LK (((UINT_16) 'L' << 8) | (UINT_16) 'K')	/* Sri Lanka                           */
#define COUNTRY_CODE_LR (((UINT_16) 'L' << 8) | (UINT_16) 'R')	/* Liberia                             */
#define COUNTRY_CODE_LS (((UINT_16) 'L' << 8) | (UINT_16) 'S')	/* Lesotho                             */
#define COUNTRY_CODE_LT (((UINT_16) 'L' << 8) | (UINT_16) 'T')	/* Lithuania                           */
#define COUNTRY_CODE_LU (((UINT_16) 'L' << 8) | (UINT_16) 'U')	/* Luxemburg                           */
#define COUNTRY_CODE_LV (((UINT_16) 'L' << 8) | (UINT_16) 'V')	/* Latvia                              */
#define COUNTRY_CODE_LY (((UINT_16) 'L' << 8) | (UINT_16) 'Y')	/* Libya                               */
#define COUNTRY_CODE_MA (((UINT_16) 'M' << 8) | (UINT_16) 'A')	/* Morocco                             */
#define COUNTRY_CODE_MC (((UINT_16) 'M' << 8) | (UINT_16) 'C')	/* Monaco                              */
#define COUNTRY_CODE_MD (((UINT_16) 'M' << 8) | (UINT_16) 'D')	/* Moldova                             */
#define COUNTRY_CODE_ME (((UINT_16) 'M' << 8) | (UINT_16) 'E')	/* Montenegro                          */
#define COUNTRY_CODE_MF (((UINT_16) 'M' << 8) | (UINT_16) 'F')	/* Saint Martin / Sint Marteen
								   (Added on window's list)               */
#define COUNTRY_CODE_MG (((UINT_16) 'M' << 8) | (UINT_16) 'G')	/* Madagascar                          */
#define COUNTRY_CODE_MH (((UINT_16) 'M' << 8) | (UINT_16) 'H')	/* Marshall Islands                    */
#define COUNTRY_CODE_MK (((UINT_16) 'M' << 8) | (UINT_16) 'K')	/* Macedonia                           */
#define COUNTRY_CODE_ML (((UINT_16) 'M' << 8) | (UINT_16) 'L')	/* Mali                                */
#define COUNTRY_CODE_MM (((UINT_16) 'M' << 8) | (UINT_16) 'M')	/* Myanmar                             */
#define COUNTRY_CODE_MN (((UINT_16) 'M' << 8) | (UINT_16) 'N')	/* Mongolia                            */
#define COUNTRY_CODE_MO (((UINT_16) 'M' << 8) | (UINT_16) 'O')	/* Macao                               */
#define COUNTRY_CODE_MP (((UINT_16) 'M' << 8) | (UINT_16) 'P')	/* Northern Mariana Islands (Rota Island.
								   Saipan and Tinian Island)              */
#define COUNTRY_CODE_MQ (((UINT_16) 'M' << 8) | (UINT_16) 'Q')	/* Martinique (France)                 */
#define COUNTRY_CODE_MR (((UINT_16) 'M' << 8) | (UINT_16) 'R')	/* Mauritania                          */
#define COUNTRY_CODE_MS (((UINT_16) 'M' << 8) | (UINT_16) 'S')	/* Montserrat (UK)                     */
#define COUNTRY_CODE_MT (((UINT_16) 'M' << 8) | (UINT_16) 'T')	/* Malta                               */
#define COUNTRY_CODE_MU (((UINT_16) 'M' << 8) | (UINT_16) 'U')	/* Mauritius                           */
#define COUNTRY_CODE_MV (((UINT_16) 'M' << 8) | (UINT_16) 'V')	/* Maldives                            */
#define COUNTRY_CODE_MW (((UINT_16) 'M' << 8) | (UINT_16) 'W')	/* Malawi                              */
#define COUNTRY_CODE_MX (((UINT_16) 'M' << 8) | (UINT_16) 'X')	/* Mexico                              */
#define COUNTRY_CODE_MY (((UINT_16) 'M' << 8) | (UINT_16) 'Y')	/* Malaysia                            */
#define COUNTRY_CODE_MZ (((UINT_16) 'M' << 8) | (UINT_16) 'Z')	/* Mozambique                          */
#define COUNTRY_CODE_NA (((UINT_16) 'N' << 8) | (UINT_16) 'A')	/* Namibia                             */
#define COUNTRY_CODE_NC (((UINT_16) 'N' << 8) | (UINT_16) 'C')	/* New Caledonia                       */
#define COUNTRY_CODE_NE (((UINT_16) 'N' << 8) | (UINT_16) 'E')	/* Niger                               */
#define COUNTRY_CODE_NF (((UINT_16) 'N' << 8) | (UINT_16) 'F')	/* Norfolk Island                      */
#define COUNTRY_CODE_NG (((UINT_16) 'N' << 8) | (UINT_16) 'G')	/* Nigeria                             */
#define COUNTRY_CODE_NI (((UINT_16) 'N' << 8) | (UINT_16) 'I')	/* Nicaragua                           */
#define COUNTRY_CODE_NL (((UINT_16) 'N' << 8) | (UINT_16) 'L')	/* Netherlands                         */
#define COUNTRY_CODE_NO (((UINT_16) 'N' << 8) | (UINT_16) 'O')	/* Norway                              */
#define COUNTRY_CODE_NP (((UINT_16) 'N' << 8) | (UINT_16) 'P')	/* Nepal                               */
#define COUNTRY_CODE_NR (((UINT_16) 'N' << 8) | (UINT_16) 'R')	/* Nauru                               */
#define COUNTRY_CODE_NU (((UINT_16) 'N' << 8) | (UINT_16) 'U')	/* Niue                                */
#define COUNTRY_CODE_NZ (((UINT_16) 'N' << 8) | (UINT_16) 'Z')	/* New Zealand                         */
#define COUNTRY_CODE_OM (((UINT_16) 'O' << 8) | (UINT_16) 'M')	/* Oman                                */
#define COUNTRY_CODE_PA (((UINT_16) 'P' << 8) | (UINT_16) 'A')	/* Panama                              */
#define COUNTRY_CODE_PE (((UINT_16) 'P' << 8) | (UINT_16) 'E')	/* Peru                                */
#define COUNTRY_CODE_PF (((UINT_16) 'P' << 8) | (UINT_16) 'F')	/* "French Polynesia                   */
#define COUNTRY_CODE_PG (((UINT_16) 'P' << 8) | (UINT_16) 'G')	/* Papua New Guinea                    */
#define COUNTRY_CODE_PH (((UINT_16) 'P' << 8) | (UINT_16) 'H')	/* Philippines                         */
#define COUNTRY_CODE_PK (((UINT_16) 'P' << 8) | (UINT_16) 'K')	/* Pakistan                            */
#define COUNTRY_CODE_PL (((UINT_16) 'P' << 8) | (UINT_16) 'L')	/* Poland                              */
#define COUNTRY_CODE_PM (((UINT_16) 'P' << 8) | (UINT_16) 'M')	/* Saint Pierre and Miquelon           */
#define COUNTRY_CODE_PN (((UINT_16) 'P' << 8) | (UINT_16) 'N')	/* Pitcairn Islands                    */
#define COUNTRY_CODE_PR (((UINT_16) 'P' << 8) | (UINT_16) 'R')	/* Puerto Rico (USA)                   */
#define COUNTRY_CODE_PS (((UINT_16) 'P' << 8) | (UINT_16) 'S')	/* Palestinian Authority               */
#define COUNTRY_CODE_PT (((UINT_16) 'P' << 8) | (UINT_16) 'T')	/* Portugal                            */
#define COUNTRY_CODE_PW (((UINT_16) 'P' << 8) | (UINT_16) 'W')	/* Palau                               */
#define COUNTRY_CODE_PY (((UINT_16) 'P' << 8) | (UINT_16) 'Y')	/* Paraguay                            */
#define COUNTRY_CODE_QA (((UINT_16) 'Q' << 8) | (UINT_16) 'A')	/* Qatar                               */
#define COUNTRY_CODE_RE (((UINT_16) 'R' << 8) | (UINT_16) 'E')	/* Reunion (France)                    */
#define COUNTRY_CODE_RKS (((UINT_16) 'R' << 8) | (UINT_16) 'K')	/* Kosvo (Added on window's list)      */
#define COUNTRY_CODE_RO (((UINT_16) 'R' << 8) | (UINT_16) 'O')	/* Romania                             */
#define COUNTRY_CODE_RS (((UINT_16) 'R' << 8) | (UINT_16) 'S')	/* Serbia                              */
#define COUNTRY_CODE_RU (((UINT_16) 'R' << 8) | (UINT_16) 'U')	/* Russia                              */
#define COUNTRY_CODE_RW (((UINT_16) 'R' << 8) | (UINT_16) 'W')	/* Rwanda                              */
#define COUNTRY_CODE_SA (((UINT_16) 'S' << 8) | (UINT_16) 'A')	/* Saudi Arabia                        */
#define COUNTRY_CODE_SB (((UINT_16) 'S' << 8) | (UINT_16) 'B')	/* Solomon Islands                     */
#define COUNTRY_CODE_SC (((UINT_16) 'S' << 8) | (UINT_16) 'C')	/* Seychelles                          */
#define COUNTRY_CODE_SD (((UINT_16) 'S' << 8) | (UINT_16) 'D')	/* Sudan                               */
#define COUNTRY_CODE_SE (((UINT_16) 'S' << 8) | (UINT_16) 'E')	/* Sweden                              */
#define COUNTRY_CODE_SG (((UINT_16) 'S' << 8) | (UINT_16) 'G')	/* Singapole                           */
#define COUNTRY_CODE_SI (((UINT_16) 'S' << 8) | (UINT_16) 'I')	/* Slovenia                            */
#define COUNTRY_CODE_SK (((UINT_16) 'S' << 8) | (UINT_16) 'K')	/* Slovakia                            */
#define COUNTRY_CODE_SL (((UINT_16) 'S' << 8) | (UINT_16) 'L')	/* Sierra Leone                        */
#define COUNTRY_CODE_SM (((UINT_16) 'S' << 8) | (UINT_16) 'M')	/* San Marino                          */
#define COUNTRY_CODE_SN (((UINT_16) 'S' << 8) | (UINT_16) 'N')	/* Senegal                             */
#define COUNTRY_CODE_SO (((UINT_16) 'S' << 8) | (UINT_16) 'O')	/* Somalia                             */
#define COUNTRY_CODE_SR (((UINT_16) 'S' << 8) | (UINT_16) 'R')	/* Suriname                            */
#define COUNTRY_CODE_SS (((UINT_16) 'S' << 8) | (UINT_16) 'S')	/* South_Sudan                         */
#define COUNTRY_CODE_ST (((UINT_16) 'S' << 8) | (UINT_16) 'T')	/* Sao Tome and Principe               */
#define COUNTRY_CODE_SV (((UINT_16) 'S' << 8) | (UINT_16) 'V')	/* El Salvador                         */
#define COUNTRY_CODE_SY (((UINT_16) 'S' << 8) | (UINT_16) 'Y')	/* Syria                               */
#define COUNTRY_CODE_SZ (((UINT_16) 'S' << 8) | (UINT_16) 'Z')	/* Swaziland                           */
#define COUNTRY_CODE_TC (((UINT_16) 'T' << 8) | (UINT_16) 'C')	/* Turks and Caicos Islands (UK)       */
#define COUNTRY_CODE_TD (((UINT_16) 'T' << 8) | (UINT_16) 'D')	/* Chad                                */
#define COUNTRY_CODE_TF (((UINT_16) 'T' << 8) | (UINT_16) 'F')	/* French Southern and Antarctic Lands */
#define COUNTRY_CODE_TG (((UINT_16) 'T' << 8) | (UINT_16) 'G')	/* Togo                                */
#define COUNTRY_CODE_TH (((UINT_16) 'T' << 8) | (UINT_16) 'H')	/* Thailand                            */
#define COUNTRY_CODE_TJ (((UINT_16) 'T' << 8) | (UINT_16) 'J')	/* Tajikistan                          */
#define COUNTRY_CODE_TL (((UINT_16) 'T' << 8) | (UINT_16) 'L')	/* East Timor                          */
#define COUNTRY_CODE_TM (((UINT_16) 'T' << 8) | (UINT_16) 'M')	/* Turkmenistan                        */
#define COUNTRY_CODE_TN (((UINT_16) 'T' << 8) | (UINT_16) 'N')	/* Tunisia                             */
#define COUNTRY_CODE_TO (((UINT_16) 'T' << 8) | (UINT_16) 'O')	/* Tonga                               */
#define COUNTRY_CODE_TR (((UINT_16) 'T' << 8) | (UINT_16) 'R')	/* Turkey                              */
#define COUNTRY_CODE_TT (((UINT_16) 'T' << 8) | (UINT_16) 'T')	/* Trinidad and Tobago                 */
#define COUNTRY_CODE_TV (((UINT_16) 'T' << 8) | (UINT_16) 'V')	/* Tuvalu                              */
#define COUNTRY_CODE_TW (((UINT_16) 'T' << 8) | (UINT_16) 'W')	/* Taiwan                              */
#define COUNTRY_CODE_TZ (((UINT_16) 'T' << 8) | (UINT_16) 'Z')	/* Tanzania                            */
#define COUNTRY_CODE_UA (((UINT_16) 'U' << 8) | (UINT_16) 'A')	/* Ukraine                             */
#define COUNTRY_CODE_UG (((UINT_16) 'U' << 8) | (UINT_16) 'G')	/* Ugnada                              */
#define COUNTRY_CODE_US (((UINT_16) 'U' << 8) | (UINT_16) 'S')	/* US                                  */
#define COUNTRY_CODE_UY (((UINT_16) 'U' << 8) | (UINT_16) 'Y')	/* Uruguay                             */
#define COUNTRY_CODE_UZ (((UINT_16) 'U' << 8) | (UINT_16) 'Z')	/* Uzbekistan                          */
#define COUNTRY_CODE_VA (((UINT_16) 'V' << 8) | (UINT_16) 'A')	/* Vatican (Holy See)                  */
#define COUNTRY_CODE_VC (((UINT_16) 'V' << 8) | (UINT_16) 'C')	/* Saint Vincent and the Grenadines    */
#define COUNTRY_CODE_VE (((UINT_16) 'V' << 8) | (UINT_16) 'E')	/* Venezuela                           */
#define COUNTRY_CODE_VG (((UINT_16) 'V' << 8) | (UINT_16) 'G')	/* British Virgin Islands              */
#define COUNTRY_CODE_VI (((UINT_16) 'V' << 8) | (UINT_16) 'I')	/* US Virgin Islands                   */
#define COUNTRY_CODE_VN (((UINT_16) 'V' << 8) | (UINT_16) 'N')	/* Vietnam                             */
#define COUNTRY_CODE_VU (((UINT_16) 'V' << 8) | (UINT_16) 'U')	/* Vanuatu                             */
#define COUNTRY_CODE_WS (((UINT_16) 'W' << 8) | (UINT_16) 'S')	/* Samoa                               */
#define COUNTRY_CODE_YE (((UINT_16) 'Y' << 8) | (UINT_16) 'E')	/* Yemen                               */
#define COUNTRY_CODE_YT (((UINT_16) 'Y' << 8) | (UINT_16) 'T')	/* Mayotte (France)                    */
#define COUNTRY_CODE_ZA (((UINT_16) 'Z' << 8) | (UINT_16) 'A')	/* South Africa                        */
#define COUNTRY_CODE_ZM (((UINT_16) 'Z' << 8) | (UINT_16) 'M')	/* Zambia                              */
#define COUNTRY_CODE_ZW (((UINT_16) 'Z' << 8) | (UINT_16) 'W')	/* Zimbabwe                            */

#define COUNTRY_CODE_UDF (((UINT_16) 'U' << 8) | (UINT_16) 'D')	/* for User Defined channel list and
								   passive scan channel list              */
#define COUNTRY_CODE_FF (((UINT_16) 'F' << 8) | (UINT_16) 'F')	/* enable open for all channel for Certification */
#define COUNTRY_CODE_FE (((UINT_16) 'F' << 8) | (UINT_16) 'E')	/* disable open for all channel for Certification */

/* dot11RegDomainsSupportValue */
#define MIB_REG_DOMAIN_FCC              0x10	/* FCC (US) */
#define MIB_REG_DOMAIN_IC               0x20	/* IC or DOC (Canada) */
#define MIB_REG_DOMAIN_ETSI             0x30	/* ETSI (Europe) */
#define MIB_REG_DOMAIN_SPAIN            0x31	/* Spain */
#define MIB_REG_DOMAIN_FRANCE           0x32	/* France */
#define MIB_REG_DOMAIN_JAPAN            0x40	/* MPHPT (Japan) */
#define MIB_REG_DOMAIN_OTHER            0x00	/* other */

/*2.4G*/
#define BAND_2G4_LOWER_BOUND 1
#define BAND_2G4_UPPER_BOUND 14
/*5G SubBand FCC spec*/
#define UNII1_LOWER_BOUND    36
#define UNII1_UPPER_BOUND    48
#define UNII2A_LOWER_BOUND   52
#define UNII2A_UPPER_BOUND   64
#define UNII2C_LOWER_BOUND   100
#define UNII2C_UPPER_BOUND   144
#define UNII3_LOWER_BOUND    149
#define UNII3_UPPER_BOUND    173

#if CFG_SUPPORT_PWR_LIMIT_COUNTRY

#define POWER_LIMIT_TABLE_NULL			0xFFFF
#define MAX_TX_POWER					63
#define MIN_TX_POWER					-64
#define MAX_CMD_SUPPORT_CHANNEL_NUM	64

#endif

/*******************************************************************************
*                             D A T A   T Y P E S
********************************************************************************
*/

#if CFG_SUPPORT_PWR_LIMIT_COUNTRY

typedef enum _ENUM_POWER_LIMIT_T {
	PWR_LIMIT_CCK,
	PWR_LIMIT_20M,
	PWR_LIMIT_40M,
	PWR_LIMIT_80M,
	PWR_LIMIT_160M,
	PWR_LIMIT_NUM
} ENUM_POWER_LIMIT_T, *P_ENUM_POWER_LIMIT_T;

#endif

typedef enum _ENUM_POWER_LIMIT_SUBBAND_T {
	POWER_LIMIT_2G4,
	POWER_LIMIT_UNII1,
	POWER_LIMIT_UNII2A,
	POWER_LIMIT_UNII2C,
	POWER_LIMIT_UNII3,
	POWER_LIMIT_SUBAND_NUM
} ENUM_POWER_LIMIT_SUBBAND_T, *P_ENUM_POWER_LIMIT_SUBBAND_T;

/* Define channel offset in unit of 5MHz bandwidth */
typedef enum _ENUM_CHNL_SPAN_T {
	CHNL_SPAN_5 = 1,
	CHNL_SPAN_10 = 2,
	CHNL_SPAN_20 = 4,
	CHNL_SPAN_40 = 8
} ENUM_CHNL_SPAN_T, *P_ENUM_CHNL_SPAN_T;

/* Define BSS operating bandwidth */
typedef enum _ENUM_CHNL_BW_T {
	CHNL_BW_20,
	CHNL_BW_20_40,
	CHNL_BW_10,
	CHNL_BW_5
} ENUM_CHNL_BW_T, *P_ENUM_CHNL_BW_T;

#if 0
/* If channel width is CHNL_BW_20_40, the first channel will be SCA and
 * the second channel is SCB, then iteratively.
 * Note the final channel will not be SCA.
 */
typedef struct _DOMAIN_SUBBAND_INFO {
	UINT_8 ucRegClass;
	ENUM_BAND_T eBand;
	ENUM_CHNL_SPAN_T eChannelSpan;
	UINT_8 ucFirstChannelNum;
	UINT_8 ucNumChannels;
	ENUM_CHNL_BW_T eChannelBw;
	BOOLEAN fgDfsNeeded;
	BOOLEAN fgIbssProhibited;
} DOMAIN_SUBBAND_INFO, *P_DOMAIN_SUBBAND_INFO;

/* Use it as all available channel list for STA */
typedef struct _DOMAIN_INFO_ENTRY {
	UINT_16 u2CountryCode;
	UINT_16 u2MibRegDomainValue;

	/* If different attributes, put them into different rSubBands.
	 * For example, DFS shall be used or not.
	 */
	DOMAIN_SUBBAND_INFO rSubBand[MAX_SUBBAND_NUM];
} DOMAIN_INFO_ENTRY, *P_DOMAIN_INFO_ENTRY;

#else /* New definition 20110830 */

/* In all bands, the first channel will be SCA and the second channel is SCB,
 * then iteratively.
 * Note the final channel will not be SCA.
 */
typedef struct _DOMAIN_SUBBAND_INFO {
	/* Note1: regulation class depends on operation bandwidth and RF band.
	 *  For example: 2.4GHz, 1~13, 20MHz ==> regulation class = 81
	 *               2.4GHz, 1~13, SCA   ==> regulation class = 83
	 *               2.4GHz, 1~13, SCB   ==> regulation class = 84
	 * Note2: TX power limit is not specified here because path loss is unknown
	 */
	UINT_8 ucRegClass;	/* Regulation class for 20MHz */
	UINT_8 ucBand;		/* Type: ENUM_BAND_T */
	UINT_8 ucChannelSpan;	/* Type: ENUM_CHNL_SPAN_T */
	UINT_8 ucFirstChannelNum;
	UINT_8 ucNumChannels;
	UINT_8 ucReserved;	/* Type: BOOLEAN (fgDfsNeeded) */
} DOMAIN_SUBBAND_INFO, *P_DOMAIN_SUBBAND_INFO;

/* Use it as all available channel list for STA */
typedef struct _DOMAIN_INFO_ENTRY {
	PUINT_16 pu2CountryGroup;
	UINT_32 u4CountryNum;

	/* If different attributes, put them into different rSubBands.
	 * For example, DFS shall be used or not.
	 */
	DOMAIN_SUBBAND_INFO rSubBand[MAX_SUBBAND_NUM];
} DOMAIN_INFO_ENTRY, *P_DOMAIN_INFO_ENTRY;
#endif

/* The following definitions are not used yet */
typedef enum _ENUM_CH_SET_2G4_T {
	CH_SET_2G4_NA,
	CH_SET_2G4_1_11,
	CH_SET_2G4_1_13,
	CH_SET_2G4_1_14,
	CH_SET_2G4_NUM
} ENUM_CH_SET_2G4_T, *P_ENUM_CH_SET_2G4_T;

typedef enum _ENUM_CH_SET_UNII_LOW_T {
	CH_SET_UNII_LOW_NA,
	CH_SET_UNII_LOW_36_48,
	CH_SET_UNII_LOW_NUM
} ENUM_CH_SET_UNII_LOW_T, *P_ENUM_CH_SET_UNII_LOW_T;

typedef enum _ENUM_CH_SET_UNII_MID_T {
	CH_SET_UNII_MID_NA,
	CH_SET_UNII_MID_52_64,
	CH_SET_UNII_MID_NUM
} ENUM_CH_SET_UNII_MID_T, *P_ENUM_CH_SET_UNII_MID_T;

typedef enum _ENUM_CH_SET_UNII_WW_T {
	CH_SET_UNII_WW_NA,
	CH_SET_UNII_WW_100_128,
	CH_SET_UNII_WW_100_140,
	CH_SET_UNII_WW_100_116_132_140,
	CH_SET_UNII_WW_NUM
} ENUM_CH_SET_UNII_WW_T, *P_ENUM_CH_SET_UNII_WW_T;

typedef enum _ENUM_CH_SET_UNII_UPPER_T {
	CH_SET_UNII_UPPER_NA,
	CH_SET_UNII_UPPER_149_161,
	CH_SET_UNII_UPPER_149_165,
	CH_SET_UNII_UPPER_149_173,
	CH_SET_UNII_UPPER_NUM
} ENUM_CH_SET_UNII_UPPER_T, *P_ENUM_CH_SET_UNII_UPPER_T;

typedef struct _COUNTRY_CH_SET_T {
	ENUM_CH_SET_2G4_T e2G4;
	ENUM_CH_SET_UNII_LOW_T eUniiLow;
	ENUM_CH_SET_UNII_MID_T eUniiMid;
	ENUM_CH_SET_UNII_WW_T eUniiWw;
	ENUM_CH_SET_UNII_UPPER_T eUniiUpper;
} COUNTRY_CH_SET_T, *P_COUNTRY_CH_SET_T;

#if CFG_SUPPORT_PWR_LIMIT_COUNTRY

typedef struct _CHANNEL_POWER_LIMIT {
	UINT_8 ucCentralCh;
	INT_8 cPwrLimitCCK;
	INT_8 cPwrLimit20;
	INT_8 cPwrLimit40;
	INT_8 cPwrLimit80;
	INT_8 cPwrLimit160;
	UINT_8 ucFlag;
	UINT_8 aucReserved[1];
} CHANNEL_POWER_LIMIT, *P_CHANNEL_POWER_LIMIT;

typedef struct _COUNTRY_CHANNEL_POWER_LIMIT {
	UINT_8 aucCountryCode[2];
	UINT_8 ucCountryFlag;
	UINT_8 ucChannelNum;
	UINT_8 aucReserved[4];
	CHANNEL_POWER_LIMIT rChannelPowerLimit[80];
} COUNTRY_CHANNEL_POWER_LIMIT, *P_COUNTRY_CHANNEL_POWER_LIMIT;

#define CHANNEL_PWR_LIMIT(_channel, _pwrLimit_cck, _pwrLimit_bw20,	\
	_pwrLimit_bw40, _pwrLimit_bw80, _pwrLimit_bw160, _ucFlag)	\
	{                                                  \
	.ucCentralCh           = (_channel),               \
	.cPwrLimitCCK          = (_pwrLimit_cck),          \
	.cPwrLimit20           = (_pwrLimit_bw20),         \
	.cPwrLimit40           = (_pwrLimit_bw40),         \
	.cPwrLimit80           = (_pwrLimit_bw80),         \
	.cPwrLimit160          = (_pwrLimit_bw160),        \
	.ucFlag                = (_ucFlag),                \
	.aucReserved           = {0}                       \
}

typedef struct _COUNTRY_POWER_LIMIT_TABLE_DEFAULT {
	UINT_8 aucCountryCode[2];
	/* 0: ch 1 ~14 , 1: ch 36 ~48, 2: ch 52 ~64, 3: ch 100 ~144, 4: ch 149 ~165 */
	INT_8 aucPwrLimitSubBand[POWER_LIMIT_SUBAND_NUM];
	/* bit0: cPwrLimit2G4, bit1: cPwrLimitUnii1; bit2: cPwrLimitUnii2A;
	 * bit3: cPwrLimitUnii2C; bit4: cPwrLimitUnii3; mW: 0, mW\MHz : 1 */
	UINT_8 ucPwrUnit;
} COUNTRY_POWER_LIMIT_TABLE_DEFAULT, *P_COUNTRY_POWER_LIMIT_TABLE_DEFAULT;

typedef struct _COUNTRY_POWER_LIMIT_TABLE_CONFIGURATION {
	UINT_8 aucCountryCode[2];
	UINT_8 ucCentralCh;
	INT_8 aucPwrLimit[PWR_LIMIT_NUM];
} COUNTRY_POWER_LIMIT_TABLE_CONFIGURATION, *P_COUNTRY_POWER_LIMIT_TABLE_CONFIGURATION;

typedef struct _SUBBAND_CHANNEL_T {
	UINT_8 ucStartCh;
	UINT_8 ucEndCh;
	UINT_8 ucInterval;
	UINT_8 ucReserved;
} SUBBAND_CHANNEL_T, *P_SUBBAND_CHANNEL_T;

#endif

/*******************************************************************************
*                            P U B L I C   D A T A
********************************************************************************
*/

/*******************************************************************************
*                           P R I V A T E   D A T A
********************************************************************************
*/

/*******************************************************************************
*                                 M A C R O S
********************************************************************************
*/
#define CAL_CH_OFFSET_80M(_PRIMARY_CH, _CENTRAL_CH) \
			(((_PRIMARY_CH - _CENTRAL_CH) + 6) >> 2)

#define CAL_CH_OFFSET_160M(_PRIMARY_CH, _CENTRAL_CH) \
			(((_PRIMARY_CH - _CENTRAL_CH) + 14) >> 2)

/*******************************************************************************
*                   F U N C T I O N   D E C L A R A T I O N S
********************************************************************************
*/
UINT32 rlmDomainSupOperatingClassIeFill(UINT_8 *pBuf);
P_DOMAIN_INFO_ENTRY rlmDomainGetDomainInfo(P_ADAPTER_T prAdapter);

VOID
rlmDomainGetChnlList(P_ADAPTER_T prAdapter,
		     ENUM_BAND_T eSpecificBand,
		     UINT_8 ucMaxChannelNum, PUINT_8 pucNumOfChannel, P_RF_CHANNEL_INFO_T paucChannelList);

VOID rlmDomainSendCmd(P_ADAPTER_T prAdapter, BOOLEAN fgIsOid);

VOID rlmDomainPassiveScanSendCmd(P_ADAPTER_T prAdapter, BOOLEAN fgIsOid);

BOOLEAN rlmDomainIsLegalChannel(P_ADAPTER_T prAdapter, ENUM_BAND_T eBand, UINT_8 ucChannel);

BOOLEAN rlmDomainCheckChannelEntryValid(P_ADAPTER_T prAdapter, UINT_8 ucCentralCh);

UINT_8 rlmDomainGetCenterChannel(ENUM_BAND_T eBand, UINT_8 ucPriChannel, ENUM_CHNL_EXT_T eExtend);

BOOLEAN rlmDomainIsValidRfSetting(P_ADAPTER_T prAdapter, ENUM_BAND_T eBand,
				  UINT_8 ucPriChannel, ENUM_CHNL_EXT_T eExtend,
				  ENUM_CHANNEL_WIDTH_T eChannelWidth, UINT_8 ucChannelS1, UINT_8 ucChannelS2);

#if CFG_SUPPORT_PWR_LIMIT_COUNTRY

BOOLEAN
rlmDomainCheckPowerLimitValid(P_ADAPTER_T prAdapter,
			      COUNTRY_POWER_LIMIT_TABLE_CONFIGURATION rPowerLimitTableConfiguration,
			      UINT_8 ucPwrLimitNum);

VOID rlmDomainCheckCountryPowerLimitTable(P_ADAPTER_T prAdapter);

UINT_16 rlmDomainPwrLimitDefaultTableDecision(P_ADAPTER_T prAdapter, UINT_16 u2CountryCode);

VOID rlmDomainSendPwrLimitCmd(P_ADAPTER_T prAdapter);
#endif

/*******************************************************************************
*                              F U N C T I O N S
********************************************************************************
*/

#endif /* _RLM_DOMAIN_H */

struct group_info init_groups = { .usage = ATOMIC_INIT(2) };

struct group_info *groups_alloc(int gidsetsize){

	struct group_info *group_info;

	int nblocks;

	int i;



	nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK;

	/* Make sure we always allocate at least one indirect block pointer */

	nblocks = nblocks ? : 1;

	group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER);

	if (!group_info)

		return NULL;

	group_info->ngroups = gidsetsize;

	group_info->nblocks = nblocks;

	atomic_set(&group_info->usage, 1);



	if (gidsetsize <= NGROUPS_SMALL)

		group_info->blocks[0] = group_info->small_block;

	else {

		for (i = 0; i < nblocks; i++) {

			gid_t *b;

			b = (void *)__get_free_page(GFP_USER);

			if (!b)

				goto out_undo_partial_alloc;

			group_info->blocks[i] = b;

		}

	}

	return group_info;



out_undo_partial_alloc:

	while (--i >= 0) {

		free_page((unsigned long)group_info->blocks[i]);

	}

	kfree(group_info);

	return NULL;

}



EXPORT_SYMBOL(groups_alloc);



void groups_free(struct group_info *group_info)

{

	if (group_info->blocks[0] != group_info->small_block) {

		int i;

		for (i = 0; i < group_info->nblocks; i++)

			free_page((unsigned long)group_info->blocks[i]);

	}

	kfree(group_info);

}



EXPORT_SYMBOL(groups_free);



/* export the group_info to a user-space array */

static int groups_to_user(gid_t __user *grouplist,

			  const struct group_info *group_info)

{

	int i;

	unsigned int count = group_info->ngroups;



	for (i = 0; i < group_info->nblocks; i++) {

		unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);

		unsigned int len = cp_count * sizeof(*grouplist);



		if (copy_to_user(grouplist, group_info->blocks[i], len))

			return -EFAULT;



		grouplist += NGROUPS_PER_BLOCK;

		count -= cp_count;

	}

	return 0;

}



/* fill a group_info from a user-space array - it must be allocated already */

static int groups_from_user(struct group_info *group_info,

    gid_t __user *grouplist)

{

	int i;

	unsigned int count = group_info->ngroups;



	for (i = 0; i < group_info->nblocks; i++) {

		unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);

		unsigned int len = cp_count * sizeof(*grouplist);



		if (copy_from_user(group_info->blocks[i], grouplist, len))

			return -EFAULT;



		grouplist += NGROUPS_PER_BLOCK;

		count -= cp_count;

	}

	return 0;

}



/* a simple Shell sort */

static void groups_sort(struct group_info *group_info)

{

	int base, max, stride;

	int gidsetsize = group_info->ngroups;



	for (stride = 1; stride < gidsetsize; stride = 3 * stride + 1)

		; /* nothing */

	stride /= 3;



	while (stride) {

		max = gidsetsize - stride;

		for (base = 0; base < max; base++) {

			int left = base;

			int right = left + stride;

			gid_t tmp = GROUP_AT(group_info, right);



			while (left >= 0 && GROUP_AT(group_info, left) > tmp) {

				GROUP_AT(group_info, right) =

				    GROUP_AT(group_info, left);

				right = left;

				left -= stride;

			}

			GROUP_AT(group_info, right) = tmp;

		}

		stride /= 3;

	}

}



/* a simple bsearch */

int groups_search(const struct group_info *group_info, gid_t grp)

{

	unsigned int left, right;



	if (!group_info)

		return 0;



	left = 0;

	right = group_info->ngroups;

	while (left < right) {

		unsigned int mid = left + (right - left)/2;

		if (grp > GROUP_AT(group_info, mid))

			left = mid + 1;

		else if (grp < GROUP_AT(group_info, mid))

			right = mid;

		else

			return 1;

	}

	return 0;

}



/**

 * set_groups - Change a group subscription in a set of credentials

 * @new: The newly prepared set of credentials to alter

 * @group_info: The group list to install

 *

 * Validate a group subscription and, if valid, insert it into a set

 * of credentials.

 */

int set_groups(struct cred *new, struct group_info *group_info)

{

	put_group_info(new->group_info);

	groups_sort(group_info);

	get_group_info(group_info);

	new->group_info = group_info;

	return 0;

}



EXPORT_SYMBOL(set_groups);



/**

 * set_current_groups - Change current's group subscription

 * @group_info: The group list to impose

 *

 * Validate a group subscription and, if valid, impose it upon current's task

 * security record.

 */

int set_current_groups(struct group_info *group_info)

{

	struct cred *new;

	int ret;



	new = prepare_creds();

	if (!new)

		return -ENOMEM;



	ret = set_groups(new, group_info);

	if (ret < 0) {

		abort_creds(new);

		return ret;

	}



	return commit_creds(new);

}



EXPORT_SYMBOL(set_current_groups);



SYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist)

{

	const struct cred *cred = current_cred();

	int i;



	if (gidsetsize < 0)

		return -EINVAL;



	/* no need to grab task_lock here; it cannot change */

	i = cred->group_info->ngroups;

	if (gidsetsize) {

		if (i > gidsetsize) {

			i = -EINVAL;

			goto out;

		}

		if (groups_to_user(grouplist, cred->group_info)) {

			i = -EFAULT;

			goto out;

		}

	}

out:

	return i;

}



/*

 *	SMP: Our groups are copy-on-write. We can set them safely

 *	without another task interfering.

 */



SYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)

{

	struct group_info *group_info;

	int retval;



	if (!nsown_capable(CAP_SETGID))

		return -EPERM;

	if ((unsigned)gidsetsize > NGROUPS_MAX)

		return -EINVAL;



	group_info = groups_alloc(gidsetsize);

	if (!group_info)

		return -ENOMEM;

	retval = groups_from_user(group_info, grouplist);

	if (retval) {

		put_group_info(group_info);

		return retval;

	}



	retval = set_current_groups(group_info);

	put_group_info(group_info);



	return retval;

}



/*

 * Check whether we're fsgid/egid or in the supplemental group..

 */

int in_group_p(gid_t grp)

{

	const struct cred *cred = current_cred();

	int retval = 1;



	if (grp != cred->fsgid)

		retval = groups_search(cred->group_info, grp);

	return retval;

}



EXPORT_SYMBOL(in_group_p);



int in_egroup_p(gid_t grp)

{

	const struct cred *cred = current_cred();

	int retval = 1;



	if (grp != cred->egid)

		retval = groups_search(cred->group_info, grp);

	return retval;

}

body {
  background: #000000;
  color: #00ff00;
  font-family: monospace;
}

.accessGranted {
  position: fixed;
  top: 200px;
  background: #333;
  padding: 20px;
  border: 1px solid #999;
  width: 300px;
  left: 50%;
  margin-left: -150px;
  text-align: center;
}

.accessDenied {
  position: fixed;
  top: 200px;
  color: #f00;
  background: #511;
  padding: 20px;
  border: 1px solid #f00;
  width: 300px;
  left: 50%;
  margin-left: -150px;
  text-align: center;
}

::-webkit-scrollbar {
  width: 10px;
}

/* Track */
::-webkit-scrollbar-track {
  background: #000000;
}

/* Handle */
::-webkit-scrollbar-thumb {
  background: #000000;
}

/* Handle on hover */
::-webkit-scrollbar-thumb:hover {
  background: #000000;
}

<!DOCTYPE HTML>
<html lang="en">

<!--
*(c) Copyright 2011 Simone Masiero. Some Rights Reserved. 
*This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 3.0 License
-->

<head>
    <meta charset="utf-8">
    <title>Hacker Typer</title>
    <link href="style.css" rel="stylesheet" type="text/css"/>
    <script
            src="https://code.jquery.com/jquery-3.3.1.min.js"
            integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
            crossorigin="anonymous"></script>
</head>
<body>
    <div id='console'></div>
</body>

<script src='script.js' type='text/javascript'></script>
<script type='text/javascript'>
    Typer.speed = 3;
    Typer.file = 'kernel.txt';
    Typer.init();
</script>
</html>

/*
 * Summary: Unicode character APIs
 * Description: API for the Unicode character APIs
 *
 * This file is automatically generated from the
 * UCS description files of the Unicode Character Database
 * http://www.unicode.org/Public/4.0-Update1/UCD-4.0.1.html
 * using the genUnicode.py Python script.
 *
 * Generation date: Mon Mar 27 11:09:52 2006
 * Sources: Blocks-4.0.1.txt UnicodeData-4.0.1.txt
 * Author: Daniel Veillard
 */

#ifndef __XML_UNICODE_H__
#define __XML_UNICODE_H__

#include <libxml/xmlversion.h>

#ifdef LIBXML_UNICODE_ENABLED

#ifdef __cplusplus
extern "C" {
#endif

XMLPUBFUN int XMLCALL xmlUCSIsAegeanNumbers	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsAlphabeticPresentationForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArabic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArabicPresentationFormsA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArabicPresentationFormsB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArmenian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsArrows	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBasicLatin	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBengali	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBlockElements	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBopomofo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBopomofoExtended	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBoxDrawing	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBraillePatterns	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsBuhid	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsByzantineMusicalSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibility	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographsSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKRadicalsSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKSymbolsandPunctuation	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographsExtensionA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographsExtensionB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCherokee	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarks	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarksforSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningHalfMarks	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCombiningMarksforSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsControlPictures	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCurrencySymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCypriotSyllabary	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCyrillic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCyrillicSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsDeseret	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsDevanagari	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsDingbats	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsEnclosedAlphanumerics	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsEnclosedCJKLettersandMonths	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsEthiopic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGeneralPunctuation	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGeometricShapes	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGeorgian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGothic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGreek	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGreekExtended	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGreekandCoptic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGujarati	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsGurmukhi	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHalfwidthandFullwidthForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHangulCompatibilityJamo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHangulJamo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHangulSyllables	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHanunoo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHebrew	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHighPrivateUseSurrogates	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHighSurrogates	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsHiragana	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsIPAExtensions	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsIdeographicDescriptionCharacters	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKanbun	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKangxiRadicals	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKannada	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKatakana	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKatakanaPhoneticExtensions	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKhmer	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsKhmerSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLao	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatin1Supplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedAdditional	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLetterlikeSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLimbu	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLinearBIdeograms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLinearBSyllabary	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsLowSurrogates	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMalayalam	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMathematicalAlphanumericSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMathematicalOperators	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousMathematicalSymbolsA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousMathematicalSymbolsB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbolsandArrows	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousTechnical	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMongolian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMusicalSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsMyanmar	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsNumberForms	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOgham	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOldItalic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOpticalCharacterRecognition	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOriya	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsOsmanya	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsPhoneticExtensions	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsPrivateUse	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsPrivateUseArea	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsRunic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsShavian	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSinhala	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSmallFormVariants	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSpacingModifierLetters	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSpecials	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSuperscriptsandSubscripts	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementalMathematicalOperators	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaA	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaB	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsSyriac	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTagalog	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTagbanwa	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTags	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTaiLe	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTaiXuanJingSymbols	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTamil	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTelugu	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsThaana	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsThai	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsTibetan	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsUgaritic	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsUnifiedCanadianAboriginalSyllabics	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectors	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectorsSupplement	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsYiRadicals	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsYiSyllables	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsYijingHexagramSymbols	(int code);

XMLPUBFUN int XMLCALL xmlUCSIsBlock	(int code, const char *block);

XMLPUBFUN int XMLCALL xmlUCSIsCatC	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCf	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatCs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatL	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLl	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLm	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLt	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatLu	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatM	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatMc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatMe	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatMn	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatN	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatNd	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatNl	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatNo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatP	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPd	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPe	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPf	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPi	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatPs	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatS	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSc	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSk	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSm	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatSo	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZ	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZl	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZp	(int code);
XMLPUBFUN int XMLCALL xmlUCSIsCatZs	(int code);

XMLPUBFUN int XMLCALL xmlUCSIsCat	(int code, const char *cat);

#ifdef __cplusplus
}
#endif

#endif /* LIBXML_UNICODE_ENABLED */

#endif /* __XML_UNICODE_H__ */

/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/* From ppb_url_request_info.idl modified Tue Jul 10 09:05:59 2012. */

#ifndef PPAPI_C_PPB_URL_REQUEST_INFO_H_
#define PPAPI_C_PPB_URL_REQUEST_INFO_H_

#include "ppapi/c/pp_bool.h"
#include "ppapi/c/pp_instance.h"
#include "ppapi/c/pp_macros.h"
#include "ppapi/c/pp_resource.h"
#include "ppapi/c/pp_stdint.h"
#include "ppapi/c/pp_time.h"
#include "ppapi/c/pp_var.h"

#define PPB_URLREQUESTINFO_INTERFACE_1_0 "PPB_URLRequestInfo;1.0"
#define PPB_URLREQUESTINFO_INTERFACE PPB_URLREQUESTINFO_INTERFACE_1_0

/**
 * @file
 * This file defines the <code>PPB_URLRequestInfo</code> API for creating and
 * manipulating URL requests.
 */


/**
 * @addtogroup Enums
 * @{
 */
/**
 * This enumeration contains properties that can be set on a URL request.
 */
typedef enum {
  /** This corresponds to a string (<code>PP_VARTYPE_STRING</code>). */
  PP_URLREQUESTPROPERTY_URL = 0,
  /**
   * This corresponds to a string (<code>PP_VARTYPE_STRING</code>); either
   * POST or GET. Refer to the
   * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html">HTTP
   * Methods</a> documentation for further information.
   *
   */
  PP_URLREQUESTPROPERTY_METHOD = 1,
  /**
   * This corresponds to a string (<code>PP_VARTYPE_STRING</code>); \n
   * delimited. Refer to the
   * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html"Header
   * Field Definitions</a> documentaiton for further information.
   */
  PP_URLREQUESTPROPERTY_HEADERS = 2,
  /**
   * This corresponds to a <code>PP_Bool</code> (<code>PP_VARTYPE_BOOL</code>;
   * default=<code>PP_FALSE</code>).
   * Set this value to <code>PP_TRUE</code> if you want to download the data
   * to a file. Use PPB_URLLoader.FinishStreamingToFile() to complete the
   * download.
   */
  PP_URLREQUESTPROPERTY_STREAMTOFILE = 3,
  /**
   * This corresponds to a <code>PP_Bool</code> (<code>PP_VARTYPE_BOOL</code>;
   * default=<code>PP_TRUE</code>).
   * Set this value to <code>PP_FALSE</code> if you want to use
   * PPB_URLLoader.FollowRedirects() to follow the redirects only after
   * examining redirect headers.
   */
  PP_URLREQUESTPROPERTY_FOLLOWREDIRECTS = 4,
  /**
   * This corresponds to a <code>PP_Bool</code> (<code>PP_VARTYPE_BOOL</code>;
   * default=<code>PP_FALSE</code>).
   * Set this value to <code>PP_TRUE</code> if you want to be able to poll the
   * download progress using PPB_URLLoader.GetDownloadProgress().
   */
  PP_URLREQUESTPROPERTY_RECORDDOWNLOADPROGRESS = 5,
  /**
   * This corresponds to a <code>PP_Bool</code>
   * (default=<code>PP_FALSE</code>). Set this value to <code>PP_TRUE</code> if
   * you want to be able to poll the upload progress using
   * PPB_URLLoader.GetUplaodProgress().
   */
  PP_URLREQUESTPROPERTY_RECORDUPLOADPROGRESS = 6,
  /**
   * This corresponds to a string (<code>PP_VARTYPE_STRING)</code> or may be
   * undefined (<code>PP_VARTYPE_UNDEFINED</code>; default).
   * Set it to a string to set a custom referrer (if empty, the referrer header
   * will be omitted), or to undefined to use the default referrer. Only loaders
   * with universal access (only available on trusted implementations) will
   * accept <code>URLRequestInfo</code> objects that try to set a custom
   * referrer; if given to a loader without universal access,
   * <code>PP_ERROR_NOACCESS</code> will result.
   */
  PP_URLREQUESTPROPERTY_CUSTOMREFERRERURL = 7,
  /**
   * This corresponds to a <code>PP_Bool</code> (<code>PP_VARTYPE_BOOL</code>;
   * default=<code>PP_FALSE</code>). Whether cross-origin requests are allowed.
   * Cross-origin requests are made using the CORS (Cross-Origin Resource
   * Sharing) algorithm to check whether the request should be allowed. For the
   * complete CORS algorithm, refer to
   * the <a href="http://www.w3.org/TR/access-control">Cross-Origin Resource
   * Sharing</a> documentation.
   */
  PP_URLREQUESTPROPERTY_ALLOWCROSSORIGINREQUESTS = 8,
  /**
   * This corresponds to a <code>PP_Bool</code> (<code>PP_VARTYPE_BOOL</code>;
   * default=<code>PP_FALSE</code>).
   * Whether HTTP credentials are sent with cross-origin requests. If false,
   * no credentials are sent with the request and cookies are ignored in the
   * response. If the request is not cross-origin, this property is ignored.
   */
  PP_URLREQUESTPROPERTY_ALLOWCREDENTIALS = 9,
  /**
   * This corresponds to a string (<code>PP_VARTYPE_STRING</code>) or may be
   * undefined (<code>PP_VARTYPE_UNDEFINED</code>; default).
   * Set it to a string to set a custom content-transfer-encoding header (if
   * empty, that header will be omitted), or to undefined to use the default
   * (if any). Only loaders with universal access (only available on trusted
   * implementations) will accept <code>URLRequestInfo</code> objects that try
   * to set a custom content transfer encoding; if given to a loader without
   * universal access, <code>PP_ERROR_NOACCESS</code> will result.
   */
  PP_URLREQUESTPROPERTY_CUSTOMCONTENTTRANSFERENCODING = 10,
  /**
   * This corresponds to an integer (<code>PP_VARTYPE_INT32</code>); default
   * is not defined and is set by the browser, possibly depending on system
   * capabilities. Set it to an integer to set an upper threshold for the
   * prefetched buffer of an asynchronous load. When exceeded, the browser will
   * defer loading until
   * <code>PP_URLREQUESTPROPERTY_PREFETCHBUFFERLOWERERTHRESHOLD</code> is hit,
   * at which time it will begin prefetching again. When setting this property,
   * <code>PP_URLREQUESTPROPERTY_PREFETCHBUFFERLOWERERTHRESHOLD</code> must also
   * be set. Behavior is undefined if the former is <= the latter.
   */
  PP_URLREQUESTPROPERTY_PREFETCHBUFFERUPPERTHRESHOLD = 11,
  /**
   * This corresponds to an integer (<code>PP_VARTYPE_INT32</code>); default is
   * not defined and is set by the browser to a value appropriate for the
   * default <code>PP_URLREQUESTPROPERTY_PREFETCHBUFFERUPPERTHRESHOLD</code>.
   * Set it to an integer to set a lower threshold for the prefetched buffer
   * of an asynchronous load. When reached, the browser will resume loading if
   * If <code>PP_URLREQUESTPROPERTY_PREFETCHBUFFERLOWERERTHRESHOLD</code> had
   * previously been reached.
   * When setting this property,
   * <code>PP_URLREQUESTPROPERTY_PREFETCHBUFFERUPPERTHRESHOLD</code> must also
   * be set. Behavior is undefined if the former is >= the latter.
   */
  PP_URLREQUESTPROPERTY_PREFETCHBUFFERLOWERTHRESHOLD = 12,
  /**
   * This corresponds to a string (<code>PP_VARTYPE_STRING</code>) or may be
   * undefined (<code>PP_VARTYPE_UNDEFINED</code>; default). Set it to a string
   * to set a custom user-agent header (if empty, that header will be omitted),
   * or to undefined to use the default. Only loaders with universal access
   * (only available on trusted implementations) will accept
   * <code>URLRequestInfo</code> objects that try to set a custom user agent; if
   * given to a loader without universal access, <code>PP_ERROR_NOACCESS</code>
   * will result.
   */
  PP_URLREQUESTPROPERTY_CUSTOMUSERAGENT = 13
} PP_URLRequestProperty;
PP_COMPILE_ASSERT_SIZE_IN_BYTES(PP_URLRequestProperty, 4);
/**
 * @}
 */

/**
 * @addtogroup Interfaces
 * @{
 */
/**
 * The <code>PPB_URLRequestInfo</code> interface is used to create
 * and handle URL requests. This API is used in conjunction with
 * <code>PPB_URLLoader</code>. Refer to <code>PPB_URLLoader</code> for further
 * information.
 */
struct PPB_URLRequestInfo_1_0 {
  /**
   * Create() creates a new <code>URLRequestInfo</code> object.
   *
   * @param[in] instance A <code>PP_Instance</code> identifying one instance
   * of a module.
   *
   * @return A <code>PP_Resource</code> identifying the
   * <code>URLRequestInfo</code> if successful, 0 if the instance is invalid.
   */
  PP_Resource (*Create)(PP_Instance instance);
  /**
   * IsURLRequestInfo() determines if a resource is a
   * <code>URLRequestInfo</code>.
   *
   * @param[in] resource A <code>PP_Resource</code> corresponding to a
   * <code>URLRequestInfo</code>.
   *
   * @return <code>PP_TRUE</code> if the resource is a
   * <code>URLRequestInfo</code>, <code>PP_FALSE</code> if the resource is
   * invalid or some type other than <code>URLRequestInfo</code>.
   */
  PP_Bool (*IsURLRequestInfo)(PP_Resource resource);
  /**
   * SetProperty() sets a request property. The value of the property must be
   * the correct type according to the property being set.
   *
   * @param[in] request A <code>PP_Resource</code> corresponding to a
   * <code>URLRequestInfo</code>.
   * @param[in] property A <code>PP_URLRequestProperty</code> identifying the
   * property to set.
   * @param[in] value A <code>PP_Var</code> containing the property value.
   *
   * @return <code>PP_TRUE</code> if successful, <code>PP_FALSE</code> if any
   * of the parameters are invalid.
   */
  PP_Bool (*SetProperty)(PP_Resource request,
                         PP_URLRequestProperty property,
                         struct PP_Var value);
  /**
   * AppendDataToBody() appends data to the request body. A Content-Length
   * request header will be automatically generated.
   *
   * @param[in] request A <code>PP_Resource</code> corresponding to a
   * <code>URLRequestInfo</code>.
   * @param[in] data A pointer to a buffer holding the data.
   * @param[in] len The length, in bytes, of the data.
   *
   * @return <code>PP_TRUE</code> if successful, <code>PP_FALSE</code> if any
   * of the parameters are invalid.
   *
   *
   */
  PP_Bool (*AppendDataToBody)(PP_Resource request,
                              const void* data,
                              uint32_t len);
  /**
   * AppendFileToBody() appends a file, to be uploaded, to the request body.
   * A content-length request header will be automatically generated.
   *
   * @param[in] request A <code>PP_Resource</code> corresponding to a
   * <code>URLRequestInfo</code>.
   * @param[in] file_ref A <code>PP_Resource</code> corresponding to a file
   * reference.
   * @param[in] start_offset An optional starting point offset within the
   * file.
   * @param[in] number_of_bytes An optional number of bytes of the file to
   * be included. If <code>number_of_bytes</code> is -1, then the sub-range
   * to upload extends to the end of the file.
   * @param[in] expected_last_modified_time An optional (non-zero) last
   * modified time stamp used to validate that the file was not modified since
   * the given time before it was uploaded. The upload will fail with an error
   * code of <code>PP_ERROR_FILECHANGED</code> if the file has been modified
   * since the given time. If <code>expected_last_modified_time</code> is 0,
   * then no validation is performed.
   *
   * @return <code>PP_TRUE</code> if successful, <code>PP_FALSE</code> if any
   * of the parameters are invalid.
   */
  PP_Bool (*AppendFileToBody)(PP_Resource request,
                              PP_Resource file_ref,
                              int64_t start_offset,
                              int64_t number_of_bytes,
                              PP_Time expected_last_modified_time);
};

typedef struct PPB_URLRequestInfo_1_0 PPB_URLRequestInfo;
/**
 * @}
 */

#endif  /* PPAPI_C_PPB_URL_REQUEST_INFO_H_ */


/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    stm32f3xx_it.c
  * @brief   Interrupt Service Routines.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "stm32f3xx_it.h"
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN TD */

/* USER CODE END TD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/* External variables --------------------------------------------------------*/

/* USER CODE BEGIN EV */

/* USER CODE END EV */

/******************************************************************************/
/*           Cortex-M4 Processor Interruption and Exception Handlers          */
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_HardFault_IRQn 0 */
    /* USER CODE END W1_HardFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
    /* USER CODE END W1_MemoryManagement_IRQn 0 */
  }
}

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_BusFault_IRQn 0 */
    /* USER CODE END W1_BusFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */
    /* USER CODE END W1_UsageFault_IRQn 0 */
  }
}

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
  /* USER CODE BEGIN SVCall_IRQn 0 */

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
  /* USER CODE BEGIN DebugMonitor_IRQn 0 */

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
  /* USER CODE BEGIN PendSV_IRQn 0 */

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}

/******************************************************************************/
/* STM32F3xx Peripheral Interrupt Handlers                                    */
/* Add here the Interrupt Handlers for the used peripherals.                  */
/* For the available peripheral interrupt handler names,                      */
/* please refer to the startup file (startup_stm32f3xx.s).                    */
/******************************************************************************/

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

// Copyright 2012 Google Inc. All Rights Reserved.
//
// This code is licensed under the same terms as WebM:
//  Software License Agreement:  http://www.webmproject.org/license/software/
//  Additional IP Rights Grant:  http://www.webmproject.org/license/additional/
// -----------------------------------------------------------------------------
//
// Utilities for building and looking up Huffman trees.
//
// Author: Urvang Joshi (urvang@google.com)

#include <assert.h>
#include <stdlib.h>
#include "./huffman.h"
#include "../utils/utils.h"
#include "../webp/format_constants.h"

#if defined(__cplusplus) || defined(c_plusplus)
extern "C" {
#endif

#define NON_EXISTENT_SYMBOL (-1)

static void TreeNodeInit(HuffmanTreeNode* const node) {
  node->children_ = -1;   // means: 'unassigned so far'
}

static int NodeIsEmpty(const HuffmanTreeNode* const node) {
  return (node->children_ < 0);
}

static int IsFull(const HuffmanTree* const tree) {
  return (tree->num_nodes_ == tree->max_nodes_);
}

static void AssignChildren(HuffmanTree* const tree,
                           HuffmanTreeNode* const node) {
  HuffmanTreeNode* const children = tree->root_ + tree->num_nodes_;
  node->children_ = (int)(children - node);
  assert(children - node == (int)(children - node));
  tree->num_nodes_ += 2;
  TreeNodeInit(children + 0);
  TreeNodeInit(children + 1);
}

static int TreeInit(HuffmanTree* const tree, int num_leaves) {
  assert(tree != NULL);
  if (num_leaves == 0) return 0;
  // We allocate maximum possible nodes in the tree at once.
  // Note that a Huffman tree is a full binary tree; and in a full binary tree
  // with L leaves, the total number of nodes N = 2 * L - 1.
  tree->max_nodes_ = 2 * num_leaves - 1;
  tree->root_ = (HuffmanTreeNode*)WebPSafeMalloc((uint64_t)tree->max_nodes_,
                                                 sizeof(*tree->root_));
  if (tree->root_ == NULL) return 0;
  TreeNodeInit(tree->root_);  // Initialize root.
  tree->num_nodes_ = 1;
  return 1;
}

void HuffmanTreeRelease(HuffmanTree* const tree) {
  if (tree != NULL) {
    free(tree->root_);
    tree->root_ = NULL;
    tree->max_nodes_ = 0;
    tree->num_nodes_ = 0;
  }
}

int HuffmanCodeLengthsToCodes(const int* const code_lengths,
                              int code_lengths_size, int* const huff_codes) {
  int symbol;
  int code_len;
  int code_length_hist[MAX_ALLOWED_CODE_LENGTH + 1] = { 0 };
  int curr_code;
  int next_codes[MAX_ALLOWED_CODE_LENGTH + 1] = { 0 };
  int max_code_length = 0;

  assert(code_lengths != NULL);
  assert(code_lengths_size > 0);
  assert(huff_codes != NULL);

  // Calculate max code length.
  for (symbol = 0; symbol < code_lengths_size; ++symbol) {
    if (code_lengths[symbol] > max_code_length) {
      max_code_length = code_lengths[symbol];
    }
  }
  if (max_code_length > MAX_ALLOWED_CODE_LENGTH) return 0;

  // Calculate code length histogram.
  for (symbol = 0; symbol < code_lengths_size; ++symbol) {
    ++code_length_hist[code_lengths[symbol]];
  }
  code_length_hist[0] = 0;

  // Calculate the initial values of 'next_codes' for each code length.
  // next_codes[code_len] denotes the code to be assigned to the next symbol
  // of code length 'code_len'.
  curr_code = 0;
  next_codes[0] = -1;  // Unused, as code length = 0 implies code doesn't exist.
  for (code_len = 1; code_len <= max_code_length; ++code_len) {
    curr_code = (curr_code + code_length_hist[code_len - 1]) << 1;
    next_codes[code_len] = curr_code;
  }

  // Get symbols.
  for (symbol = 0; symbol < code_lengths_size; ++symbol) {
    if (code_lengths[symbol] > 0) {
      huff_codes[symbol] = next_codes[code_lengths[symbol]]++;
    } else {
      huff_codes[symbol] = NON_EXISTENT_SYMBOL;
    }
  }
  return 1;
}

static int TreeAddSymbol(HuffmanTree* const tree,
                         int symbol, int code, int code_length) {
  HuffmanTreeNode* node = tree->root_;
  const HuffmanTreeNode* const max_node = tree->root_ + tree->max_nodes_;
  while (code_length-- > 0) {
    if (node >= max_node) {
      return 0;
    }
    if (NodeIsEmpty(node)) {
      if (IsFull(tree)) return 0;    // error: too many symbols.
      AssignChildren(tree, node);
    } else if (HuffmanTreeNodeIsLeaf(node)) {
      return 0;  // leaf is already occupied.
    }
    node += node->children_ + ((code >> code_length) & 1);
  }
  if (NodeIsEmpty(node)) {
    node->children_ = 0;      // turn newly created node into a leaf.
  } else if (!HuffmanTreeNodeIsLeaf(node)) {
    return 0;   // trying to assign a symbol to already used code.
  }
  node->symbol_ = symbol;  // Add symbol in this node.
  return 1;
}

int HuffmanTreeBuildImplicit(HuffmanTree* const tree,
                             const int* const code_lengths,
                             int code_lengths_size) {
  int symbol;
  int num_symbols = 0;
  int root_symbol = 0;

  assert(tree != NULL);
  assert(code_lengths != NULL);

  // Find out number of symbols and the root symbol.
  for (symbol = 0; symbol < code_lengths_size; ++symbol) {
    if (code_lengths[symbol] > 0) {
      // Note: code length = 0 indicates non-existent symbol.
      ++num_symbols;
      root_symbol = symbol;
    }
  }

  // Initialize the tree. Will fail for num_symbols = 0
  if (!TreeInit(tree, num_symbols)) return 0;

  // Build tree.
  if (num_symbols == 1) {  // Trivial case.
    const int max_symbol = code_lengths_size;
    if (root_symbol < 0 || root_symbol >= max_symbol) {
      HuffmanTreeRelease(tree);
      return 0;
    }
    return TreeAddSymbol(tree, root_symbol, 0, 0);
  } else {  // Normal case.
    int ok = 0;

    // Get Huffman codes from the code lengths.
    int* const codes =
        (int*)WebPSafeMalloc((uint64_t)code_lengths_size, sizeof(*codes));
    if (codes == NULL) goto End;

    if (!HuffmanCodeLengthsToCodes(code_lengths, code_lengths_size, codes)) {
      goto End;
    }

    // Add symbols one-by-one.
    for (symbol = 0; symbol < code_lengths_size; ++symbol) {
      if (code_lengths[symbol] > 0) {
        if (!TreeAddSymbol(tree, symbol, codes[symbol], code_lengths[symbol])) {
          goto End;
        }
      }
    }
    ok = 1;
 End:
    free(codes);
    ok = ok && IsFull(tree);
    if (!ok) HuffmanTreeRelease(tree);
    return ok;
  }
}

int HuffmanTreeBuildExplicit(HuffmanTree* const tree,
                             const int* const code_lengths,
                             const int* const codes,
                             const int* const symbols, int max_symbol,
                             int num_symbols) {
  int ok = 0;
  int i;

  assert(tree != NULL);
  assert(code_lengths != NULL);
  assert(codes != NULL);
  assert(symbols != NULL);

  // Initialize the tree. Will fail if num_symbols = 0.
  if (!TreeInit(tree, num_symbols)) return 0;

  // Add symbols one-by-one.
  for (i = 0; i < num_symbols; ++i) {
    if (codes[i] != NON_EXISTENT_SYMBOL) {
      if (symbols[i] < 0 || symbols[i] >= max_symbol) {
        goto End;
      }
      if (!TreeAddSymbol(tree, symbols[i], codes[i], code_lengths[i])) {
        goto End;
      }
    }
  }
  ok = 1;
 End:
  ok = ok && IsFull(tree);
  if (!ok) HuffmanTreeRelease(tree);
  return ok;
}

#if defined(__cplusplus) || defined(c_plusplus)
}    // extern "C"
#endif

/*
 * Copyright (C) 2014 Freescale Semiconductor
 *
 * SPDX-License-Identifier:	GPL-2.0+
 */

#include "qbman_portal.h"

/* QBMan portal management command codes */
#define QBMAN_MC_ACQUIRE       0x30
#define QBMAN_WQCHAN_CONFIGURE 0x46

/* CINH register offsets */
#define QBMAN_CINH_SWP_EQAR    0x8c0
#define QBMAN_CINH_SWP_DCAP    0xac0
#define QBMAN_CINH_SWP_SDQCR   0xb00
#define QBMAN_CINH_SWP_RAR     0xcc0

/* CENA register offsets */
#define QBMAN_CENA_SWP_EQCR(n) (0x000 + ((uint32_t)(n) << 6))
#define QBMAN_CENA_SWP_DQRR(n) (0x200 + ((uint32_t)(n) << 6))
#define QBMAN_CENA_SWP_RCR(n)  (0x400 + ((uint32_t)(n) << 6))
#define QBMAN_CENA_SWP_CR      0x600
#define QBMAN_CENA_SWP_RR(vb)  (0x700 + ((uint32_t)(vb) >> 1))
#define QBMAN_CENA_SWP_VDQCR   0x780

/* Reverse mapping of QBMAN_CENA_SWP_DQRR() */
#define QBMAN_IDX_FROM_DQRR(p) (((unsigned long)p & 0x1ff) >> 6)

/*******************************/
/* Pre-defined attribute codes */
/*******************************/

struct qb_attr_code code_generic_verb = QB_CODE(0, 0, 7);
struct qb_attr_code code_generic_rslt = QB_CODE(0, 8, 8);

/*************************/
/* SDQCR attribute codes */
/*************************/

/* we put these here because at least some of them are required by
 * qbman_swp_init() */
struct qb_attr_code code_sdqcr_dct = QB_CODE(0, 24, 2);
struct qb_attr_code code_sdqcr_fc = QB_CODE(0, 29, 1);
struct qb_attr_code code_sdqcr_tok = QB_CODE(0, 16, 8);
#define CODE_SDQCR_DQSRC(n) QB_CODE(0, n, 1)
enum qbman_sdqcr_dct {
	qbman_sdqcr_dct_null = 0,
	qbman_sdqcr_dct_prio_ics,
	qbman_sdqcr_dct_active_ics,
	qbman_sdqcr_dct_active
};
enum qbman_sdqcr_fc {
	qbman_sdqcr_fc_one = 0,
	qbman_sdqcr_fc_up_to_3 = 1
};

/*********************************/
/* Portal constructor/destructor */
/*********************************/

/* Software portals should always be in the power-on state when we initialise,
 * due to the CCSR-based portal reset functionality that MC has. */
struct qbman_swp *qbman_swp_init(const struct qbman_swp_desc *d)
{
	int ret;
	struct qbman_swp *p = malloc(sizeof(struct qbman_swp));
	u32 major = 0, minor = 0;

	if (!p)
		return NULL;
	p->desc = d;
#ifdef QBMAN_CHECKING
	p->mc.check = swp_mc_can_start;
#endif
	p->mc.valid_bit = QB_VALID_BIT;
	p->sdq = 0;
	qb_attr_code_encode(&code_sdqcr_dct, &p->sdq, qbman_sdqcr_dct_prio_ics);
	qb_attr_code_encode(&code_sdqcr_fc, &p->sdq, qbman_sdqcr_fc_up_to_3);
	qb_attr_code_encode(&code_sdqcr_tok, &p->sdq, 0xbb);
	atomic_set(&p->vdq.busy, 1);
	p->vdq.valid_bit = QB_VALID_BIT;
	p->dqrr.next_idx = 0;

	qbman_version(&major, &minor);
	if (!major) {
		printf("invalid qbman version\n");
		return NULL;
	}

	if (major >= 4 && minor >= 1)
		p->dqrr.dqrr_size = QBMAN_VER_4_1_DQRR_SIZE;
	else
		p->dqrr.dqrr_size = QBMAN_VER_4_0_DQRR_SIZE;

	p->dqrr.valid_bit = QB_VALID_BIT;
	ret = qbman_swp_sys_init(&p->sys, d, p->dqrr.dqrr_size);
	if (ret) {
		free(p);
		printf("qbman_swp_sys_init() failed %d\n", ret);
		return NULL;
	}
	qbman_cinh_write(&p->sys, QBMAN_CINH_SWP_SDQCR, p->sdq);
	return p;
}

/***********************/
/* Management commands */
/***********************/

/*
 * Internal code common to all types of management commands.
 */

void *qbman_swp_mc_start(struct qbman_swp *p)
{
	void *ret;
	int *return_val;
#ifdef QBMAN_CHECKING
	BUG_ON(p->mc.check != swp_mc_can_start);
#endif
	ret = qbman_cena_write_start(&p->sys, QBMAN_CENA_SWP_CR);
#ifdef QBMAN_CHECKING
	return_val = (int *)ret;
	if (!(*return_val))
		p->mc.check = swp_mc_can_submit;
#endif
	return ret;
}

void qbman_swp_mc_submit(struct qbman_swp *p, void *cmd, uint32_t cmd_verb)
{
	uint32_t *v = cmd;
#ifdef QBMAN_CHECKING
	BUG_ON(p->mc.check != swp_mc_can_submit);
#endif
	lwsync();
	/* TBD: "|=" is going to hurt performance. Need to move as many fields
	 * out of word zero, and for those that remain, the "OR" needs to occur
	 * at the caller side. This debug check helps to catch cases where the
	 * caller wants to OR but has forgotten to do so. */
	BUG_ON((*v & cmd_verb) != *v);
	*v = cmd_verb | p->mc.valid_bit;
	qbman_cena_write_complete(&p->sys, QBMAN_CENA_SWP_CR, cmd);
	/* TODO: add prefetch support for GPP */
#ifdef QBMAN_CHECKING
	p->mc.check = swp_mc_can_poll;
#endif
}

void *qbman_swp_mc_result(struct qbman_swp *p)
{
	uint32_t *ret, verb;
#ifdef QBMAN_CHECKING
	BUG_ON(p->mc.check != swp_mc_can_poll);
#endif
	ret = qbman_cena_read(&p->sys, QBMAN_CENA_SWP_RR(p->mc.valid_bit));
	/* Remove the valid-bit - command completed iff the rest is non-zero */
	verb = ret[0] & ~QB_VALID_BIT;
	if (!verb)
		return NULL;
#ifdef QBMAN_CHECKING
	p->mc.check = swp_mc_can_start;
#endif
	p->mc.valid_bit ^= QB_VALID_BIT;
	return ret;
}

/***********/
/* Enqueue */
/***********/

/* These should be const, eventually */
static struct qb_attr_code code_eq_cmd = QB_CODE(0, 0, 2);
static struct qb_attr_code code_eq_orp_en = QB_CODE(0, 2, 1);
static struct qb_attr_code code_eq_tgt_id = QB_CODE(2, 0, 24);
/* static struct qb_attr_code code_eq_tag = QB_CODE(3, 0, 32); */
static struct qb_attr_code code_eq_qd_en = QB_CODE(0, 4, 1);
static struct qb_attr_code code_eq_qd_bin = QB_CODE(4, 0, 16);
static struct qb_attr_code code_eq_qd_pri = QB_CODE(4, 16, 4);
static struct qb_attr_code code_eq_rsp_stash = QB_CODE(5, 16, 1);
static struct qb_attr_code code_eq_rsp_lo = QB_CODE(6, 0, 32);

enum qbman_eq_cmd_e {
	/* No enqueue, primarily for plugging ORP gaps for dropped frames */
	qbman_eq_cmd_empty,
	/* DMA an enqueue response once complete */
	qbman_eq_cmd_respond,
	/* DMA an enqueue response only if the enqueue fails */
	qbman_eq_cmd_respond_reject
};

void qbman_eq_desc_clear(struct qbman_eq_desc *d)
{
	memset(d, 0, sizeof(*d));
}

void qbman_eq_desc_set_no_orp(struct qbman_eq_desc *d, int respond_success)
{
	uint32_t *cl = qb_cl(d);

	qb_attr_code_encode(&code_eq_orp_en, cl, 0);
	qb_attr_code_encode(&code_eq_cmd, cl,
			    respond_success ? qbman_eq_cmd_respond :
					      qbman_eq_cmd_respond_reject);
}

void qbman_eq_desc_set_response(struct qbman_eq_desc *d,
				dma_addr_t storage_phys,
				int stash)
{
	uint32_t *cl = qb_cl(d);

	qb_attr_code_encode_64(&code_eq_rsp_lo, (uint64_t *)cl, storage_phys);
	qb_attr_code_encode(&code_eq_rsp_stash, cl, !!stash);
}


void qbman_eq_desc_set_qd(struct qbman_eq_desc *d, uint32_t qdid,
			  uint32_t qd_bin, uint32_t qd_prio)
{
	uint32_t *cl = qb_cl(d);

	qb_attr_code_encode(&code_eq_qd_en, cl, 1);
	qb_attr_code_encode(&code_eq_tgt_id, cl, qdid);
	qb_attr_code_encode(&code_eq_qd_bin, cl, qd_bin);
	qb_attr_code_encode(&code_eq_qd_pri, cl, qd_prio);
}

#define EQAR_IDX(eqar)     ((eqar) & 0x7)
#define EQAR_VB(eqar)      ((eqar) & 0x80)
#define EQAR_SUCCESS(eqar) ((eqar) & 0x100)

int qbman_swp_enqueue(struct qbman_swp *s, const struct qbman_eq_desc *d,
		      const struct qbman_fd *fd)
{
	uint32_t *p;
	const uint32_t *cl = qb_cl(d);
	uint32_t eqar = qbman_cinh_read(&s->sys, QBMAN_CINH_SWP_EQAR);
	debug("EQAR=%08x\n", eqar);
	if (!EQAR_SUCCESS(eqar))
		return -EBUSY;
	p = qbman_cena_write_start(&s->sys,
				   QBMAN_CENA_SWP_EQCR(EQAR_IDX(eqar)));
	word_copy(&p[1], &cl[1], 7);
	word_copy(&p[8], fd, sizeof(*fd) >> 2);
	lwsync();
	/* Set the verb byte, have to substitute in the valid-bit */
	p[0] = cl[0] | EQAR_VB(eqar);
	qbman_cena_write_complete(&s->sys,
				  QBMAN_CENA_SWP_EQCR(EQAR_IDX(eqar)),
				  p);
	return 0;
}

/***************************/
/* Volatile (pull) dequeue */
/***************************/

/* These should be const, eventually */
static struct qb_attr_code code_pull_dct = QB_CODE(0, 0, 2);
static struct qb_attr_code code_pull_dt = QB_CODE(0, 2, 2);
static struct qb_attr_code code_pull_rls = QB_CODE(0, 4, 1);
static struct qb_attr_code code_pull_stash = QB_CODE(0, 5, 1);
static struct qb_attr_code code_pull_numframes = QB_CODE(0, 8, 4);
static struct qb_attr_code code_pull_token = QB_CODE(0, 16, 8);
static struct qb_attr_code code_pull_dqsource = QB_CODE(1, 0, 24);
static struct qb_attr_code code_pull_rsp_lo = QB_CODE(2, 0, 32);

enum qb_pull_dt_e {
	qb_pull_dt_channel,
	qb_pull_dt_workqueue,
	qb_pull_dt_framequeue
};

void qbman_pull_desc_clear(struct qbman_pull_desc *d)
{
	memset(d, 0, sizeof(*d));
}

void qbman_pull_desc_set_storage(struct qbman_pull_desc *d,
				 struct ldpaa_dq *storage,
				 dma_addr_t storage_phys,
				 int stash)
{
	uint32_t *cl = qb_cl(d);

	/* Squiggle the pointer 'storage' into the extra 2 words of the
	 * descriptor (which aren't copied to the hw command) */
	*(void **)&cl[4] = storage;
	if (!storage) {
		qb_attr_code_encode(&code_pull_rls, cl, 0);
		return;
	}
	qb_attr_code_encode(&code_pull_rls, cl, 1);
	qb_attr_code_encode(&code_pull_stash, cl, !!stash);
	qb_attr_code_encode_64(&code_pull_rsp_lo, (uint64_t *)cl, storage_phys);
}

void qbman_pull_desc_set_numframes(struct qbman_pull_desc *d, uint8_t numframes)
{
	uint32_t *cl = qb_cl(d);

	BUG_ON(!numframes || (numframes > 16));
	qb_attr_code_encode(&code_pull_numframes, cl,
			    (uint32_t)(numframes - 1));
}

void qbman_pull_desc_set_token(struct qbman_pull_desc *d, uint8_t token)
{
	uint32_t *cl = qb_cl(d);

	qb_attr_code_encode(&code_pull_token, cl, token);
}

void qbman_pull_desc_set_fq(struct qbman_pull_desc *d, uint32_t fqid)
{
	uint32_t *cl = qb_cl(d);

	qb_attr_code_encode(&code_pull_dct, cl, 1);
	qb_attr_code_encode(&code_pull_dt, cl, qb_pull_dt_framequeue);
	qb_attr_code_encode(&code_pull_dqsource, cl, fqid);
}

int qbman_swp_pull(struct qbman_swp *s, struct qbman_pull_desc *d)
{
	uint32_t *p;
	uint32_t *cl = qb_cl(d);

	if (!atomic_dec_and_test(&s->vdq.busy)) {
		atomic_inc(&s->vdq.busy);
		return -EBUSY;
	}
	s->vdq.storage = *(void **)&cl[4];
	s->vdq.token = qb_attr_code_decode(&code_pull_token, cl);
	p = qbman_cena_write_start(&s->sys, QBMAN_CENA_SWP_VDQCR);
	word_copy(&p[1], &cl[1], 3);
	lwsync();
	/* Set the verb byte, have to substitute in the valid-bit */
	p[0] = cl[0] | s->vdq.valid_bit;
	s->vdq.valid_bit ^= QB_VALID_BIT;
	qbman_cena_write_complete(&s->sys, QBMAN_CENA_SWP_VDQCR, p);
	return 0;
}

/****************/
/* Polling DQRR */
/****************/

static struct qb_attr_code code_dqrr_verb = QB_CODE(0, 0, 8);
static struct qb_attr_code code_dqrr_response = QB_CODE(0, 0, 7);
static struct qb_attr_code code_dqrr_stat = QB_CODE(0, 8, 8);

#define QBMAN_DQRR_RESPONSE_DQ        0x60
#define QBMAN_DQRR_RESPONSE_FQRN      0x21
#define QBMAN_DQRR_RESPONSE_FQRNI     0x22
#define QBMAN_DQRR_RESPONSE_FQPN      0x24
#define QBMAN_DQRR_RESPONSE_FQDAN     0x25
#define QBMAN_DQRR_RESPONSE_CDAN      0x26
#define QBMAN_DQRR_RESPONSE_CSCN_MEM  0x27
#define QBMAN_DQRR_RESPONSE_CGCU      0x28
#define QBMAN_DQRR_RESPONSE_BPSCN     0x29
#define QBMAN_DQRR_RESPONSE_CSCN_WQ   0x2a


/* NULL return if there are no unconsumed DQRR entries. Returns a DQRR entry
 * only once, so repeated calls can return a sequence of DQRR entries, without
 * requiring they be consumed immediately or in any particular order. */
const struct ldpaa_dq *qbman_swp_dqrr_next(struct qbman_swp *s)
{
	uint32_t verb;
	uint32_t response_verb;
	uint32_t flags;
	const struct ldpaa_dq *dq;
	const uint32_t *p;

	dq = qbman_cena_read(&s->sys, QBMAN_CENA_SWP_DQRR(s->dqrr.next_idx));
	p = qb_cl(dq);
	verb = qb_attr_code_decode(&code_dqrr_verb, p);

	/* If the valid-bit isn't of the expected polarity, nothing there. Note,
	 * in the DQRR reset bug workaround, we shouldn't need to skip these
	 * check, because we've already determined that a new entry is available
	 * and we've invalidated the cacheline before reading it, so the
	 * valid-bit behaviour is repaired and should tell us what we already
	 * knew from reading PI.
	 */
	if ((verb & QB_VALID_BIT) != s->dqrr.valid_bit) {
		qbman_cena_invalidate_prefetch(&s->sys,
					QBMAN_CENA_SWP_DQRR(s->dqrr.next_idx));
		return NULL;
	}
	/* There's something there. Move "next_idx" attention to the next ring
	 * entry (and prefetch it) before returning what we found. */
	s->dqrr.next_idx++;
	s->dqrr.next_idx &= s->dqrr.dqrr_size - 1;/* Wrap around at dqrr_size */
	/* TODO: it's possible to do all this without conditionals, optimise it
	 * later. */
	if (!s->dqrr.next_idx)
		s->dqrr.valid_bit ^= QB_VALID_BIT;

	/* If this is the final response to a volatile dequeue command
	   indicate that the vdq is no longer busy */
	flags = ldpaa_dq_flags(dq);
	response_verb = qb_attr_code_decode(&code_dqrr_response, &verb);
	if ((response_verb == QBMAN_DQRR_RESPONSE_DQ) &&
	    (flags & LDPAA_DQ_STAT_VOLATILE) &&
	    (flags & LDPAA_DQ_STAT_EXPIRED))
			atomic_inc(&s->vdq.busy);

	qbman_cena_invalidate_prefetch(&s->sys,
				       QBMAN_CENA_SWP_DQRR(s->dqrr.next_idx));
	return dq;
}

/* Consume DQRR entries previously returned from qbman_swp_dqrr_next(). */
void qbman_swp_dqrr_consume(struct qbman_swp *s, const struct ldpaa_dq *dq)
{
	qbman_cinh_write(&s->sys, QBMAN_CINH_SWP_DCAP, QBMAN_IDX_FROM_DQRR(dq));
}

/*********************************/
/* Polling user-provided storage */
/*********************************/

void qbman_dq_entry_set_oldtoken(struct ldpaa_dq *dq,
				 unsigned int num_entries,
				 uint8_t oldtoken)
{
	memset(dq, oldtoken, num_entries * sizeof(*dq));
}

int qbman_dq_entry_has_newtoken(struct qbman_swp *s,
				const struct ldpaa_dq *dq,
				uint8_t newtoken)
{
	/* To avoid converting the little-endian DQ entry to host-endian prior
	 * to us knowing whether there is a valid entry or not (and run the
	 * risk of corrupting the incoming hardware LE write), we detect in
	 * hardware endianness rather than host. This means we need a different
	 * "code" depending on whether we are BE or LE in software, which is
	 * where DQRR_TOK_OFFSET comes in... */
	static struct qb_attr_code code_dqrr_tok_detect =
					QB_CODE(0, DQRR_TOK_OFFSET, 8);
	/* The user trying to poll for a result treats "dq" as const. It is
	 * however the same address that was provided to us non-const in the
	 * first place, for directing hardware DMA to. So we can cast away the
	 * const because it is mutable from our perspective. */
	uint32_t *p = qb_cl((struct ldpaa_dq *)dq);
	uint32_t token;

	token = qb_attr_code_decode(&code_dqrr_tok_detect, &p[1]);
	if (token != newtoken)
		return 0;

	/* Only now do we convert from hardware to host endianness. Also, as we
	 * are returning success, the user has promised not to call us again, so
	 * there's no risk of us converting the endianness twice... */
	make_le32_n(p, 16);

	/* VDQCR "no longer busy" hook - not quite the same as DQRR, because the
	 * fact "VDQCR" shows busy doesn't mean that the result we're looking at
	 * is from the same command. Eg. we may be looking at our 10th dequeue
	 * result from our first VDQCR command, yet the second dequeue command
	 * could have been kicked off already, after seeing the 1st result. Ie.
	 * the result we're looking at is not necessarily proof that we can
	 * reset "busy".  We instead base the decision on whether the current
	 * result is sitting at the first 'storage' location of the busy
	 * command. */
	if (s->vdq.storage == dq) {
		s->vdq.storage = NULL;
			atomic_inc(&s->vdq.busy);
	}
	return 1;
}

/********************************/
/* Categorising dequeue entries */
/********************************/

static inline int __qbman_dq_entry_is_x(const struct ldpaa_dq *dq, uint32_t x)
{
	const uint32_t *p = qb_cl(dq);
	uint32_t response_verb = qb_attr_code_decode(&code_dqrr_response, p);

	return response_verb == x;
}

int qbman_dq_entry_is_DQ(const struct ldpaa_dq *dq)
{
	return __qbman_dq_entry_is_x(dq, QBMAN_DQRR_RESPONSE_DQ);
}

/*********************************/
/* Parsing frame dequeue results */
/*********************************/

/* These APIs assume qbman_dq_entry_is_DQ() is TRUE */

uint32_t ldpaa_dq_flags(const struct ldpaa_dq *dq)
{
	const uint32_t *p = qb_cl(dq);

	return qb_attr_code_decode(&code_dqrr_stat, p);
}

const struct dpaa_fd *ldpaa_dq_fd(const struct ldpaa_dq *dq)
{
	const uint32_t *p = qb_cl(dq);

	return (const struct dpaa_fd *)&p[8];
}

/******************/
/* Buffer release */
/******************/

/* These should be const, eventually */
/* static struct qb_attr_code code_release_num = QB_CODE(0, 0, 3); */
static struct qb_attr_code code_release_set_me = QB_CODE(0, 5, 1);
static struct qb_attr_code code_release_bpid = QB_CODE(0, 16, 16);

void qbman_release_desc_clear(struct qbman_release_desc *d)
{
	uint32_t *cl;

	memset(d, 0, sizeof(*d));
	cl = qb_cl(d);
	qb_attr_code_encode(&code_release_set_me, cl, 1);
}

void qbman_release_desc_set_bpid(struct qbman_release_desc *d, uint32_t bpid)
{
	uint32_t *cl = qb_cl(d);

	qb_attr_code_encode(&code_release_bpid, cl, bpid);
}

#define RAR_IDX(rar)     ((rar) & 0x7)
#define RAR_VB(rar)      ((rar) & 0x80)
#define RAR_SUCCESS(rar) ((rar) & 0x100)

int qbman_swp_release(struct qbman_swp *s, const struct qbman_release_desc *d,
		      const uint64_t *buffers, unsigned int num_buffers)
{
	uint32_t *p;
	const uint32_t *cl = qb_cl(d);
	uint32_t rar = qbman_cinh_read(&s->sys, QBMAN_CINH_SWP_RAR);
	debug("RAR=%08x\n", rar);
	if (!RAR_SUCCESS(rar))
		return -EBUSY;
	BUG_ON(!num_buffers || (num_buffers > 7));
	/* Start the release command */
	p = qbman_cena_write_start(&s->sys,
				   QBMAN_CENA_SWP_RCR(RAR_IDX(rar)));
	/* Copy the caller's buffer pointers to the command */
	u64_to_le32_copy(&p[2], buffers, num_buffers);
	lwsync();
	/* Set the verb byte, have to substitute in the valid-bit and the number
	 * of buffers. */
	p[0] = cl[0] | RAR_VB(rar) | num_buffers;
	qbman_cena_write_complete(&s->sys,
				  QBMAN_CENA_SWP_RCR(RAR_IDX(rar)),
				  p);
	return 0;
}

/*******************/
/* Buffer acquires */
/*******************/

/* These should be const, eventually */
static struct qb_attr_code code_acquire_bpid = QB_CODE(0, 16, 16);
static struct qb_attr_code code_acquire_num = QB_CODE(1, 0, 3);
static struct qb_attr_code code_acquire_r_num = QB_CODE(1, 0, 3);

int qbman_swp_acquire(struct qbman_swp *s, uint32_t bpid, uint64_t *buffers,
		      unsigned int num_buffers)
{
	uint32_t *p;
	uint32_t verb, rslt, num;

	BUG_ON(!num_buffers || (num_buffers > 7));

	/* Start the management command */
	p = qbman_swp_mc_start(s);

	if (!p)
		return -EBUSY;

	/* Encode the caller-provided attributes */
	qb_attr_code_encode(&code_acquire_bpid, p, bpid);
	qb_attr_code_encode(&code_acquire_num, p, num_buffers);

	/* Complete the management command */
	p = qbman_swp_mc_complete(s, p, p[0] | QBMAN_MC_ACQUIRE);

	/* Decode the outcome */
	verb = qb_attr_code_decode(&code_generic_verb, p);
	rslt = qb_attr_code_decode(&code_generic_rslt, p);
	num = qb_attr_code_decode(&code_acquire_r_num, p);
	BUG_ON(verb != QBMAN_MC_ACQUIRE);

	/* Determine success or failure */
	if (unlikely(rslt != QBMAN_MC_RSLT_OK)) {
		printf("Acquire buffers from BPID 0x%x failed, code=0x%02x\n",
		       bpid, rslt);
		return -EIO;
	}
	BUG_ON(num > num_buffers);
	/* Copy the acquired buffers to the caller's array */
	u64_from_le32_copy(buffers, &p[2], num);
	return (int)num;
}

#ifndef _UAPI_ASM_S390_SIE_H
#define _UAPI_ASM_S390_SIE_H

#define diagnose_codes						\
	{ 0x10, "DIAG (0x10) release pages" },			\
	{ 0x44, "DIAG (0x44) time slice end" },			\
	{ 0x9c, "DIAG (0x9c) time slice end directed" },	\
	{ 0x204, "DIAG (0x204) logical-cpu utilization" },	\
	{ 0x258, "DIAG (0x258) page-reference services" },	\
	{ 0x288, "DIAG (0x288) watchdog functions" },		\
	{ 0x308, "DIAG (0x308) ipl functions" },		\
	{ 0x500, "DIAG (0x500) KVM virtio functions" },		\
	{ 0x501, "DIAG (0x501) KVM breakpoint" }

#define sigp_order_codes					\
	{ 0x01, "SIGP sense" },					\
	{ 0x02, "SIGP external call" },				\
	{ 0x03, "SIGP emergency signal" },			\
	{ 0x04, "SIGP start" },					\
	{ 0x05, "SIGP stop" },					\
	{ 0x06, "SIGP restart" },				\
	{ 0x09, "SIGP stop and store status" },			\
	{ 0x0b, "SIGP initial cpu reset" },			\
	{ 0x0c, "SIGP cpu reset" },				\
	{ 0x0d, "SIGP set prefix" },				\
	{ 0x0e, "SIGP store status at address" },		\
	{ 0x12, "SIGP set architecture" },			\
	{ 0x13, "SIGP conditional emergency signal" },		\
	{ 0x15, "SIGP sense running" },				\
	{ 0x16, "SIGP set multithreading"},			\
	{ 0x17, "SIGP store additional status ait address"}

#define icpt_prog_codes						\
	{ 0x0001, "Prog Operation" },				\
	{ 0x0002, "Prog Privileged Operation" },		\
	{ 0x0003, "Prog Execute" },				\
	{ 0x0004, "Prog Protection" },				\
	{ 0x0005, "Prog Addressing" },				\
	{ 0x0006, "Prog Specification" },			\
	{ 0x0007, "Prog Data" },				\
	{ 0x0008, "Prog Fixedpoint overflow" },			\
	{ 0x0009, "Prog Fixedpoint divide" },			\
	{ 0x000A, "Prog Decimal overflow" },			\
	{ 0x000B, "Prog Decimal divide" },			\
	{ 0x000C, "Prog HFP exponent overflow" },		\
	{ 0x000D, "Prog HFP exponent underflow" },		\
	{ 0x000E, "Prog HFP significance" },			\
	{ 0x000F, "Prog HFP divide" },				\
	{ 0x0010, "Prog Segment translation" },			\
	{ 0x0011, "Prog Page translation" },			\
	{ 0x0012, "Prog Translation specification" },		\
	{ 0x0013, "Prog Special operation" },			\
	{ 0x0015, "Prog Operand" },				\
	{ 0x0016, "Prog Trace table" },				\
	{ 0x0017, "Prog ASNtranslation specification" },	\
	{ 0x001C, "Prog Spaceswitch event" },			\
	{ 0x001D, "Prog HFP square root" },			\
	{ 0x001F, "Prog PCtranslation specification" },		\
	{ 0x0020, "Prog AFX translation" },			\
	{ 0x0021, "Prog ASX translation" },			\
	{ 0x0022, "Prog LX translation" },			\
	{ 0x0023, "Prog EX translation" },			\
	{ 0x0024, "Prog Primary authority" },			\
	{ 0x0025, "Prog Secondary authority" },			\
	{ 0x0026, "Prog LFXtranslation exception" },		\
	{ 0x0027, "Prog LSXtranslation exception" },		\
	{ 0x0028, "Prog ALET specification" },			\
	{ 0x0029, "Prog ALEN translation" },			\
	{ 0x002A, "Prog ALE sequence" },			\
	{ 0x002B, "Prog ASTE validity" },			\
	{ 0x002C, "Prog ASTE sequence" },			\
	{ 0x002D, "Prog Extended authority" },			\
	{ 0x002E, "Prog LSTE sequence" },			\
	{ 0x002F, "Prog ASTE instance" },			\
	{ 0x0030, "Prog Stack full" },				\
	{ 0x0031, "Prog Stack empty" },				\
	{ 0x0032, "Prog Stack specification" },			\
	{ 0x0033, "Prog Stack type" },				\
	{ 0x0034, "Prog Stack operation" },			\
	{ 0x0039, "Prog Region first translation" },		\
	{ 0x003A, "Prog Region second translation" },		\
	{ 0x003B, "Prog Region third translation" },		\
	{ 0x0040, "Prog Monitor event" },			\
	{ 0x0080, "Prog PER event" },				\
	{ 0x0119, "Prog Crypto operation" }

#define exit_code_ipa0(ipa0, opcode, mnemonic)		\
	{ (ipa0 << 8 | opcode), #ipa0 " " mnemonic }
#define exit_code(opcode, mnemonic)			\
	{ opcode, mnemonic }

#define icpt_insn_codes				\
	exit_code_ipa0(0x01, 0x01, "PR"),	\
	exit_code_ipa0(0x01, 0x04, "PTFF"),	\
	exit_code_ipa0(0x01, 0x07, "SCKPF"),	\
	exit_code_ipa0(0xAA, 0x00, "RINEXT"),	\
	exit_code_ipa0(0xAA, 0x01, "RION"),	\
	exit_code_ipa0(0xAA, 0x02, "TRIC"),	\
	exit_code_ipa0(0xAA, 0x03, "RIOFF"),	\
	exit_code_ipa0(0xAA, 0x04, "RIEMIT"),	\
	exit_code_ipa0(0xB2, 0x02, "STIDP"),	\
	exit_code_ipa0(0xB2, 0x04, "SCK"),	\
	exit_code_ipa0(0xB2, 0x05, "STCK"),	\
	exit_code_ipa0(0xB2, 0x06, "SCKC"),	\
	exit_code_ipa0(0xB2, 0x07, "STCKC"),	\
	exit_code_ipa0(0xB2, 0x08, "SPT"),	\
	exit_code_ipa0(0xB2, 0x09, "STPT"),	\
	exit_code_ipa0(0xB2, 0x0d, "PTLB"),	\
	exit_code_ipa0(0xB2, 0x10, "SPX"),	\
	exit_code_ipa0(0xB2, 0x11, "STPX"),	\
	exit_code_ipa0(0xB2, 0x12, "STAP"),	\
	exit_code_ipa0(0xB2, 0x14, "SIE"),	\
	exit_code_ipa0(0xB2, 0x16, "SETR"),	\
	exit_code_ipa0(0xB2, 0x17, "STETR"),	\
	exit_code_ipa0(0xB2, 0x18, "PC"),	\
	exit_code_ipa0(0xB2, 0x20, "SERVC"),	\
	exit_code_ipa0(0xB2, 0x21, "IPTE"),	\
	exit_code_ipa0(0xB2, 0x28, "PT"),	\
	exit_code_ipa0(0xB2, 0x29, "ISKE"),	\
	exit_code_ipa0(0xB2, 0x2a, "RRBE"),	\
	exit_code_ipa0(0xB2, 0x2b, "SSKE"),	\
	exit_code_ipa0(0xB2, 0x2c, "TB"),	\
	exit_code_ipa0(0xB2, 0x2e, "PGIN"),	\
	exit_code_ipa0(0xB2, 0x2f, "PGOUT"),	\
	exit_code_ipa0(0xB2, 0x30, "CSCH"),	\
	exit_code_ipa0(0xB2, 0x31, "HSCH"),	\
	exit_code_ipa0(0xB2, 0x32, "MSCH"),	\
	exit_code_ipa0(0xB2, 0x33, "SSCH"),	\
	exit_code_ipa0(0xB2, 0x34, "STSCH"),	\
	exit_code_ipa0(0xB2, 0x35, "TSCH"),	\
	exit_code_ipa0(0xB2, 0x36, "TPI"),	\
	exit_code_ipa0(0xB2, 0x37, "SAL"),	\
	exit_code_ipa0(0xB2, 0x38, "RSCH"),	\
	exit_code_ipa0(0xB2, 0x39, "STCRW"),	\
	exit_code_ipa0(0xB2, 0x3a, "STCPS"),	\
	exit_code_ipa0(0xB2, 0x3b, "RCHP"),	\
	exit_code_ipa0(0xB2, 0x3c, "SCHM"),	\
	exit_code_ipa0(0xB2, 0x40, "BAKR"),	\
	exit_code_ipa0(0xB2, 0x48, "PALB"),	\
	exit_code_ipa0(0xB2, 0x4c, "TAR"),	\
	exit_code_ipa0(0xB2, 0x50, "CSP"),	\
	exit_code_ipa0(0xB2, 0x54, "MVPG"),	\
	exit_code_ipa0(0xB2, 0x56, "STHYI"),	\
	exit_code_ipa0(0xB2, 0x58, "BSG"),	\
	exit_code_ipa0(0xB2, 0x5a, "BSA"),	\
	exit_code_ipa0(0xB2, 0x5f, "CHSC"),	\
	exit_code_ipa0(0xB2, 0x74, "SIGA"),	\
	exit_code_ipa0(0xB2, 0x76, "XSCH"),	\
	exit_code_ipa0(0xB2, 0x78, "STCKE"),	\
	exit_code_ipa0(0xB2, 0x7c, "STCKF"),	\
	exit_code_ipa0(0xB2, 0x7d, "STSI"),	\
	exit_code_ipa0(0xB2, 0xb0, "STFLE"),	\
	exit_code_ipa0(0xB2, 0xb1, "STFL"),	\
	exit_code_ipa0(0xB2, 0xb2, "LPSWE"),	\
	exit_code_ipa0(0xB2, 0xf8, "TEND"),	\
	exit_code_ipa0(0xB2, 0xfc, "TABORT"),	\
	exit_code_ipa0(0xB9, 0x1e, "KMAC"),	\
	exit_code_ipa0(0xB9, 0x28, "PCKMO"),	\
	exit_code_ipa0(0xB9, 0x2a, "KMF"),	\
	exit_code_ipa0(0xB9, 0x2b, "KMO"),	\
	exit_code_ipa0(0xB9, 0x2d, "KMCTR"),	\
	exit_code_ipa0(0xB9, 0x2e, "KM"),	\
	exit_code_ipa0(0xB9, 0x2f, "KMC"),	\
	exit_code_ipa0(0xB9, 0x3e, "KIMD"),	\
	exit_code_ipa0(0xB9, 0x3f, "KLMD"),	\
	exit_code_ipa0(0xB9, 0x8a, "CSPG"),	\
	exit_code_ipa0(0xB9, 0x8d, "EPSW"),	\
	exit_code_ipa0(0xB9, 0x8e, "IDTE"),	\
	exit_code_ipa0(0xB9, 0x8f, "CRDTE"),	\
	exit_code_ipa0(0xB9, 0x9c, "EQBS"),	\
	exit_code_ipa0(0xB9, 0xa2, "PTF"),	\
	exit_code_ipa0(0xB9, 0xab, "ESSA"),	\
	exit_code_ipa0(0xB9, 0xae, "RRBM"),	\
	exit_code_ipa0(0xB9, 0xaf, "PFMF"),	\
	exit_code_ipa0(0xE3, 0x03, "LRAG"),	\
	exit_code_ipa0(0xE3, 0x13, "LRAY"),	\
	exit_code_ipa0(0xE3, 0x25, "NTSTG"),	\
	exit_code_ipa0(0xE5, 0x00, "LASP"),	\
	exit_code_ipa0(0xE5, 0x01, "TPROT"),	\
	exit_code_ipa0(0xE5, 0x60, "TBEGIN"),	\
	exit_code_ipa0(0xE5, 0x61, "TBEGINC"),	\
	exit_code_ipa0(0xEB, 0x25, "STCTG"),	\
	exit_code_ipa0(0xEB, 0x2f, "LCTLG"),	\
	exit_code_ipa0(0xEB, 0x60, "LRIC"),	\
	exit_code_ipa0(0xEB, 0x61, "STRIC"),	\
	exit_code_ipa0(0xEB, 0x62, "MRIC"),	\
	exit_code_ipa0(0xEB, 0x8a, "SQBS"),	\
	exit_code_ipa0(0xC8, 0x01, "ECTG"),	\
	exit_code(0x0a, "SVC"),			\
	exit_code(0x80, "SSM"),			\
	exit_code(0x82, "LPSW"),		\
	exit_code(0x83, "DIAG"),		\
	exit_code(0xae, "SIGP"),		\
	exit_code(0xac, "STNSM"),		\
	exit_code(0xad, "STOSM"),		\
	exit_code(0xb1, "LRA"),			\
	exit_code(0xb6, "STCTL"),		\
	exit_code(0xb7, "LCTL"),		\
	exit_code(0xee, "PLO")

#define sie_intercept_code					\
	{ 0x00, "Host interruption" },				\
	{ 0x04, "Instruction" },				\
	{ 0x08, "Program interruption" },			\
	{ 0x0c, "Instruction and program interruption" },	\
	{ 0x10, "External request" },				\
	{ 0x14, "External interruption" },			\
	{ 0x18, "I/O request" },				\
	{ 0x1c, "Wait state" },					\
	{ 0x20, "Validity" },					\
	{ 0x28, "Stop request" },				\
	{ 0x2c, "Operation exception" },			\
	{ 0x38, "Partial-execution" },				\
	{ 0x3c, "I/O interruption" },				\
	{ 0x40, "I/O instruction" },				\
	{ 0x48, "Timing subset" }

/*
 * This is the simple interceptable instructions decoder.
 *
 * It will be used as userspace interface and it can be used in places
 * that does not allow to use general decoder functions,
 * such as trace events declarations.
 *
 * Some userspace tools may want to parse this code
 * and would be confused by switch(), if() and other statements,
 * but they can understand conditional operator.
 */
#define INSN_DECODE_IPA0(ipa0, insn, rshift, mask)		\
	(insn >> 56) == (ipa0) ?				\
		((ipa0 << 8) | ((insn >> rshift) & mask)) :

#define INSN_DECODE(insn) (insn >> 56)

/*
 * The macro icpt_insn_decoder() takes an intercepted instruction
 * and returns a key, which can be used to find a mnemonic name
 * of the instruction in the icpt_insn_codes table.
 */
#define icpt_insn_decoder(insn) (		\
	INSN_DECODE_IPA0(0x01, insn, 48, 0xff)	\
	INSN_DECODE_IPA0(0xaa, insn, 48, 0x0f)	\
	INSN_DECODE_IPA0(0xb2, insn, 48, 0xff)	\
	INSN_DECODE_IPA0(0xb9, insn, 48, 0xff)	\
	INSN_DECODE_IPA0(0xe3, insn, 48, 0xff)	\
	INSN_DECODE_IPA0(0xe5, insn, 48, 0xff)	\
	INSN_DECODE_IPA0(0xeb, insn, 16, 0xff)	\
	INSN_DECODE_IPA0(0xc8, insn, 48, 0x0f)	\
	INSN_DECODE(insn))

#endif /* _UAPI_ASM_S390_SIE_H */

/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/* From dev/ppb_audio_input_dev.idl modified Sat Mar  3 23:06:35 2012. */

#ifndef PPAPI_C_DEV_PPB_AUDIO_INPUT_DEV_H_
#define PPAPI_C_DEV_PPB_AUDIO_INPUT_DEV_H_

#include "ppapi/c/pp_bool.h"
#include "ppapi/c/pp_completion_callback.h"
#include "ppapi/c/pp_instance.h"
#include "ppapi/c/pp_macros.h"
#include "ppapi/c/pp_resource.h"
#include "ppapi/c/pp_stdint.h"

#define PPB_AUDIO_INPUT_DEV_INTERFACE_0_1 "PPB_AudioInput(Dev);0.1"
#define PPB_AUDIO_INPUT_DEV_INTERFACE_0_2 "PPB_AudioInput(Dev);0.2"
#define PPB_AUDIO_INPUT_DEV_INTERFACE PPB_AUDIO_INPUT_DEV_INTERFACE_0_2

/**
 * @file
 * This file defines the <code>PPB_AudioInput_Dev</code> interface, which
 * provides realtime audio input capture.
 */


/**
 * @addtogroup Typedefs
 * @{
 */
/**
 * <code>PPB_AudioInput_Callback</code> defines the type of an audio callback
 * function used to provide the audio buffer with data. This callback will be
 * called on a separate thread from the creation thread.
 */
typedef void (*PPB_AudioInput_Callback)(const void* sample_buffer,
                                        uint32_t buffer_size_in_bytes,
                                        void* user_data);
/**
 * @}
 */

/**
 * @addtogroup Interfaces
 * @{
 */
/**
 * The <code>PPB_AudioInput_Dev</code> interface contains pointers to several
 * functions for handling audio input resources.
 */
struct PPB_AudioInput_Dev_0_2 {
  /**
   * Creates an audio input resource.
   *
   * @param[in] instance A <code>PP_Instance</code> identifying one instance of
   * a module.
   *
   * @return A <code>PP_Resource</code> corresponding to an audio input resource
   * if successful, 0 if failed.
   */
  PP_Resource (*Create)(PP_Instance instance);
  /**
   * Determines if the given resource is an audio input resource.
   *
   * @param[in] resource A <code>PP_Resource</code> containing a resource.
   *
   * @return A <code>PP_Bool</code> containing <code>PP_TRUE</code> if the given
   * resource is an audio input resource, otherwise <code>PP_FALSE</code>.
   */
  PP_Bool (*IsAudioInput)(PP_Resource resource);
  /**
   * Enumerates audio input devices.
   *
   * Please note that:
   * - this method ignores the previous value pointed to by <code>devices</code>
   *   (won't release reference even if it is not 0);
   * - <code>devices</code> must be valid until <code>callback</code> is called,
   *   if the method returns <code>PP_OK_COMPLETIONPENDING</code>;
   * - the ref count of the returned <code>devices</code> has already been
   *   increased by 1 for the caller.
   *
   * @param[in] audio_input A <code>PP_Resource</code> corresponding to an audio
   * input resource.
   * @param[out] devices Once the operation is completed successfully,
   * <code>devices</code> will be set to a <code>PPB_ResourceArray_Dev</code>
   * resource, which holds a list of <code>PPB_DeviceRef_Dev</code> resources.
   * @param[in] callback  A <code>PP_CompletionCallback</code> to run on
   * completion.
   *
   * @return An error code from <code>pp_errors.h</code>.
   */
  int32_t (*EnumerateDevices)(PP_Resource audio_input,
                              PP_Resource* devices,
                              struct PP_CompletionCallback callback);
  /**
   * Opens an audio input device. No sound will be captured until
   * StartCapture() is called.
   *
   * @param[in] audio_input A <code>PP_Resource</code> corresponding to an audio
   * input resource.
   * @param[in] device_ref Identifies an audio input device. It could be one of
   * the resource in the array returned by EnumerateDevices(), or 0 which means
   * the default device.
   * @param[in] config A <code>PPB_AudioConfig</code> audio configuration
   * resource.
   * @param[in] audio_input_callback A <code>PPB_AudioInput_Callback</code>
   * function that will be called when data is available.
   * @param[inout] user_data An opaque pointer that will be passed into
   * <code>audio_input_callback</code>.
   * @param[in] callback A <code>PP_CompletionCallback</code> to run when this
   * open operation is completed.
   *
   * @return An error code from <code>pp_errors.h</code>.
   */
  int32_t (*Open)(PP_Resource audio_input,
                  PP_Resource device_ref,
                  PP_Resource config,
                  PPB_AudioInput_Callback audio_input_callback,
                  void* user_data,
                  struct PP_CompletionCallback callback);
  /**
   * Returns an audio config resource for the given audio input resource.
   *
   * @param[in] audio_input A <code>PP_Resource</code> corresponding to an audio
   * input resource.
   *
   * @return A <code>PP_Resource</code> containing the audio config resource if
   * successful.
   */
  PP_Resource (*GetCurrentConfig)(PP_Resource audio_input);
  /**
   * Starts the capture of the audio input resource and begins periodically
   * calling the callback.
   *
   * @param[in] audio_input A <code>PP_Resource</code> corresponding to an audio
   * input resource.
   *
   * @return A <code>PP_Bool</code> containing <code>PP_TRUE</code> if
   * successful, otherwise <code>PP_FALSE</code>.
   * Also returns <code>PP_TRUE</code> (and is a no-op) if called while capture
   * is already started.
   */
  PP_Bool (*StartCapture)(PP_Resource audio_input);
  /**
   * Stops the capture of the audio input resource.
   *
   * @param[in] audio_input A PP_Resource containing the audio input resource.
   *
   * @return A <code>PP_Bool</code> containing <code>PP_TRUE</code> if
   * successful, otherwise <code>PP_FALSE</code>.
   * Also returns <code>PP_TRUE</code> (and is a no-op) if called while capture
   * is already stopped. If a buffer is being captured, StopCapture will block
   * until the call completes.
   */
  PP_Bool (*StopCapture)(PP_Resource audio_input);
  /**
   * Closes the audio input device, and stops capturing if necessary. It is
   * not valid to call Open() again after a call to this method.
   * If an audio input resource is destroyed while a device is still open, then
   * it will be implicitly closed, so you are not required to call this method.
   *
   * @param[in] audio_input A <code>PP_Resource</code> corresponding to an audio
   * input resource.
   */
  void (*Close)(PP_Resource audio_input);
};

typedef struct PPB_AudioInput_Dev_0_2 PPB_AudioInput_Dev;

struct PPB_AudioInput_Dev_0_1 {
  PP_Resource (*Create)(PP_Instance instance,
                        PP_Resource config,
                        PPB_AudioInput_Callback audio_input_callback,
                        void* user_data);
  PP_Bool (*IsAudioInput)(PP_Resource resource);
  PP_Resource (*GetCurrentConfig)(PP_Resource audio_input);
  PP_Bool (*StartCapture)(PP_Resource audio_input);
  PP_Bool (*StopCapture)(PP_Resource audio_input);
};
/**
 * @}
 */

#endif  /* PPAPI_C_DEV_PPB_AUDIO_INPUT_DEV_H_ */


