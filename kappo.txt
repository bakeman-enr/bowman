#!/bin/sh
DIR=www

mkdir $DIR 2> /dev/null

#echo "optimizing css[ui]..."
#java -jar tools/yuicompressor-2.4.2.jar -o $DIR/_s.css style.css

echo "optimizing css[text]..."
java -jar tools/yuicompressor-2.4.2.jar -o $DIR/_ts.css tstyle.css

GCC_OPT="--compilation_level ADVANCED_OPTIMIZATIONS"
#echo "optimizing game code[ui]..."
#cat game.js shared_ui.js ui.js > $DIR/_source.js
#echo -n "\$('head')['append'](\$(\"<style>" >> $DIR/_source.js
#cat $DIR/_s.css >> $DIR/_source.js
#echo '</style>"));' >> $DIR/_source.js
#java -jar tools/compiler.jar $GCC_OPT --js $DIR/_source.js --js_output_file $DIR/_j.js

echo "optimizing game code[text]..."
cat game.js shared_ui.js minigame.js tui.js | \
	grep -v cheat | \
	sed 's/\/\*\* @const \*\//var \0/' | \
	sed 's/\/\*==global==\*\//var \0/' | \
	sed 's/\.left/\._left/g' | \
	sed 's/\.right/\._right/g' | \
	sed 's/\.top/\._top/g' | \
	sed 's/\.bottom/\._bottom/g' | \
	sed 's/\.width/\._width/g' | \
	sed 's/\.height/\._height/g' | \
	sed 's/\.cells/\._cells/g' | \
	sed 's/\.name/\._name/g' | \
	sed 's/\.move/\._move/g' | \
	sed 's/\.type/\._type/g' | \
	sed 's/\.search/\._search/g' | \
	sed 's/\.add/\._add/g' | \
	sed 's/\.remove/\._remove/g' | \
	sed 's/\.distance/\._distance/g' | \
	sed 's/\.apply/\._apply/g' \
	> $DIR/_tsource.js

echo -n "\$('head')['append'](\$(\"<style>" >> $DIR/_tsource.js
cat $DIR/_ts.css | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/;}/}/g' >> $DIR/_tsource.js
echo '</style>"));' >> $DIR/_tsource.js
java -jar tools/compiler.jar $GCC_OPT --js $DIR/_tsource.js --variable_map_output_file $DIR/_jt_vars.map | sed 's/function/@/g' | sed "s/.length/@@/g" |sed "s/this\\./\`/g" > $DIR/_jt.js

#rm $DIR/_source.js

#echo "optimizing tiles..."
#pngcrush -rem alla -reduce -brute t.png $DIR/t.png > /dev/null

#echo "packing png file [ui]..."
#./js2png.php $DIR/_j.js $DIR/j.png
echo "packing png file [text]..."
./js2png.py $DIR/_jt.js $DIR/x.png
#rm $DIR/_j.js
SIZE=`identify www/x.png | awk '{ print $3; }'`
WIDTH=`echo $SIZE | cut -dx -f1`
HEIGHT=`echo $SIZE | cut -dx -f2`
echo "inserting width: $WIDTH, height: $HEIGHT"

echo "optimizing loader code[text]..."
cat loader.js | sed "s/WIDTH/$WIDTH/" | sed "s/HEIGHT/$HEIGHT/" > $DIR/loader.js
echo "loadpng('x.png', start);" >> $DIR/loader.js

java -jar tools/compiler.jar $GCC_OPT --js $DIR/loader.js --js_output_file $DIR/_s.js
#echo "creating loaders..."
##cutting first two lines:
#head -n2 < loader.html > $DIR/ui.html
#cat $DIR/_s.js >> $DIR/ui.html
#tail -n+3 loader.html >> $DIR/ui.html

head -n2 < loader.html > $DIR/text.html
cat $DIR/_s.js >> $DIR/text.html
tail -n+3 loader.html >> $DIR/text.html
cp t.png $DIR/t.png

#echo "calling advpng"
#advpng -z -4 www/x.png www/t.png
echo "optimizing with pngout..."
wine tools/pngout.exe -c0 www/x.png
wine tools/pngout.exe www/t.png

#echo -n "3d variant: "
#du -cb $DIR/j.png $DIR/ui.html | tail -n1
echo -n "tile variant: "
du -cb $DIR/x.png $DIR/text.html $DIR/t.png | tail -n1


#!/bin/sh

rm -rf fontanero fontanero.zip
mkdir fontanero
cp www/text.html fontanero/index.html
cp t.png fontanero
cp www/x.png fontanero
zip -r -9 fontanero.zip fontanero readme.txt
rm -rf fontanero

/** @const */ CELL_VOID = 0;
/** @const */ CELL_FLOOR = 1;
/** @const */ CELL_WALL = 2;
/** @const */ CELL_ENTRANCE = 3;
/** @const */ CELL_EXIT = 4;

/** @const */ PICKABLE = 1;
/** @const */ EDIBLE = 2;
/** @const */ READABLE = 4;
/** @const */ DRINKABLE = 8;
/** @const */ WEARABLE = 16;
/** @const */ FIXABLE = 32;

var book_list = [
	["book of healing", READABLE | PICKABLE], 
	["book of vision", READABLE | PICKABLE], 
	["book of cure", READABLE | PICKABLE],
	["book of genocide", READABLE | PICKABLE]
];

var food_list = [
	["apple", PICKABLE | EDIBLE], 
	["bread", PICKABLE | EDIBLE], 
	["meat", PICKABLE | EDIBLE], 
	["egg", PICKABLE | EDIBLE], 
	["spaghetti", PICKABLE | EDIBLE], 
	["jelly", PICKABLE | EDIBLE], 

	["gold", PICKABLE], 

	["strange potion", DRINKABLE | PICKABLE],
	["soda", DRINKABLE | PICKABLE],
	["milk", DRINKABLE | PICKABLE],
	["water", DRINKABLE | PICKABLE],
	["tea", DRINKABLE | PICKABLE]
];

var monster_list = [
	["spider"],
	["wasp"],
	["rat", "bat", "snake"],
	["poisonous bat", "vampire bat", "poisonous snake"], 
	["rabid mole"], 
	["mutant", "zombie"],
	["ghost"]
];

/*==global==*/map = null;

var floor = Math.floor, random = Math.random, abs = Math.abs;

function hash(str) {
	return str.charCodeAt(0) ^ (str.charCodeAt(1) << 1) ^ str.length;
}

function in_range(x, a, b) {
	return x >= a && x < b;
}

function rand(min, max) {
	if (min instanceof Array)
		return min[floor(random() * min.length)];
	return floor(min + random() * (max - min));
}

function roll(probability) {
	return random() < probability;
}

function sgn(v) {
	return (v > 0)? 1: ((v < 0)? -1: 0);
}

function log(str) {
	$("#l")['append']("&gt; " + str + "<br>")['scrollTop'](1000000);
}

function capitalize(string) {
	return string.charAt(0).toUpperCase() + string.slice(1);
}

var repaint_objects = function() {
	map.foreach(function(cell) {
		if (cell.visited && (cell.actor || cell.objects.length))
			map.repaint(cell);
	});
}

/** @constructor */

function movable() {
	this.cell = null;
	this.hp = rand(this.level * 5, this.level * 10);
	this.boss = false;
	this.poison_chance = 0;
	this.blind_chance = 0;

	this.drop_loot = function() {
		var c = this.cell;
		c.actor = null;
		if (this.boss || roll(0.5)) {
			c.objects.push(new dungeon_object("gold"));
		}
		c.blood = true;
	}
	this.damage = function(obj, hit) {
		//log("damaged for " + hit);
		obj.hp -= hit;
		if (obj.hp <= 0) {
			log(capitalize(this.blinded? "something": obj.name) + " dies.");
			if (obj.boss) {
				map.boss_killed = true;
				log("You killed the monster, return to the surface!");
			}
			
			if (obj instanceof hero) {
				var restart = confirm("You have died, continue?");
				if (restart) {
					obj.hp = rand(10, 20);
					obj.poisoned = 0;
					++obj.dead;
					return false;
				}
				else {
					S();
					return false;
				}
			}
			obj.drop_loot();
			map.repaint(obj.cell);
			return true;
		}
		if (roll(this.poison_chance)) {
			log(obj.name + " has been poisoned!");
			obj.poisoned = rand(3, 10);
		}
		if (roll(this.blind_chance)) {
			log(obj.name + " has been blinded!");
			obj.blinded = rand(20, 30);
			repaint_objects();
		}
		return false;
	}
	this.attack = function(obj, throwing) {
		var l = this.level;
		var my_hit = this instanceof hero;
		if (my_hit && !throwing)
			++l; //little hero's improvement
		if (!my_hit && !(obj instanceof hero))
			return false; //skip monsters attacks
		var hit = (!obj.boss || throwing)? rand(5 * l, 7 * l): 1;
		var blinded = this.blinded;
		var something = "something";
		log(
			(my_hit? 
				"You hit " + (blinded? something: obj.name): 
				capitalize(blinded? something: this.name) + " hits " + obj.name
			) + 
			" for " + hit + " hit points.");
		return this.damage(obj, hit);
	}
	
	this.move = function(dx, dy) {
		if (!(dx | dy) || (dx && dy))
			return false;
		
		var cell = this.cell;
		var x = cell.x + dx, y = cell.y + dy;
		if (x < 0 || x >= map.width || y < 0 || y >= map.height)
			return false;

		var new_cell = map.cells[y][x];
		if (new_cell.type == CELL_VOID || new_cell.type == CELL_WALL)
			return false;

		if (new_cell.actor != null) {
			this.attack(new_cell.actor);
			return true;
		}
		
		cell.actor = null;
		new_cell.actor = this;
		this.cell = new_cell;
		map.repaint(cell);
		map.repaint(new_cell);
		return true;
	}

	this.smart_move = function(dx, dy) {
		var dx2 = dx * dx, dy2 = dy * dy;
		var prefer_x = dx2 > dy2;
		if (!this.move(dx, dy)) {
			if (prefer_x)
				this.move(dx, 0) || this.move(0, dy);
			else
				this.move(0, dy) || this.move(dx, 0);
		}
	}
}

//basic actions

/** @constructor */

function hero_action(hero, key, name, mask, func) {
	this.hero = hero;
	this.key = key;
	this.name = name;
	this.mask = mask;
	this.func = func;
	this.combine = false;
	this.need_dir = false;

	this.apply = function(obj, obj2) {
		this.func.call(this.hero, obj, obj2);
	}
}

/** @constructor */

function inventory() {
	this.objects = [];
	
	this.add = function(obj, silent) {
		obj.type &= ~PICKABLE;
		if (obj.cell != null) {
			obj.cell.unlink(obj);
			obj.cell = null;
		}
		if (!silent)
			log("You picked up " + obj.name + ".");
		this.objects.push(obj);
	}
	
	this.find = function(name) {
		var objs = this.objects;
		for(var i = 0; i < objs.length; ++i) {
			var o = objs[i];
			if (o.name == name) 
				return o;
		}
		return null;
	}

	this.remove = function(obj) {
		var objs = this.objects, i = objs.indexOf(obj);
		if (i >= 0)
			objs.splice(i, 1);
	}
	
	this.get_actions = function() {
		var mask = 0;
		var objs = this.objects;
		for(var i = 0; i < objs.length; ++i) {
			mask |= objs[i].type;
		}
		return mask;
	}
	
	this.toString = function() {
		var c = {};
		var l = this.objects;
		if (!l.length)
			return "nothing";
		for(var i = 0; i < l.length; ++i) {
			var name = l[i].name;
			if (!c[name])
				c[name] = 1;
			else
				++c[name];
		}
		var r = "";
		for(var i in c) {
			var n = c[i];
			r += i;
			if (n > 1)
				r += "*" + n;
			r += ", ";
		}
		r = r.slice(0, -2);
		return r;
	}
}

/** @constructor */

function dungeon_monster(name, level) {
	this.name = name;
	this.level = level;
	
	movable.call(this);
	
	this.tick = function() {
		var hero = map.hero;
		var hero_cell = hero.cell, cell = this.cell;
		var dx = hero_cell.x - cell.x, dy = hero_cell.y - cell.y;
		var d = floor(Math.sqrt(dx * dx + dy * dy));
		var boss = this.boss;
		//now boss always moves randomly
		if (boss || d > 6) { //max distance
			dx = rand(-1, 2);
			dy = rand(-1, 2);
		} else {
			dx = sgn(dx);
			dy = sgn(dy);
		}
		this.smart_move(dx, dy);
	}
}

/** @constructor */

function hero() {
	this.name = "Mario";
	this.level = 1;
	this.MAX_LEVEL = 7;
	movable.call(this);
	this.cash = 0;
	this.inv = new inventory();
	this.poisoned = 0;
	this.blinded = 0;
	this.confused = 0;
	this.dead = 0;
	this.levels = ["Beggar", "Poor", "Labourer", "Professional", "Prosperous", "Millionaire", "Billionaire"];
	
	this.max_hp = function() {
		return 100 + this.level * 50;
	}
	
	this.level_cap = function() {
		return Math.pow(10, this.level + 1);
	}

	this.hp = this.max_hp();

	this.unlink = function(obj) {
		if (obj.cell != null)
			obj.cell.unlink(obj);
		else 
			this.inv.remove(obj);
	}
	
	this.pickup = function(obj) {
		this.inv.add(obj);
	}
	
	this.read = function(obj) {
		log("You read " + obj.name + ".");
		this.unlink(obj);
		var name = obj.name;
		if (name.indexOf("healing") >= 0) {
			this.hp = this.max_hp();
			log("You feel fully restored.");
		} else if (name.indexOf("vision") >= 0) {
			log("You feel somewhat enlightened.");
			map.foreach(function(cell) {
					if (!cell.visited) {
						cell.visited = true;
						map.repaint(cell);
					}
				});
		} else if (name.indexOf("cure") >= 0) {
			this.poisoned = 0;
			this.confused = 0;
			if (this.blinded) {
				this.blinded = 0;
				repaint_objects();
			}
		} else if (name.indexOf("genocide") >= 0) {
			map.foreach(function(cell) {
					if (cell.actor != null && cell.actor != map.hero && !cell.actor.boss) {
						cell.actor.drop_loot();
						cell.actor = null;
						map.repaint(cell);
					}
				});
		}
	}
	
	this.heal = function(n) {
		var hp = this.hp, hp0 = hp;
		hp += n;
		var max_hp = this.max_hp();
		if (hp > max_hp) {
			//add satiated effect? 
			hp = max_hp;
		}
		if (hp != hp0) {
			log("You restored " + (hp - hp0) + " health points.");
		}
		this.hp = hp;
	}

	this.eat = function(obj) {
		this.unlink(obj);
		var msg = ["Umph, it's rotten!", "Tastes great!", "Smells awful.", "You feel satiated."];
		log(rand(msg));
		var max_hp = this.max_hp();
		this.heal(rand(1, max_hp / 10));
	}
	
	this.throw_obj = function(obj, dx, dy) {
		this.unlink(obj);
		var text = "You threw " + obj.name + " and hit ";
		var cell = map.hero.cell;
		var x = cell.x, y = cell.y;
		for(;;) {
			cell = map.cells[y + dy][x + dx];
			if (cell.type == CELL_WALL) {
				text += "the wall";
				break;
			}
			if (cell.actor) {
				//hit something
				text += cell.actor.name;
				obj = null;
				break;
			}
			x += dx; y += dy;
		}
		animate_throw(x, y, obj, cell.actor, text + '.');
	}

	this.combine = function(obj1, obj2) {
		var obj = null;
		this.unlink(obj1);
		this.unlink(obj2);
		var r = (hash(obj1.name) + hash(obj2.name)) & 0x0f;
		var text = "got nothing.";
		if (in_range(r, 0, 4)) { //0, 1, 2, 3
			var book = book_list[r];
			obj = new dungeon_object(book[0], book[1]);
			text = "got " + obj.name + ".";
		} else if (in_range(r, 4, 8)) { //4, 5, 6, 7
			this.confused = rand(30, 40);
			text = "felt dizzy.";
		} else if (in_range(r, 8, 12)) {//8,9,10,11
			if (map.ambushed())
				text = "were attacked from ambush!";
		}
		//12,13,14,15 - nothing
		
		log("You tried to combine " + obj1.name + " and " + obj2.name + " and " + text);
		if (obj)
			this.inv.add(obj, true);
	}
	
	this.drink = function(obj) {
		this.unlink(obj);
		log("Refreshing!");
		var max_hp = this.max_hp();
		this.heal(rand(max_hp / 5, max_hp / 3));
		if (roll(0.05)) {
			log("You feel dizzy.");
			this.confused = rand(30, 40);
		}
	}
	
	this.search = function() {
		map.insert_random_object(food_list);
		if (roll(0.1))
			map.insert_random_monsters(1);
		if (roll(0.05))
			map.insert_random_object(book_list);
	}
	
	this.fix = function(obj) {
		obj.type &= ~FIXABLE;
		obj.name = "fixed pipes";
		var size = floor(3 * this.level / this.MAX_LEVEL + 3);
		run_mini_game(size, this.level_cap(), 10 - size);
	}
	this.add_cash = function(g) {
		var cap = this.level_cap();
		log("You got $" + g + ".");
		this.cash += g;
		if (this.level < this.MAX_LEVEL && this.cash >= cap) {
			++this.level;
			log(rand(["Occasionally you feel stronger!", "You gained next level!"]));
			this.cash -= cap;
		}
	}
	
	this.cheat = function() { this.add_cash(this.level_cap()); this.hp = this.max_hp(); } //keep this in one-line (grepped out by build.sh)
	
	this.get_actions = function() {
		var cell = this.cell;
		var objs = cell.objects;
		var mask = 0;
		for(var i = 0; i < objs.length; ) {
			var o = objs[i];
			switch(o.name) {
			case "gold": {
					objs.splice(i, 1);
					var cap = this.level_cap();
					var g = rand(cap / 10, cap / 5);
					this.add_cash(g);
					map.repaint(cell);
					continue;
				}
			case "key": {
					this.inv.add(o, true);
					objs.splice(i, 1);
					log("You picked up key to the next level.");
					map.repaint(cell);
					continue;
				}
			default:
				mask |= o.type;
				++i;
			}
		}
		mask |= this.inv.get_actions();
		var a = [];
		if (mask & PICKABLE)
			a.push(new hero_action(this, 'p', '<em>P</em>ickup', PICKABLE, this.pickup));
		if (mask & EDIBLE) {
			a.push(new hero_action(this, 'e', '<em>E</em>at', EDIBLE, this.eat));
			var t = new hero_action(this, 't', '<em>T</em>hrow', EDIBLE, this.throw_obj)
			t.need_dir = true;
			a.push(t);
			if (mask & DRINKABLE) {
				var ha = new hero_action(this, 'a', '<em>A</em>lchemy', EDIBLE | DRINKABLE, this.combine);
				ha.combine = true;
				a.push(ha);
			}
		}
		if (mask & READABLE)
			a.push(new hero_action(this, 'r', '<em>R</em>ead', READABLE, this.read));
		if (mask & DRINKABLE)
			a.push(new hero_action(this, 'd', '<em>D</em>rink', DRINKABLE, this.drink));
		if (mask & FIXABLE)
			a.push(new hero_action(this, 'f', '<em>F</em>ix', FIXABLE, this.fix));
		
		a.push(new hero_action(this, 's', '<em>S</em>earch', 0, this.search));
		a.push(new hero_action(this, 'h', 'C<em>h</em>eat', 0, this.cheat));
		
		var ct = cell.type;
		if (ct == CELL_EXIT || ct == CELL_ENTRANCE)
			a.push(new hero_action(this, 'x', 'E<em>x</em>it', 0, this.exit));
		return a;
	}
	
	this.get_objects = function(action, filter) {
		var r = [];
		var objs = this.cell.objects.concat(this.inv.objects);
		var mask = 0;
		if (!filter)
			filter = EDIBLE;
		for(var i = 0; i < objs.length; ++i) {
			var o = objs[i];
			if (action.combine? filter & o.type: action.mask & o.type)
				r.push([o, action]);
		}
		return r;
	}
	
	this.exit = function() {
		if (this.cell.type == CELL_ENTRANCE) {
			map.up();
		} else
			map.down();
	}
	
	this.tick = function() {
		if (this.poisoned > 0) {
			log(rand(["You are slowly dying.", "You feel sick."]));
			this.cell.blood = true;
			var hp = this.max_hp();
			this.damage(this, rand(hp / 20, hp / 10));
			--this.poisoned;
		}
		if (this.blinded > 0) {
			--this.blinded;
			if (this.blinded <= 0)
				repaint_objects();
		}
		if (this.confused > 0)
			--this.confused;
	}
}

/** @constructor */

function dungeon_object(name, type) {
	this.type = type;
	this.name = name;
}

/** @constructor */

function map_cell(type) {
	this.type = type;
	this.objects = [];
	this.actor = null;
	this.visited = false;
	this.blood = false;

	this.unlink = function(obj) {
		var objs = this.objects, i = objs.indexOf(obj);
		if (i >= 0)
			objs.splice(i, 1);
		map.repaint(this);
	}
}

/** @constructor */

function dungeon_room(l, t, r, b) {
	this.left = l;
	this.right = r;
	this.top = t;
	this.bottom = b;
	this.width = r - l;
	this.height = b - t;
	
	this.intersects = function(room) {
		//disallowing side-by-side walls
		return this.left <= room.right && this.right >= room.left && this.top <= room.bottom && this.bottom >= room.top;
	}
	this.manhattan = function(room) {
		var x1 = (this.left + this.right) >> 1;
		var x2 = (room.left + room.right) >> 1;
		var y1 = (this.top + this.bottom) >> 1;
		var y2 = (room.top + room.bottom) >> 1;
		return abs(x1 - x2) + abs(y1 - y2);
	}
	
	this.render = function(cells) {
		var l = this.left, r = this.right; t = this.top, b = this.bottom;
		for(var y = t; y < b; ++y) {
			for(var x = l; x < r; ++x) {
				var cell = cells[y][x];
				if (cell.type != CELL_VOID)
					continue;
				cell.type = (x == l || x == r - 1 || y == t || y == b - 1)? CELL_WALL: CELL_FLOOR;
				cell.room = [l, t, r, b];
			}
		}
	}
}


/** @constructor */

function dungeon_map(width, height) {
	this.width = width;
	this.height = height;
	this.cells = [];
	this.objects = [];
	this.repaint = null;
	this.repaint_all = null;
	this.levels = [];
	this.level = 0;
	this.hero = new hero();
	this.pipes = 0;
	this.fixed = 0;
	this.boss_killed = false;
	
	this.patch = function(x, y, type) {
		if (in_range(x, 0, this.width) && in_range(y, 0, this.height)) {
			var cell = this.cells[y][x];
			if (cell.type == CELL_VOID) {
				cell.type = type;
				return true;
			}
		}
		return false;
	}

	this.patch_random = function(room, type) {
		while(true) {
			var x = rand(room.left + 1, room.right - 1), y = rand(room.top + 1, room.bottom - 1);
			var cell = this.cells[y][x];
			if (cell.type == CELL_FLOOR) {
				cell.type = type;
				return cell;
			}
		}
	}
	
	this.connect = function(room1, room2) {
		var x = (room1.left + room1.right) >> 1;
		var y = (room1.top + room1.bottom) >> 1;
		var x2 = (room2.left + room2.right) >> 1;
		var y2 = (room2.top + room2.bottom) >> 1;
		while(x != x2 || y != y2) {
			var rx = abs(x - x2), ry = abs(y - y2);
			var dx = rx? (x2 - x) / rx: 0, dy = ry? (y2 - y) / ry: 0;
			var t = random();
			if (t < 0.3)
				dx = 0;
			else if (t > 0.7)
				dy = 0;

			if (dx != 0 && dy != 0) {
				if (rx >= ry)
					dy = 0;
				else
					dx = 0;
			}

			var cell = this.cells[y][x];
			switch(cell.type) {
			case CELL_VOID:
			case CELL_WALL:
				cell.type = CELL_FLOOR;
				break;
			}
			for(var wy = -1; wy <= 1; ++wy)
				for(var wx = -1; wx <= 1; ++wx) {
					if (wx | wy)
						this.patch(x + wx, y + wy, CELL_WALL);
				}
			
			x += dx;
			y += dy;
		}
	}
	
	this.insert_object = function(object, x, y) {
		var cell = this.cells[y][x];
		object.cell = cell;
		cell.objects.push(object);
		this.repaint(cell);
	}

	this.insert_actor = function(actor, cell) {
		actor.cell = cell;
		cell.actor = actor;
	}
	
	this.insert_random_object = function(objs) {
		var x = rand(0, this.width), y = rand(0, this.height);
		if (this.cells[y][x].type != CELL_FLOOR)
			return;
			
		var o = rand(objs);
		var e = new dungeon_object(o[0], o[1]);
		this.insert_object(e, x, y);
	}
	
	this.generate = function() {
		var MAX_SIZE = 0.3;
		var MIN_SIZE = 5; //with walls around
		var MAX_ASPECT = 1.75;
		var MIN_ASPECT = 1 / MAX_ASPECT;
		var MAX_ROOMS = 10;
		var MAX_ROOM_ATTEMPTS = 5;
		var rooms = [];

		var width = this.width, height = this.height;
		
		this.cells = [];
		var cells = this.cells;
		for(var y = 0; y < height; ++y) {
			cells[y] = [];
			var row = cells[y];
			for(var x = 0; x < width; ++x) {
				row.push(new map_cell(CELL_VOID));
				var cell = row[x];
				cell.x = x;
				cell.y = y;
			}
		}
		
		var hero = this.hero;
		if (hero.level == hero.MAX_LEVEL) {
			//final boss
			var room = new dungeon_room(1, 1, width - 2, height - 2);
			room.render(cells);
			var enter_cell = cells[height >> 1][width >> 1];
			enter_cell.type = CELL_ENTRANCE;
			for(var i = 0; i < width * height / 4; ++i) {
				cells[rand(1, height)][rand(1, width)].blood = true; //dont care about bounds anyway
			}
			this.levels[this.level] = cells;
			this.insert_actor(hero, enter_cell);
			var rabbit = new dungeon_monster("Killer Rabbit of Caerbannog", 25);
			rabbit.boss = true;
			this.insert_actor(rabbit, this.cells[height / 2][width / 2 + 7]);
			log(" Follow!  But! follow only if ye be men of valor, " + 
				"for the entrance to this cave is guarded by a creature so foul, " + 
				"so cruel that no man yet has fought with it and lived!  " + 
				"Bones of four fifty men lie strewn about its lair. " + 
				"So, brave " + hero.name + ", if you do doubt your courage or" +
				"your strength, come no further, for death awaits you " + 
				"all with nasty big pointy teeth.");

			this.update_view();
			this.repaint_all();
			return;
		}

		for(var i = 0; i < MAX_ROOMS * MAX_ROOM_ATTEMPTS; ++i) {
			var w = rand(MIN_SIZE, (this.width - MIN_SIZE - 2) * MAX_SIZE);
			var aspect = MIN_ASPECT + random() * (MAX_ASPECT - MIN_ASPECT);
			var h = (w * aspect) | 0;
			var x = rand(0, width - w);
			var y = rand(0, height - h);
			if (x + w >= width || y + h >= height || w < MIN_SIZE || h < MIN_SIZE)
				continue;
			var room = new dungeon_room(x, y, x + w, y + h);
			var j;
			for(j = 0; j < rooms.length; ++j) {
				if (room.intersects(rooms[j]))
					break;
			}
			if (j == rooms.length) {
				room.id = rooms.length;
				rooms.push(room);
				room.render(cells);
			}
			if (rooms.length >= MAX_ROOMS)
				break;
		}
		var enter_id = rand(0, rooms.length);
		var exit_id = enter_id;
		while(enter_id == exit_id) {
			exit_id = rand(0, rooms.length);
		}
		var enter_cell = this.patch_random(rooms[enter_id], CELL_ENTRANCE);
		var exit_cell = this.patch_random(rooms[exit_id], CELL_EXIT);
		
		for(var i = 0; i < rooms.length; ++i) {
			var room = rooms[i];
			room.distances = [];
			room.connected = [];
			for(var j = 0; j < rooms.length; ++j) {
				room.distances.push((i != j)? room.manhattan(rooms[j]): 0);
			}
		}
		for(var i = 0; i < rooms.length - 1; ++i) {
			var room = rooms[i];
			var d = room.distances.slice();
			d.sort();
			var m = d[floor(Math.sqrt(d.length))];
			if (rooms.length <= 4)
				m = d[d.length - 1];
			
			//alert(m);
			for(var j = i + 1; j < rooms.length; ++j) {
				if (room.distances[j] <= m) {
					room.connected.push(j);
					rooms[j].connected.push(i);
					this.connect(room, rooms[j]);
				}
			}
		}
		
		var visited = Array();
		var check = [enter_id];
		var connected = [];
		while(true) {
			while(check.length) {
				i = check.pop();
				if (connected.indexOf(i) < 0)
					connected.push(i);
				
				var room = rooms[i];
				for(var j = 0; j < room.connected.length; ++j) {
					var v = room.connected[j];
					if (connected.indexOf(v) < 0) {
						check.push(v);
						connected.push(v);
					}
				}
			}
			if (connected.length < rooms.length) {
				var closest_room1 = null, closest_room2 = null, closest_room_dist = 0;
				for(var i = 0; i < rooms.length; ++i) {
					if (connected.indexOf(i) < 0) //skip connected nodes
						continue;
					var room1 = rooms[i];
					for(var j = 0; j < rooms.length; ++j) {
						if (connected.indexOf(j) < 0) {
							var room2 = rooms[j];
							if (closest_room1 == null || room1.manhattan(room2) < closest_room_dist) {
								closest_room1 = room1;
								closest_room2 = room2;
								closest_room_dist = room1.manhattan(room2);
							}
						}
					}
				}
				if (closest_room1 == null) {
					alert("closest_room1 == null");
					break;
				}
				//alert("connecting " + closest_room1.id + " and " + closest_room2.id);
				closest_room1.connected.push(closest_room2.id);
				closest_room2.connected.push(closest_room1.id);
				check.push(closest_room1.id);
				check.push(closest_room2.id);
				this.connect(closest_room1, closest_room2);
			} else
				break;
		}
		//generating objects here
		
		this.insert_actor(hero, enter_cell);
		this.levels[this.level] = cells;
		this.repaint_all();
		this.update_view();
		
		while(true) {
			var x = rand(0, width), y = rand(0, height);
			if (cells[y][x].type != CELL_FLOOR)
				continue;
			var o = new dungeon_object("key", PICKABLE);
			this.insert_object(o, x, y);
			break;
		}

		if (roll(0.3)) {
			while(true) {
				var x = rand(0, width), y = rand(0, height);
				if (cells[y][x].type != CELL_FLOOR)
					continue;
				var o = new dungeon_object("pipes", FIXABLE);
				this.insert_object(o, x, y);
				++this.pipes;
				break;
			}
			log("Your senses tell you about broken pipe on this floor!");
		}

		for(var i = 0; i < rooms.length * 5; ++i)
			this.insert_random_object(food_list);
		this.insert_random_object(book_list);
		this.insert_random_monsters(rooms.length * 5);
	}
	
	this.ambushed = function() {
		var hero_cell = this.hero.cell;
		var cells = []
		for(var dy = -1; dy <= 1; ++dy)
			for(var dx = -1; dx <= 1; ++dx) {
				if (dx | dy) {
					var cell = this.cells[hero_cell.y + dy][hero_cell.x + dx];
					if (cell.type == CELL_FLOOR && !cell.actor)
						cells.push(cell);
				}
			}
		if (cells.length) {
			var cell = rand(cells);
			this.insert_actor(this.generate_monster(), cell);
			this.repaint(cell);
			return true;
		}
		return false;
	}
	
	this.generate_monster = function() {
		var hero = this.hero, monster_list_length = monster_list.length;
		var level = 1 + floor(monster_list_length * (hero.level - 1) / hero.MAX_LEVEL);
		if (level > 3 && level < monster_list_length) //a bit harder
			++level;
		var monsters = monster_list.slice(0, level);
		var monsters_len = monsters.length;
		var m_level = rand(monsters_len > 3? monsters_len - 3: 0, monsters_len);
		//log("monster level: " + level + " of " + monster_list.length + "-&gt;" + m_level);
		var o = rand(monsters[m_level]);
		var m = new dungeon_monster(o, m_level + 1);
		if (o.indexOf("poison") >= 0)
			m.poison_chance = 0.2;
		if (o == "ghost" || o == "mutant" || o == "wasp")
			m.blind_chance = 0.3;
		/*
		if (o == "spider") {
			m.blind_chance = 1;
			m.poison_chance = 1;
		}
		*/
		return m;
	}
	
	this.insert_random_monsters = function(n) {
		//log("spawning " + n + "monsters");
		for(var i = 0; i < n; ++i) {
			var x = rand(0, this.width), y = rand(0, this.height);
			var c = this.cells[y][x];
			if (c.type == CELL_FLOOR && !c.actor) {
				this.insert_actor(this.generate_monster(), c);
				this.repaint(c);
			}
		}
	}

	this.init_hero = function(cell_type) {
		this.foreach(function(cell) {
				if (cell.type == cell_type) {
					map.hero.cell = cell;
				}
			});
	}
	
	this.up = function() {
		var l = this.level, levels = this.levels;
		if (l == 0) {
			//add final here!
			if (this.boss_killed && this.fixed >= this.pipes)
				this.win(this.hero);
			else
				log("You must fix all pipes(and probably kill someone), until then there's no way out!");
			return;
		}
		log("you climbed up the stairs to the level " + l + ".");
		this.cells = levels[--l];
		this.level = l;
		this.init_hero(CELL_EXIT);
		this.insert_random_monsters(5);
		this.repaint_all();
	}
	
	
	this.down = function() {
		var l = this.level + 1, levels = this.levels;
		var hero = this.hero; //every new level requires a key to unlock it.
		var key = hero.inv.find("key");

		if (l >= levels.length && key == null) {
			log("This door is locked. Find the key to unlock it.");
			return;
		}
		
		this.level = l;
		log("you stepped down the stairs to the level " + (l + 1) + ".");
	
		if (l >= levels.length) {
			hero.inv.remove(key);
			this.generate();
		} else {
			this.cells = levels[l];
			this.init_hero(CELL_ENTRANCE);
			this.repaint_all();
			this.insert_random_monsters(5);
		}
	}
	
	this.view_line = function(x, y, dx, dy) {
		if (!(dx | dy))
			return;
		var w = this.width, h = this.height;
		//log("trying view " + x + ", " + y + ", " + dx + ", " + dy);
		while(in_range(x, 0, w) && in_range(y, 0, h)) {
			var c = this.cells[y][x];
			if (!c.visited) {
				c.visited = true;
				this.repaint(c);
			}
			if (c.type == CELL_WALL)
				break;
			x += dx; y += dy;
		}
	}
	this.update_view = function() {
		var w = this.width, h = this.height;
		var hero = this.hero;
		var cell = hero.cell;
		if (cell.room) {
			//entering the room
			var room = cell.room;
			for(var y = room[1]; y < room[3]; ++y) {
				for(var x = room[0]; x < room[2]; ++x) {
					var c = this.cells[y][x];
					if (!c.visited) {
						c.visited = true;
						this.repaint(c);
					}
				}
			}
		}
		for(var y = -1; y <= 1; ++y)
			for(var x = -1; x <= 1; ++x)
				this.view_line(hero.cell.x, hero.cell.y, x, y);
	}
	
	this.tick = function() {
		this.update_view();
		var m = [];
		this.foreach(function(cell) {
				var a = cell.actor;
				if (a != null)
					m.push(a);
			});
		for (var i = 0; i < m.length; ++i)
			m[i].tick();
	}
	
	this.foreach = function(func) {
		for(var y = 0; y < this.height; ++y) 
			for(var x = 0; x < this.width; ++x)
				func(this.cells[y][x]);
	}
}

document.title = "Fontanero. 10k Adventure for Gold and Glory. v3";


<!DOCTYPE HTML>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<title></title>
	<script type="text/javascript" src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js"></script>
	<script type="text/javascript" src="game.js"></script>
	<script type="text/javascript" src="startup.js"></script>
	<script type="text/javascript" src="shared_ui.js"></script>
	<script type="text/javascript" src="ui.js"></script>
	<link rel="stylesheet" href="style.css" type="text/css" media="screen">
</head>
<body>
	<script type="text/javascript">$(start(""));</script>
</body>
</html>

#!/usr/bin/python

import png, sys, math

align = 11

if len(sys.argv) < 3: 
	print("usage: jsfile pngfile")
	sys.exit(0)

f = open(sys.argv[1])
data = f.read()
n = len(data)
align = (1 << align) - 1
w = int(round(math.sqrt(n)) + align) & ~align;
h = int(1 + (n - 1) / w)
print("creating %dx%d image..." %(w, h));

rows = []
for i in xrange(0, h):
	rows.append([])
	for j in xrange(0, w):
		idx = i * w + j
		c = ord(data[idx]) if idx < n else 10
		if c < 32:
			if c == 10:
				c = 31
			else:
				raise Exception("unsupported char code %d" %c)
		rows[i].append(c - 31)

out = open(sys.argv[2], 'wb')

#print pixels
w = png.Writer(width=w, height=h, greyscale = True, bitdepth = 8, compression=9)
w.write(out, rows)

<!DOCTYPE HTML>
<html lang="en-US"><head><title></title><meta charset="UTF-8"><script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js"></script></head><body><script><!--
--></script></body></html>

<!DOCTYPE HTML>
<html lang="en-US"><head><title></title><meta charset="UTF-8"><script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js"></script></head><body><script><!--
--></script></body></html>

function loadpng(filename, callback) {
	var canvas = $("<canvas>")
		['attr']({width: WIDTH, height: HEIGHT})
		//['css']({'width': WIDTH + 'px', 'height': HEIGHT + 'px'})
		['get'](0), ctx;
	if (!canvas.getContext || !(ctx = canvas.getContext("2d")) || !ctx.getImageData) {
		alert('No canvas');
		return;
	}
	
	$('body')['append'](
	$('<img>')
		['css']({position: 'absolute', left: -WIDTH})
		['load'](function() {
			var self = this;
			var w = WIDTH;
			var h = HEIGHT;
			ctx.drawImage(self, 0, 0);
			var image_data = ctx.getImageData(0, 0, w, h).data;
			var str_data = "";
			var len = image_data.length;
			for (var i = 0; i < len; i += 4) {
				var b = image_data[i];
				str_data += String.fromCharCode(b > 0? b + 31: 10);
			};
			callback(str_data);
			$(self)['remove']();
		})
		['attr']('src', filename)
	); //body.append
}

function start(code) {
	eval(code.replace(/@@/g, '.length').replace(/@/g, 'function').replace(/\`/g, 'this.'));
	S();
}



		// == interface for the game ==
		function run_mini_game (size, prize, shuffle) {
			var size = size || 10,
				shuffle = shuffle || size,
				game = {
					is_win : false,
					gold : prize || 30
				},

				field = [];

			var turn = function(x, y) {
				var row = field[y];
				row[x] = !row[x];
				$('#m' + x + '_' + y)['toggleClass']('r');
			}

			var is_win_position = function() {
				for(var j = 0; j < size; ++j)
					for(var i = 0; i < size; ++i)
						if (!field[j][i])
							return false;
				return true;
			}

			var win = function () {
				game.is_win = true;
				$('#mg')['hide']()['empty']();
				++map.fixed;
				map.hero.add_cash(game.gold);
			}

			// do the move
			var move = function(x, y, shuffle_phase) {
				for(var i=0; i<size; i++) {
					turn(x, i);
					turn(i, y);
				}
				turn(x,y);
				if (is_win_position() && !shuffle_phase) {
					win();
				}
			}

			var generate = function() {
					// generate field
					for(var j=0, s=''; j<size; ++j) {
						field[j] = [];
						for(var i=0; i<size; ++i) {
							field[j][i] = true;
							s += '<b class="f" id="m' + i + '_' + j + '"></b>'
						}
					}

					// game field
					$('#mf')						// hide on start
					['html'](s)						// draw
					['css']({						// set dimensions and position
						width: size * 32,
						height: size * 32
					});

					// shuffle field
					for (var i=0; i < shuffle; ++i) {
						move(rand(0, size), rand(0, size), true);
						if (is_win_position())
							i=0;
					};
			}

			// create html
			$('#mg')['html']('<p id="mt">$' + prize + '</p>'+
			'<p id="mr">' +
			"<br>Goal of this minigame is turn <br>all the pipes to its right position (+).<br>" +
			"Click to turn pipe. <br>" + 
			'<br><button id="ms">Start!</button>' +
			'</p>' + 
			'<p id="mf"/><button id="g">Give up!</button>');
			
			generate();
			
			// start button runs the game
//			$('#ms')['bind']('click.mg', function() {
//			});
			
			// set onclick for 
			$('#mg')['bind']('click.mg', function(e) {
				var el = e.target;
				if (el.tagName == 'B') {
					move( el.id.replace(/^m(\d+)_\d+$/, '$1'), el.id.replace(/^m\d+_(\d+)$/, '$1'));
				} 
				switch(el.id) {
				case 'g':
					game.gold = 1;
					win();
					break;
				case 'ms': 
					$('#mr')['hide']();
					$('#mf, #g')['show']();
					// start timer!
					$('#mg')['bind']('tick.mg', {
							's': game,
							'id': setInterval("$('#mg').trigger('tick.mg')", 1000)
						}, function(e) {
								var s = e.data['s'];
								if (s.gold > 100)
									s.gold = floor(s.gold / 1.5);
								else
									s.gold -= rand(1, 4);
								if (s.gold < 1)
									s.gold = 1;

								if (s.is_win) {
									clearInterval(e.data['id']);
									$('#mg')['unbind']('.mg');
								}
								else {
									$('#mt')['html']('$' + s.gold);
								}
							}
					);
				}
			})['show']();
			$('#ms')['focus']();
		}

var actions = null;
var objects = null;
var combine = false;
var first_object = null;
var throw_obj = false;

function panel() {
	if (map == null)
		return;
	var hero = map.hero, level = hero.level;

	var html = "<dl><dt id='f'>" + hero.name + " the Fontanero<small>Level: " + hero.level + " (" + hero.levels[level-1] + ")</small></dt><dd>";
	html += "<b>HP:</b> " + hero.hp + " (" + hero.max_hp() +  ")" + 
	(hero.poisoned? " <b id='ps'>[POISONED]</b> ":"") + 
	(hero.blinded? " <b id='bl'>[BLINDED]</b>":"") + 
	(hero.confused? " <b id='cf'>[CONFUSED]</b>":"") + 
	"<br><b>Cash:</b> $" + hero.cash + " / " + hero.level_cap() +"<br>" + 
	"<b>Pipes found:</b> " + map.pipes + "<br><b>Pipes fixed:</b> " + map.fixed; 
	if (throw_obj) {
		html += '<dt>Choose direction:</dt><dd>Press up, down, left or right to throw ' + first_object.name +'</dd>';
		$('#panel')['html'](html);
		return;
	} else if (objects) {
		html += '<dt>Choose item:</dt><dd><ol>';
		for(var i = 0; i < objects.length; ++i) {
			var o = objects[i];
			html += "<li>" + o[0].name + "</li>";
		}
		html += '</ol></dd>';
		$('#panel')['html'](html);
		return;
	} else {
		html += '<dt>You are carrying:</dt><dd>' + hero.inv + '</dd>';
	}

	actions = hero.get_actions(); //MUST BE CALLED FIRST (do auto-pickup and other stuff)
	var objs = hero.cell.objects;
	var mask = 0;
	html += '<dt>You see:</dt><dd>';
	if (objs.length) {
		for(var i = 0; i < objs.length; ++i) {
			var o = objs[i];
			mask |= o.type;
			html += (i? ', ': '') + o.name;
		}
	}
	else {
		html += 'nothing'
	}
	html += "</dd>";
	
	html += '<dt>Actions:</dt><dd id="a"><ul>';
	for(var i = 0; i < actions.length; ++i) {
		html += '<li>' + actions[i].name + "</li>";
	}
	html += '</ul></dd>';
	$('#panel')['html'](html);
}

function on_key(e) {
	var h = map.hero;
	if (map == null || e.metaKey || $("#mg")['is'](":visible") || h.hp <= 0)
		return;
	
	var key = e.which || e.keyCode;
	var key_char = String.fromCharCode(key).toLowerCase();
	key = key_char.charCodeAt(0);
	var used = false, call_tick = true;
	//log("key " + key + "(" + key_char + ")");

	switch(key) {
	case 27:
		used = true;
		combine = false;
		throw_obj = false;
		first_object = null;
		break;
	case 37:
	case 38:
	case 39:
	case 40:
		var dx = [-1, 0, 1, 0][key - 37], dy = [0, -1, 0, 1][key - 37];
		if (h.confused > 0) {
			dx = -dx;
			dy = -dy;
		}
		if (throw_obj) {
			h.throw_obj(first_object, dx, dy);
			call_tick = false;
		} else
			h.move(dx, dy);
		used = true;
		throw_obj = false;
		first_object = null;
		objects = null;
		break;
	default:
		if (objects != null) {
			var i = key - 0x61; //ord('a');
			if (in_range(i, 0, objects.length)) {
				var o = objects[i];
				var a = o[1], obj = o[0];
				if (combine && first_object == null) {
					first_object = obj;
					objects = h.get_objects(a, DRINKABLE);
					call_tick = false;
					used = true;
					break;
				}
				if (a.need_dir) {
					first_object = obj;
					throw_obj = true;
					call_tick = false;
					used = true;
					break;
				}
				a.apply(obj, first_object);
			} 
			used = true;
			objects = null;
		} else if (actions != null) {
			for(var i = 0; i < actions.length; ++i) {
				var a = actions[i];
				if (a.key == key_char) {
					objects = h.get_objects(a);
					combine = a.combine;
					first_object = null;
					switch(objects.length) {
					case 0:
						a.apply(); //auto-action w/o object (like (s)leep)
						objects = null;
						break;
					case 1:
						var obj = objects[0][0];
						if (combine) { //choose even one object
							call_tick = false;
							break;
						}
						if (a.need_dir) {
							first_object = obj;
							throw_obj = true;
							call_tick = false;
							break;
						}
						a.apply(obj);
						objects = null;
						break;
					default:
						call_tick = false;
					}
					actions = null;
					used = true;
					break;
				}
			}
		}
	}
	if (used) {
		e.preventDefault();
		if (call_tick)
			map.tick();
		panel();
	}
}

function intro() {
	log("You've entered the <s>dungeon</s> cellar to fix all broken pipes and vents.");
}

/*
window.onbeforeunload = function (evt) {
	evt = evt || window.event;
	if (evt) {
		evt.returnValue = "Are you sure you want to leave?";
	}
	return message;
}
*/

$(document)['bind']($['browser']['mozilla'] ? 'keypress' : 'keydown', on_key);

	#wrapper {
		position: relative;
		border: 1px solid #000;
		overflow: hidden;
		background: black;
	}
	#map {
		margin-top: 16px;
		position: absolute;
		left: 0; top: 0;
	}
	/* 	Floor and roof:
		====================================================================== */
		#floor {
			background: #333;
			-moz-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-moz-transform-origin: 0% 0%;

			-webkit-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-webkit-transform-origin: 0% 0%;

			-o-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-o-transform-origin: 0% 0%;
			}
			.u {
				position: absolute;
				width: 32px;
				height: 32px;
				background: black;
				}
	/* 	Walls & doors:
		====================================================================== */
		#walls {
			position: absolute;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
		}
			.w {
				display: block;
				position: absolute;
				left: 50%;
				width: 32px;
				height: 32px;
				padding-top: 16px;	/* WALL_HEIGHT - TILE_SIZE */
				-moz-transform-origin: 100% 0;
				-webkit-transform-origin: 100% 0;
				-o-transform-origin: 100% 0;
/*				background: url('wall.png') repeat;*/
				}
		/* 	Walls:
			---------------------------------------------------------------------- */
			.w {
				background: green;
				}
				.r, .l.a {
					margin-top:-32px;
					}
				.r {
					background: #060;
					-moz-transform: skew(0deg, -26.7deg);
					-webkit-transform: skew(0deg, -26.7deg);
					-o-transform: skew(0deg, -26.7deg);
					}
				.r.a {
					margin-top: -48px;
					}
				.r.a, .l {
					margin-left: -32px;
					}
				.l {
					-moz-transform: skew(0deg, 26.7deg);
					-webkit-transform: skew(0deg, 26.7deg);
					-o-transform: skew(0deg, 26.7deg);
					margin-top: -16px;
					}
				.l.a {
					opacity: 0.7;
					margin-left: 0;
					}
				.a {
					opacity: 0.8;
					background: black;
					background: -moz-linear-gradient(bottom center, black 95%, rgba(0,204,0,0));
					background: -webkit-gradient(linear, left bottom, left top, color-stop(0.95, black), to(rgba(0,204,0,0)));
					}
			/* 	Wall decorations:
				---------------------------------------------------------------------- */
				.d {
					font-family: 'Webdings';
					font-size: 26px;
					font-weight: normal;
					text-align: center;
					}
					.paint:after {
						content: '\f0ad';
						}
					.switch:after {
						content: '\f0bc';
					}
					.plug:after {
						content: '\f0bd';
					}
					.display:after {
						content: '\f0be';
					}
					.calendar:after {
						content: '\f0a6';
					}
					.ibelieve:after {
						content: '\f085';
					}
				
				
/* 	Special zones:
	====================================================================== */
/* 	Enter:
	---------------------------------------------------------------------- */
	.enter, .exit {
		width: 64px;
		height: 64px;
		margin-left: -32px;
	}
	.enter, .exit, 
	.enter:after, .exit:after,
	.enter:before, .exit:before {
		display: block;
		position: absolute;
	}
	.enter:after, .exit:after {
		left: 10px; top: -12px;
		font-family: 'Wingdings';
		-moz-transform-origin: 100% 0;
		-moz-transform: skew(0deg, 30deg);
		-webkit-transform-origin: 100% 0;
		-webkit-transform: skew(0deg, 30deg);
		-o-transform-origin: 100% 0;
		-o-transform: skew(0deg, 30deg);
		font-size: 60px;
		text-shadow: 2px -2px 0px #000;
	}
		.enter:before, .exit:before {
			content: ' ';
			left: -22px; top: 8px;
			-moz-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-moz-transform-origin: 100% 100%;
			-webkit-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-webkit-transform-origin: 100% 100%;
			-o-transform: scale(1, 0.5) skew(-45deg, 45deg);
			-o-transform-origin: 100% 100%;
			width: 50px;
			height: 50px;
			-moz-border-radius: 15px;
			-webkit-border-radius: 15px;
			border: 4px solid #111;
			background: -moz-linear-gradient(40deg, black 50%, #222);
			background: -webkit-gradient(linear, left bottom, right top, color-stop(0.5, #000), to(#222));
		}
		.exit:before {
			border-color: #11c;
			background: #22e;
			}
		.enter:after {
			color: #cc0;
			content: '\f0e2';
			}
			#linux .enter:after {
				content: '\00e2';
				}
		.exit:after {
			color: #00c;
			content: '\f0e1';
			}
			#linux .exit:after {
				content: '\00e1';
				}
/* 	Objects:
	====================================================================== */
	.parrot, .apple, #hero, .book, .pile, .potion, .gold, .wasp {
		position: absolute;
		width: 32px;
		height: 32px;
		/*-moz-transform: scale(1, 0.5) skew(-45deg, 45deg);
				-moz-transform-origin: 0% 0%;
				-webkit-transform: scale(1, 0.5) skew(-45deg, 45deg);
				-webkit-transform-origin: 0% 0%;*/
		font-family: 'Webdings';
	}
	#hero {
			left: 50%;
			top: 50%;
	}
	#hero:after {
		-moz-transform-origin: 100% 0;
		-webkit-transform-origin: 100% 0;
		-o-transform-origin: 100% 0;		
		-moz-transform: skew(0deg, 26.7deg);
		-webkit-transform: skew(0deg, 26.7deg);
		-o-transform: skew(0deg, 26.7deg);
		
		position: absolute;
		content: '\f080';
		left: -32px;
		top: -32px;
		color: #006;
		font-size: 80px;
		text-shadow: 2px -2px 0px #003;
	}
	.pile {
		background: grey;
	}
	.parrot {
		background: orange;
	}
	.apple {
		background: red;
	}
	.book {
		background: brown;
	}
	.potion {
		background: blue;
	}
	.gold {
		color: yellow;
		font-size: 40px;
		text-shadow: 2px -1px 0px #660;
	}
	.gold:after {
/*		-moz-transform-origin: 100% 0;
		-webkit-transform-origin: 100% 0;
		-o-transform-origin: 100% 0;		
		-moz-transform: skew(0deg, 10deg);
		-webkit-transform: skew(0deg, 10deg);
		-o-transform: skew(0deg, 10deg);
*/		
		position: absolute;
		content: '\f091';
		left: 0px;
		top: 0px;
	}
	
	.wasp {
		background: yellow;
	}

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
</head>
<body>
	<script type="text/javascript">
	<!--
	//ie hack
	if(!Array.indexOf){
		Array.prototype.indexOf = function(obj){
			for(var i = 0; i < this.length; ++i){
				if (this[i] == obj)
					return i;
			}
			return -1;
		}
	}
	-->
	</script>
	<script type="text/javascript" src="https://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js"></script>
	<script type="text/javascript" src="game.js"></script>
	<script type="text/javascript" src="startup.js"></script>
	<script type="text/javascript" src="shared_ui.js"></script>
	<script type="text/javascript" src="minigame.js"></script>
	<script type="text/javascript" src="tui.js"></script>
	<script type="text/javascript">S("");</script>
	<link rel="stylesheet" href="tstyle.css" type="text/css">
</body></html>

* {margin: 0; padding: 0;
	font-weight: normal;
	font-style: normal;
	list-style: none;
	}
body {
	font: normal 12px Verdana;
	background: #055;
	color: #fff;
}
/* text-align: center */
h1, #mg {
	text-align: center;
}
/* float: left */
#c, #panel, i, u, .f {
	float: left;
}
/* display: block */
small, .f, i, u, #s {
	display: block;
}
/* display: none */
#mg, #mf, #g, #th {
	display: none;
}
/* padding: 8px */
#mf, #mr, #c, dt, #l {
	padding: 8px;
}
/* position: relative */
dd, .t1, #map {
	position: relative;
}
/* font-weight: bold */
#mt, dt, b {
	font-weight: bold;
}
/* font-size: 14px */
#f, .f {
	font-size: 14px;
}
/* overflow: hidden */
#mf, #mr, #map, #l {
	overflow: hidden;
}
#p {
	width: 1000px;
	margin: 0 auto;
}
h1 {
	padding: 20px 0
}
#c, dt, #mf, #mr {
	border: 3px solid #c93
}
#c, dt, #mf, #mr, #l {
	-moz-border-radius: 5px;
	-webkit-border-radius: 5px;
	border-radius: 5px;
}
#c, dt {
	background: #122;
}
dt {
	padding: 8px 20px;
	border-left: 0;
	-moz-border-radius: 0 5px 5px 0;
	-webkit-border-radius: 0 5px 5px 0;
	border-radius: 0 5px 5px 0;
}
dd {
	padding: 10px 20px 25px;
	background: -moz-linear-gradient(-80deg, rgba(0,0,0,0.8), rgba(0,0,0,0) 80px);
	background: -webkit-gradient(linear, center -40%, 55% 50, from(rgba(0,0,0,0.8)), to(rgba(0,0,0,0)));
	margin: 0 3px;
}
#panel {
	margin-left: -3px;
	width: 325px;
}

#l {
	font: 12px monospace;
	height: 128px;
	overflow: auto;
	background: #244;
}
dd b {
	display: inline-block;
	width: 100px;
}
ol li {
	list-style: lower-alpha inside;
}
/* Actions */
em {
	color: #c00;
}
/* poisoned */
#ps {
	color: #0c0;
	text-shadow: 0 0 3px #0c0;
}
/* blinded */
#bl {
	color: #cc0;
	text-shadow: 0 0 3px #cc0;
}
/* confused */
#cf {
	color: #0cc;
	text-shadow: 0 0 3px #0cc;
}
/* Map styles */
u, i {
	background: url(t.png); width: 16px; height: 16px;
}
u { clear: left}
#s {
	margin: 0 0 8px auto;
	padding: 0 8px;
	border: 2px solid;
}
.on i {
	-moz-box-shadow: 0px 0px 4px #323a55; 
	-webkit-box-shadow: 0px 0px 4px #323a55; 
	box-shadow: 0px 0px 4px #323a55; 
}
.on .t1 {
	-moz-box-shadow: 3px 2px 2px #000; 
	-webkit-box-shadow: 3px 2px 2px #000; 
	box-shadow: 3px 2px 2px #000;
/*	z-index: 10;*/
}
/* Minigame styles */
#mg {
	left: 0;
	top: 0;
	position: fixed;
	width: 100%;
	height: 100%;
	background: rgba(0,0,0,0.9);
	color: #000;
}
#mf, #mr {
	margin: 100px auto 20px;
	width: 250px;
	height: 150px;
	background: #fff;
}
.f {
	font-size: 18px;
	width: 32px;
	height: 32px;
	line-height: 32px;
	-moz-transition-property: -moz-transform, color;
	-moz-transition-duration: 0.4s;	
	-webkit-transition-property: -webkit-transform, color;
	-webkit-transition-duration: 0.4s;	
	-o-transition-property: -o-transform, color;
	-o-transition-duration: 0.4s;
	color: #060;
}
.f:after {
	content: '+';
}
.ie .r:after {
	content: '\00d7';
}
.f:hover {
	background: #ccc;
}
#mt {
	font-size: 40px;
	color: #0c0;
}
.r {
	color: #600;
	-moz-transform: rotate(45deg);
	-webkit-transform: rotate(45deg);	
	-o-transform: rotate(45deg);
}
#th {
	position: absolute;
	background-position:0 -112px;
/*	z-index: 8;*/
}

function gettile(cell) {
	if (!cell.visited)
		return -1;
	var actor = cell.actor;
	var hero = map.hero;
	var blinded = hero.blinded > 0;

	if (actor == hero)
		return 4;

	if (actor != null) {
		if (blinded)
			return 24;

		if (actor.boss)
			return 22;

		var name = actor.name;
		var tiles = {
			'wasp': 9, 
			'spider': 14, 
			'rat': 15,
			'bat': 16, 
			'snake': 17, 
			'poisonous bat': 16, 
			'vampire bat': 16, 
			'poisonous snake': 17,
			'rabid mole': 18,
			'mutant': 19,
			'zombie': 20,
			'ghost': 21
		}
		var tile = tiles[name];
		return tile? tile: 24;
	}
	
	var objs = cell.objects;
	var n = objs.length;
	if (n) {
		if (blinded)
			return 24;

		var mask = 0;
		for(var i = 0; i < n; ++i) {
			mask |= (objs[i].type & ~PICKABLE);
		}
		if (n == 1 || (mask & (mask - 1)) == 0) {
			var o = objs[0];
			var type = o.type;
			if (o.name.indexOf("pipes") >= 0)
				return (type&FIXABLE)? 12: 13;
			if (type & DRINKABLE)
				return 11;
			if (type & EDIBLE)
				return 7;
			if (type & READABLE)
				return 8;
			
			switch(o.name) {
			case "gold":
				return 6; 
			case "key":
				return 10;
			}
		}
		return 5;
	}
	switch(cell.type) {
	case CELL_FLOOR:
		return cell.blood? 23: 0;
	case CELL_ENTRANCE:
		return 2;
	case CELL_EXIT:
		return 3;
	case CELL_WALL:
		return 1;
	default:
		return -1;
	}
}

function repaint(cell) {
	var c = $('#c' + cell.y + '_' + cell.x);
	var t = gettile(cell);
	if (t >= 0) {
		c['css']({
			'visibility': 'visible',
			'background-position' : "0 " + (t * -16) + "px"
		})['addClass']('t' + t);
	} else 
		c['css']('visibility', 'hidden');
}

function repaint_all() {
	var str = '<i id="th"/>', t;
	var w = map.width, h = map.height;
	for(var y = 0; y < h; ++y) {
		for(var x = 0; x < w; ++x) {
			if (x == 0)
				t = 'u'
			else
				t = 'i';
			str += "<" + t + " id='c" + y + "_" + x + "'/>";
		}
	}
	//alert(str);
	var view = $('#map')
	view['html'](str);
	map.foreach(function(cell) {
			repaint(cell);
			var c = $('#c' + cell.y + '_' + cell.x);
			c['click'](function() {
				var hero = map.hero;
				var hero_cell = hero.cell;
				var dx = sgn(cell.x - hero_cell.x), dy = sgn(cell.y - hero_cell.y);
				hero.smart_move(dx, dy);
				map.tick();
				panel();
			});
		}
	);

	panel();
}

function animate_throw(x, y, obj, actor, message) {
	var c = map.hero.cell, dx = x - c.x, dy = y - c.y;
	distance = Math.max(Math.abs(dx), Math.abs(dy));
	$('#th')['css']({
		'left' : (c.x + sgn(dx)) * 16,
		'top' : (c.y + sgn(dy)) * 16
	})
	['show']()
	['animate']({
		'left' : x * 16,
		'top' : y * 16
	}, 20 * distance, function() {
		$(this)['hide']();
		log(message);
		if (obj) {
			obj.type |= PICKABLE;
			map.insert_object(obj, x, y);
		}
		if (actor) {
			map.hero.attack(actor, true);
		}
		map.tick();
	});
}

function win(hero) {
	var str = '<p id="mr">PURE WIN!!!<br>Got $' + hero.cash + '<br>Being dead ' + hero.dead + ' times. <br><br><b>Programmed by:</b><br>Vladimir Menshakov<br>&amp;<br>Vladimir Zhuravlev<br>&copy;2010</p>';
	$('#mg')['html'](str)['show']();
}

window['S'] = function() {
	if (map == null)
		$('body')['append']("<div id='p'><h1>" + document.title + "</h1><div id='c'><p id='map'/><button id='s'/><p id='l'/></div><div id='panel'/></div><div id='mg'/>");

	$('#s')['click'](function(){
		this.innerHTML = 'Turn shadows ' + ($('body')['toggleClass']('on')['hasClass']('on') ? 'off' : 'on');
	})['click']();
	if ($['browser']['msie']) {
		$('body')['addClass']('ie');
		$('#s')['click']();
	}

	var w = 40, h = 24; 
	map = new dungeon_map(w, h);
	
	$('#c')['css']('width', (w * 16 + 16));
	
	map.repaint = repaint;
	map.repaint_all = repaint_all;
	map.win = win;

	intro();
	map.generate();
	panel();
	//win(10000);
}

// viewport size
WINDOW_WIDTH = 12
WINDOW_HEIGHT = 12

// map dimensions
MAP_WIDTH = 80;
MAP_HEIGHT = 30;
TILE_SIZE = 32;

function create_html () {
	$('body')['append']($('<div id="wrapper"><div id="map"><div id="floor"></div><div id="walls"></div></div><div id="hero"></div></div><div id="panel"></div><div id="log"></div>'));

	var mw = MAP_WIDTH*TILE_SIZE,
		mh = MAP_HEIGHT*TILE_SIZE,
		ww = WINDOW_WIDTH*TILE_SIZE,
		wh = WINDOW_HEIGHT*TILE_SIZE;

	$('#wrapper')['css']({
		width: ww*2, 
		height: wh
	});
	$('#map')['css']({
		width: mw*2, 
		height: mh,
		'margin-left': ww,
		'margin-top': Math.floor(WINDOW_HEIGHT/2)*TILE_SIZE
	});
	$('#floor')['css']({
		width: mw, 
		height: mh
	});
}

function get_neighbors (x, y) {
	var v = { type: CELL_VOID },
		c = map.cells;
	return {
		self: (c[y] && c[y][x] || v).type, 
		left: 	(c[y] && c[y][x-1] || v).type,
		right: 	(c[y] && c[y][x+1] || v).type,
		top: 	(c[y-1] && c[y-1][x] || v).type,
		bottom: (c[y+1] && c[y+1][x] || v).type
	}
}

function draw_tile (classname, left, top, z) {
	return '<b class="' + classname + '" style="left:' + left + 'px;top:' + top + 'px;' + (z? ('z-index:'+z) : '') + '"></b>'
}

function draw_object (x, y, z) {
	var cell = map.cells[y][x],
		s = '',
		left = (x-y)*TILE_SIZE,
		top = (x+y)*TILE_SIZE/2,
		o = a = '<b style="left:' + left + 'px;' +
						'top:' + top + 'px;' + 
						'z-index' + z + '" class="';

	if (cell.objects.length) {

		// draw object
		s += o + (cell.objects.length > 1 + !!cell.actor ? 'pile' : cell.objects[0].name) + '"></b>'
	}
	// draw actor (if any)
	if (cell.actor && (cell.actor != map.hero)) {
		s += a + cell.actor.name + '"></b>'
	}
	
	return s;
}

function draw_level() {
	var // predictable_rand initial value
		Xn = map.level,
		m = Math.pow(2, 32),
		a =	69069,
		c = 5;
		
		// wall decoration classes
		DECORATION = ['paint', 'switch', 'plug', 'display', 'calendar', 'ibelieve'],
		D_FREQ = 0.05;

	var p_rand = function() {
		Xn = (a*Xn + c) % m;
		return Xn/m;
	}
	
	for(var y=0, floor='', walls=''; y<MAP_HEIGHT; y++) {
		for(var x=0; x<MAP_WIDTH; x++) {
			var obj='<b id="o'+x+'_'+y+'">',
				left = (x-y)*TILE_SIZE,
				top = (x+y)*TILE_SIZE/2,
				z = (x + y)*10,
				cells = get_neighbors(x, y),
				deco = (p_rand() < D_FREQ ? (' d ' + DECORATION[Math.floor(p_rand()*DECORATION.length)]) : '' );
			// draw map elements
			switch (cells.self) {
				case CELL_VOID: 
						floor += draw_tile('u', x*TILE_SIZE, y*TILE_SIZE);
						break;
				case CELL_WALL: 
						floor += draw_tile('u', x*TILE_SIZE, y*TILE_SIZE);
						if ((y<=0) || (cells.top != CELL_WALL)) {
							walls += draw_tile('w l a', left, top, z+1);
						}
						if ((y>=MAP_WIDTH-1) || (cells.bottom != CELL_WALL)) {
							walls += draw_tile('w l' + deco, left, top, z+8);
						} 
						if ((x<=0) || (cells.left != CELL_WALL)) {
							walls += draw_tile('w r a', left, top, z+2);
						}
						if ((x>=MAP_WIDTH-1) || (cells.right != CELL_WALL)) {
							walls += draw_tile('w r', left, top, z+9);
						} 
						break;
				case CELL_ENTRANCE:
				case CELL_EXIT:
						walls += draw_tile((cells.self == CELL_EXIT ? 'exit' : 'enter'), left, top, z+3);
						break;
			}
			// draw object containers
			var s = draw_object(x, y, z+4)
			if (s) {
				// create container for this field
				walls += obj + s + '</b>'
			}
		}
	}
	$('#floor')['html'](floor);
	$('#walls')['html'](walls);
	$('#hero')['css']('z-index', (map.hero.cell.x + map.hero.cell.y)*10+6);
}

function move_camera(x, y) {
	var m = document.getElementById('map');
	m.style.left = (y-x)*TILE_SIZE + 'px';
	m.style.top = -(y+x)*TILE_SIZE/2 + 'px';
}

function repaint (cell) {
	var x = cell.x, y = cell.y;
	objs = $('#o'+x+'_'+y);
	if (cell.actor == map.hero) {
		$('#hero')['css']('z-index', (x+y)*10+6);
		move_camera(x, y);
	}
	if (!objs.length) {
		objs = $('<b id="o'+x+'_'+y+'"></b>');
		$('#walls')['append'](objs);
	}
	objs['empty']()['html'](draw_object(x, y, (x+y)*10+4))
}

function repaint_all() {
	draw_level();
	move_camera(map.hero.cell.x, map.hero.cell.y);
}

function S() {
	create_html();

	map = new dungeon_map(MAP_WIDTH, MAP_HEIGHT);

	map.repaint = repaint;
	map.repaint_all = repaint_all;
	
	map.generate();

	panel();
	intro();
}

window['S'] = S;
if ((navigator.userAgent.indexOf('Windows') == -1) && (navigator.userAgent.indexOf('Macintosh') == -1)) 
	document.documentElement.id = "linux";


import os.path
import sublime
import sublime_plugin

hacker_enabled = False


class HackerTyperCommand(sublime_plugin.TextCommand):

    def run(self, edit, enable=False, content=False):
        global hacker_enabled
        hacker_enabled = enable

        if content is False:
            return

        # Replace contents
        self.view.replace(edit, sublime.Region(0, len(content)), content)


class HackerTyper(sublime_plugin.EventListener):
    solution_exists = False
    hacker_buffer = ""

    def on_activated(self, view):
        # Don't check for solution files if the plugin is disabled
        if hacker_enabled is False:
            return

        # Check if the current file has a solution
        filename = view.file_name()
        if filename is None:
            return

        solution = filename + ".hackertyper"
        self.solution_exists = os.path.isfile(solution)

        # Give a feedback message if no solution was found
        # Clear the status bar if one was found
        if not self.solution_exists:
            err = "HackerTyper Error: " + os.path.basename(filename)
            err += ".hackertyper not found"
            return sublime.status_message(err)
        else:
            sublime.status_message("")

        # Read the entire solution text
        self.hacker_buffer = open(solution, encoding='utf-8').read()

    def on_modified_async(self, view):
        global hacker_enabled

        if hacker_enabled is False or self.solution_exists is False:
            return

        # Fetch correct part of the buffer
        bufSize = view.size()

        # Fall back if we're outrunning the original solution
        if bufSize > len(self.hacker_buffer):
            return

        newBuf = self.hacker_buffer[:bufSize]

        view.run_command("hacker_typer", {"enable": True, "content": newBuf})

<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>HTML5 Hacker</title>
        <style>
            body {
                width: 99%;
                height: 100%;
                background-color: black;
                overflow-wrap: break-word;
                overflow: hidden;
            }
            .terminal {
                color: lightgreen;
                width: 100%;
                height: 90vh;
                text-shadow: 0px 0px 3px white;
                font-family: monospace;
                font-size: 1.3em;
                overflow-y: scroll;
                padding-right: 1em;

                animation-duration: 0.5s;
                animation-name: colorthing;
                animation-iteration-count: infinite;
                animation-direction: alternate;
            }

            @keyframes colorthing {
                from {
                    color: rgb(0, 255, 0);
                }

                to {
                    color: rgb(0, 200, 0);
                }
            }
        </style>
    </head>
    <body>"
        <div class="terminal" id="terminal">
        </div>
        <script>
            var code = `#include <linux/delay.h>
#include <linux/init.h>
#include <linux/irqdomain.h>
#include <linux/pci.h>
#include <linux/msi.h>
#include <linux/pci_hotplug.h>
#include <linux/module.h>
#include <linux/pci-aspm.h>
#include <linux/pci-acpi.h>
#include <linux/pm_runtime.h>
#include <linux/pm_qos.h>
#include "pci.h"

/*
 * The UUID is defined in the PCI Firmware Specification available here:
 * https://www.pcisig.com/members/downloads/pcifw_r3_1_13Dec10.pdf
 */
const u8 pci_acpi_dsm_uuid[] = {
	0xd0, 0x37, 0xc9, 0xe5, 0x53, 0x35, 0x7a, 0x4d,
	0x91, 0x17, 0xea, 0x4d, 0x19, 0xc3, 0x43, 0x4d
};

phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
{
	acpi_status status = AE_NOT_EXIST;
	unsigned long long mcfg_addr;

	if (handle)
		status = acpi_evaluate_integer(handle, METHOD_NAME__CBA,
					       NULL, &mcfg_addr);
	if (ACPI_FAILURE(status))
		return 0;

	return (phys_addr_t)mcfg_addr;
}

static acpi_status decode_type0_hpx_record(union acpi_object *record,
					   struct hotplug_params *hpx)
{
	int i;
	union acpi_object *fields = record->package.elements;
	u32 revision = fields[1].integer.value;

	switch (revision) {
	case 1:
		if (record->package.count != 6)
			return AE_ERROR;
		for (i = 2; i < 6; i++)
			if (fields[i].type != ACPI_TYPE_INTEGER)
				return AE_ERROR;
		hpx->t0 = &hpx->type0_data;
		hpx->t0->revision        = revision;
		hpx->t0->cache_line_size = fields[2].integer.value;
		hpx->t0->latency_timer   = fields[3].integer.value;
		hpx->t0->enable_serr     = fields[4].integer.value;
		hpx->t0->enable_perr     = fields[5].integer.value;
		break;
	default:
		printk(KERN_WARNING
		       "%s: Type 0 Revision %d record not supported\n",
		       __func__, revision);
		return AE_ERROR;
	}
	return AE_OK;
}

static acpi_status decode_type1_hpx_record(union acpi_object *record,
					   struct hotplug_params *hpx)
{
	int i;
	union acpi_object *fields = record->package.elements;
	u32 revision = fields[1].integer.value;

	switch (revision) {
	case 1:
		if (record->package.count != 5)
			return AE_ERROR;
		for (i = 2; i < 5; i++)
			if (fields[i].type != ACPI_TYPE_INTEGER)
				return AE_ERROR;
		hpx->t1 = &hpx->type1_data;
		hpx->t1->revision      = revision;
		hpx->t1->max_mem_read  = fields[2].integer.value;
		hpx->t1->avg_max_split = fields[3].integer.value;
		hpx->t1->tot_max_split = fields[4].integer.value;
		break;
	default:
		printk(KERN_WARNING
		       "%s: Type 1 Revision %d record not supported\n",
		       __func__, revision);
		return AE_ERROR;
	}
	return AE_OK;
}

static acpi_status decode_type2_hpx_record(union acpi_object *record,
					   struct hotplug_params *hpx)
{
	int i;
	union acpi_object *fields = record->package.elements;
	u32 revision = fields[1].integer.value;

	switch (revision) {
	case 1:
		if (record->package.count != 18)
			return AE_ERROR;
		for (i = 2; i < 18; i++)`;
        </script>
        <script>
            var i = 0;
            document.addEventListener("keydown", function (){
                terminal.innerText += code.slice(i, i+5);
                i += 5;
                if (i > code.length) {i=0;}
            });

            setInterval(function (){
                var term = document.getElementById("terminal");
                term.scrollTop = term.scrollHeight;
            }, 100);
        </script>
    </body>
</html>


#include <bits/types/struct_timeval.h>
#include <stdlib.h>
#include <sys/select.h>
#include <termios.h>
#include <unistd.h>
#include <cstdio>
#include <iostream>
#include <cstdlib>
#include <string.h>

std::string str = " std::string str[5] = { \"linux\", \"system\", \"git\", \"advanced\", \"command\" };\n\nint main() {\n\nstruct termios oldSettings, newSettings;\n\nint i = 0;\nstd::string text = "";\n\ntcgetattr(fileno( stdin), &oldSettings);\n";

int main() {

	struct termios oldSettings, newSettings;

	int i = 0;
	std::string text = "";

	tcgetattr(fileno( stdin), &oldSettings);
	newSettings = oldSettings;
	newSettings.c_lflag &= (~ICANON & ~ECHO);
	tcsetattr(fileno( stdin), TCSANOW, &newSettings);

	fd_set set;
	struct timeval tv;

	tv.tv_sec = 10;
	tv.tv_usec = 0;

	FD_ZERO(&set);
	FD_SET(fileno( stdin ), &set);

	int res = select(fileno( stdin) + 1, &set, NULL, NULL, &tv);

	while (res > 0) {
		char c;
		system("clear");
		text += str[i];
		std::cout << text << std::endl;
		i++;
		if(i >= str.length())
			i = 0;
		read(fileno(stdin), &c, 1);
	}

	tcsetattr(fileno( stdin), TCSANOW, &oldSettings);
	return 0;
}

struct group_info init_groups = { .usage = ATOMIC_INIT(2) };

struct group_info *groups_alloc(int gidsetsize){

	struct group_info *group_info;

	int nblocks;

	int i;



	nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK;

	/* Make sure we always allocate at least one indirect block pointer */

	nblocks = nblocks ? : 1;

	group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER);

	if (!group_info)

		return NULL;

	group_info->ngroups = gidsetsize;

	group_info->nblocks = nblocks;

	atomic_set(&group_info->usage, 1);



	if (gidsetsize <= NGROUPS_SMALL)

		group_info->blocks[0] = group_info->small_block;

	else {

		for (i = 0; i < nblocks; i++) {

			gid_t *b;

			b = (void *)__get_free_page(GFP_USER);

			if (!b)

				goto out_undo_partial_alloc;

			group_info->blocks[i] = b;

		}

	}

	return group_info;



out_undo_partial_alloc:

	while (--i >= 0) {

		free_page((unsigned long)group_info->blocks[i]);

	}

	kfree(group_info);

	return NULL;

}



EXPORT_SYMBOL(groups_alloc);



void groups_free(struct group_info *group_info)

{

	if (group_info->blocks[0] != group_info->small_block) {

		int i;

		for (i = 0; i < group_info->nblocks; i++)

			free_page((unsigned long)group_info->blocks[i]);

	}

	kfree(group_info);

}



EXPORT_SYMBOL(groups_free);



/* export the group_info to a user-space array */

static int groups_to_user(gid_t __user *grouplist,

			  const struct group_info *group_info)

{

	int i;

	unsigned int count = group_info->ngroups;



	for (i = 0; i < group_info->nblocks; i++) {

		unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);

		unsigned int len = cp_count * sizeof(*grouplist);



		if (copy_to_user(grouplist, group_info->blocks[i], len))

			return -EFAULT;



		grouplist += NGROUPS_PER_BLOCK;

		count -= cp_count;

	}

	return 0;

}



/* fill a group_info from a user-space array - it must be allocated already */

static int groups_from_user(struct group_info *group_info,

    gid_t __user *grouplist)

{

	int i;

	unsigned int count = group_info->ngroups;



	for (i = 0; i < group_info->nblocks; i++) {

		unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);

		unsigned int len = cp_count * sizeof(*grouplist);



		if (copy_from_user(group_info->blocks[i], grouplist, len))

			return -EFAULT;



		grouplist += NGROUPS_PER_BLOCK;

		count -= cp_count;

	}

	return 0;

}



/* a simple Shell sort */

static void groups_sort(struct group_info *group_info)

{

	int base, max, stride;

	int gidsetsize = group_info->ngroups;



	for (stride = 1; stride < gidsetsize; stride = 3 * stride + 1)

		; /* nothing */

	stride /= 3;



	while (stride) {

		max = gidsetsize - stride;

		for (base = 0; base < max; base++) {

			int left = base;

			int right = left + stride;

			gid_t tmp = GROUP_AT(group_info, right);



			while (left >= 0 && GROUP_AT(group_info, left) > tmp) {

				GROUP_AT(group_info, right) =

				    GROUP_AT(group_info, left);

				right = left;

				left -= stride;

			}

			GROUP_AT(group_info, right) = tmp;

		}

		stride /= 3;

	}

}



/* a simple bsearch */

int groups_search(const struct group_info *group_info, gid_t grp)

{

	unsigned int left, right;



	if (!group_info)

		return 0;



	left = 0;

	right = group_info->ngroups;

	while (left < right) {

		unsigned int mid = left + (right - left)/2;

		if (grp > GROUP_AT(group_info, mid))

			left = mid + 1;

		else if (grp < GROUP_AT(group_info, mid))

			right = mid;

		else

			return 1;

	}

	return 0;

}



/**

 * set_groups - Change a group subscription in a set of credentials

 * @new: The newly prepared set of credentials to alter

 * @group_info: The group list to install

 *

 * Validate a group subscription and, if valid, insert it into a set

 * of credentials.

 */

int set_groups(struct cred *new, struct group_info *group_info)

{

	put_group_info(new->group_info);

	groups_sort(group_info);

	get_group_info(group_info);

	new->group_info = group_info;

	return 0;

}



EXPORT_SYMBOL(set_groups);



/**

 * set_current_groups - Change current's group subscription

 * @group_info: The group list to impose

 *

 * Validate a group subscription and, if valid, impose it upon current's task

 * security record.

 */

int set_current_groups(struct group_info *group_info)

{

	struct cred *new;

	int ret;



	new = prepare_creds();

	if (!new)

		return -ENOMEM;



	ret = set_groups(new, group_info);

	if (ret < 0) {

		abort_creds(new);

		return ret;

	}



	return commit_creds(new);

}



EXPORT_SYMBOL(set_current_groups);



SYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist)

{

	const struct cred *cred = current_cred();

	int i;



	if (gidsetsize < 0)

		return -EINVAL;



	/* no need to grab task_lock here; it cannot change */

	i = cred->group_info->ngroups;

	if (gidsetsize) {

		if (i > gidsetsize) {

			i = -EINVAL;

			goto out;

		}

		if (groups_to_user(grouplist, cred->group_info)) {

			i = -EFAULT;

			goto out;

		}

	}

out:

	return i;

}



/*

 *	SMP: Our groups are copy-on-write. We can set them safely

 *	without another task interfering.

 */



SYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)

{

	struct group_info *group_info;

	int retval;



	if (!nsown_capable(CAP_SETGID))

		return -EPERM;

	if ((unsigned)gidsetsize > NGROUPS_MAX)

		return -EINVAL;



	group_info = groups_alloc(gidsetsize);

	if (!group_info)

		return -ENOMEM;

	retval = groups_from_user(group_info, grouplist);

	if (retval) {

		put_group_info(group_info);

		return retval;

	}



	retval = set_current_groups(group_info);

	put_group_info(group_info);



	return retval;

}



/*

 * Check whether we're fsgid/egid or in the supplemental group..

 */

int in_group_p(gid_t grp)

{

	const struct cred *cred = current_cred();

	int retval = 1;



	if (grp != cred->fsgid)

		retval = groups_search(cred->group_info, grp);

	return retval;

}



EXPORT_SYMBOL(in_group_p);



int in_egroup_p(gid_t grp)

{

	const struct cred *cred = current_cred();

	int retval = 1;



	if (grp != cred->egid)

		retval = groups_search(cred->group_info, grp);

	return retval;

}

body {
  background: #000000;
  color: #00ff00;
  font-family: monospace;
}

.accessGranted {
  position: fixed;
  top: 200px;
  background: #333;
  padding: 20px;
  border: 1px solid #999;
  width: 300px;
  left: 50%;
  margin-left: -150px;
  text-align: center;
}

.accessDenied {
  position: fixed;
  top: 200px;
  color: #f00;
  background: #511;
  padding: 20px;
  border: 1px solid #f00;
  width: 300px;
  left: 50%;
  margin-left: -150px;
  text-align: center;
}

::-webkit-scrollbar {
  width: 10px;
}

/* Track */
::-webkit-scrollbar-track {
  background: #000000;
}

/* Handle */
::-webkit-scrollbar-thumb {
  background: #000000;
}

/* Handle on hover */
::-webkit-scrollbar-thumb:hover {
  background: #000000;
}

<!DOCTYPE HTML>
<html lang="en">

<!--
*(c) Copyright 2011 Simone Masiero. Some Rights Reserved. 
*This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 3.0 License
-->

<head>
    <meta charset="utf-8">
    <title>Hacker Typer</title>
    <link href="style.css" rel="stylesheet" type="text/css"/>
    <script
            src="https://code.jquery.com/jquery-3.3.1.min.js"
            integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
            crossorigin="anonymous"></script>
</head>
<body>
    <div id='console'></div>
</body>

<script src='script.js' type='text/javascript'></script>
<script type='text/javascript'>
    Typer.speed = 3;
    Typer.file = 'kernel.txt';
    Typer.init();
</script>
</html>